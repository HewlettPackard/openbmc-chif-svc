#ifndef _DATAEXTRACT_INCLUDE_H_
#define _DATAEXTRACT_INCLUDE_H_
    
/**********************************************************************************************************
*  Copyright 2016-2025 Hewlett Packard Enterprise Development, LP
*
*  Confidential computer software. Valid license from Hewlett-Packard Enterprise required for possession,
*  use or copying. Consistent with FAR 12.211 and 12.212, Commercial Computer Software, Computer Software
*  Documentation, and Technical Data for Commercial Items are licensed to the U.S. Government under
*  vendor's standard commercial license.
*
**********************************************************************************************************/

/*!!!!IMPORTANT!!!!
**** PLEASE DO NOT EDIT THIS FILE. IT IS AUTO-GENERATED FROM CYPHER DATABASE.   *********
**** IF YOU HAVE QUESTIONS ABOUT THIS FILE, PLEASE CONTACT cypheradmins@hpe.com *********/

    
    
//
// Typedefs
//
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned int DWORD;
typedef unsigned long long QWORD;
    
//
// Miscellaneous
//
#define MAX_OID_DIGITS_MAPPED 6
#define MAX_EVT_VARIABLES 24
#define MAX_EVT_VAR_ENUMS 16
#define MAX_EVT_VAR_STR_LEN 487
#define EVT_MAX_SIZE 512
#define EVT_MAX_DESC_TEXT 384
#define EVT_MAX_ACTION_TEXT 256
#define MAX_TRAP_VARBINDS 13
#define MAX_OID_DIGITS 20
    
//
// Versioning Data
//
#define DATA_EXTRACT_MAJOR_NUMBER 1
#define DATA_EXTRACT_MINOR_NUMBER 594
#define DATA_EXTRACT_ERRATA_NUMBER 1
#define GEN_DATA_STRUCT_MAJOR_NUMBER 1
#define GEN_DATA_STRUCT_MINOR_NUMBER 0
#define GEN_DATA_STRUCT_ERRATA_NUMBER 0
#define TEXT_DATA_STRUCT_MAJOR_NUMBER 1
#define TEXT_DATA_STRUCT_MINOR_NUMBER 0
#define TEXT_DATA_STRUCT_ERRATA_NUMBER 0
#define VAR_DATA_STRUCT_MAJOR_NUMBER 1
#define VAR_DATA_STRUCT_MINOR_NUMBER 0
#define VAR_DATA_STRUCT_ERRATA_NUMBER 0
#define TRAP_DATA_STRUCT_MAJOR_NUMBER 1
#define TRAP_DATA_STRUCT_MINOR_NUMBER 0
#define TRAP_DATA_STRUCT_ERRATA_NUMBER 0
#define RIS_ALERT_DATA_STRUCT_MAJOR_NUMBER 1
#define RIS_ALERT_DATA_STRUCT_MINOR_NUMBER 0
#define RIS_ALERT_DATA_STRUCT_ERRATA_NUMBER 0
#define SER_EVENT_DATA_STRUCT_MAJOR_NUMBER 1
#define SER_EVENT_DATA_STRUCT_MINOR_NUMBER 0
#define SER_EVENT_DATA_STRUCT_ERRATA_NUMBER 0
    
//
// Event Severities
//
#define EVT_INFORMATIONAL 2
#define EVT_REPAIRED 6
#define EVT_CAUTION 9
#define EVT_CRITICAL 15
    
//
// Event Categories (and control defines)
//
//NOTE: When a new category is added here, it must be added to 'List_Category_Data[]' in iLO source code
#define EVT_CATEGORY_SECURITY 1
#define EVT_CATEGORY_HW_FAIL 2
#define EVT_CATEGORY_FW_FAIL 4
#define EVT_CATEGORY_MAINT 8
#define EVT_CATEGORY_ADMIN 16
#define EVT_CATEGORY_POWER 32
#define EVT_CATEGORY_COOL 64
#define EVT_CATEGORY_USR_INPUT 128
#define EVT_CATEGORY_OTHER 256
#define EVT_CATEGORY_CONFIG 512
#define EVT_CATEGORY_MAX 64
#define EVT_CATEGORY_IN_USE 10
#define EVT_CATEGORY_AVAILABLE 54
    
//
// Event Types
//
#define EVT_TYPE_IML 1
#define EVT_TYPE_IEL 2
#define EVT_TYPE_SL 3
    
//
// Event Reporting Entities
//
#define EVT_REP_ENTITY_ILO 1
#define EVT_REP_ENTITY_UEFI 2
#define EVT_REP_ENTITY_SA 4
#define EVT_REP_ENTITY_NIC 8
#define EVT_REP_ENTITY_AMS 16
#define EVT_REP_ENTITY_CHASSIS_MANAGER 32
    
//
// Event Log To AHS
//
#define AHS_LOG_NONE 0
#define AHS_LOG_DECODED 1
#define AHS_LOG_RAW 2
#define AHS_LOG_ALL 3
    
//
// Replace Flags
//
#define REPLACE_VALUE 1
#define REPLACE_DESC 2
    
//
// Representation
//
#define EVT_REP_INTEGER 1
#define EVT_REP_HEX 2
#define EVT_REP_STRING 3
    
//
// OID Types
//
#define OID_TYPE_STRING 4
#define OID_TYPE_INTEGER 5
#define OID_TYPE_IP_ADDRESS 6
    
//
// AHS Redaction Flags
//
#define EVT_REDACTION_DISABLED 0
#define EVT_REDACTION_ENABLED 1
    
//
// Event States
//
#define EVT_DISABLED 0
#define EVT_ENABLED 1
    
//************************************************************************************
//  Event Classes and Codes (codes for each class are indented)                       
//************************************************************************************
 
#define EVT_CLASS_EMPTY 0x00
 
#define EVT_CLASS_TEST 0x01
   #define EVT_TEST_IML_EVENT 0x0001
 
#define EVT_CLASS_MACHINE_ENV 0x02
   #define EVT_MACHINE_OVERHEAT 0x0013
   #define EVT_MACHINE_OVERHEAT_EXT_CHASSIS 0x0014
   #define EVT_MACHINE_OVERHEAT_STORAGE 0x0015
   #define EVT_MACHINE_OVERHEAT_ENCLOSURE 0x0016
   #define EVT_MACHINE_FAN_FAIL 0x0017
   #define EVT_MACHINE_FAN_FAIL_EXT_CHASSIS 0x0018
   #define EVT_MACHINE_FAN_FAIL_STORAGE 0x0019
   #define EVT_MACHINE_FAN_FAIL_ENCLOSURE 0x001A
   #define EVT_MACHINE_FAN_REMOVED 0x001B
   #define EVT_MACHINE_FAN_REMOVED_EXT_CHASSIS 0x001C
   #define EVT_MACHINE_FAN_REMOVED_STORAGE 0x001D
   #define EVT_MACHINE_FAN_REMOVED_ENCLOSURE 0x001E
   #define EVT_MACHINE_FAN_INSERTED 0x001F
   #define EVT_MACHINE_FAN_INSERTED_EXT_CHASSIS 0x0020
   #define EVT_MACHINE_FAN_INSERTED_STORAGE 0x0021
   #define EVT_MACHINE_FAN_INSERTED_ENCLOSURE 0x0022
   #define EVT_MACHINE_FAN_NOT_REDUNDANT 0x0023
   #define EVT_MACHINE_FAN_NOT_REDUNDANT_EXT_CHASSIS 0x0024
   #define EVT_MACHINE_FAN_NOT_REDUNDANT_STORAGE 0x0025
   #define EVT_MACHINE_FAN_NOT_REDUNDANT_ENCLOSURE 0x0026
   #define EVT_MACHINE_CRITICAL_OVERHEAT 0x0027
   #define EVT_MACHINE_CRITICAL_OVERHEAT_THRESHOLD 0x0028
   #define EVT_MACHINE_CRITICAL_OVERHEAT_EXT_CHASSIS 0x0029
   #define EVT_MACHINE_CRITICAL_OVERHEAT_EXT_STORAGE 0x002A
   #define EVT_MACHINE_CRITICAL_OVERHEAT_ENCLOSURE 0x002B
   #define EVT_MACHINE_DISK_OVERHEAT 0x002C
   #define EVT_INTRUSION_HARDWARE_INSTALLED 0x002D
   #define EVT_INTRUSION_HARDWARE_REMOVAL 0x002E
   #define EVT_HOOD_REMOVAL 0x002F
   #define EVT_HOOD_REPLACED 0x0030
   #define EVT_MACHINE_FAN_FAIL_SAS 0x0031
   #define EVT_OVERHEAT_SAS 0x0032
   #define EVT_MACHINE_FAN_DEGRADE 0x0033
   #define EVT_MACHINE_INSUFFICIENT_FANS 0x0034
   #define EVT_INSUFFICIENT_PSUS 0x0035
   #define EVT_CHASSIS_CONTROLLER_COMM 0x0036
   #define EVT_PMB_REMOVED 0x0037
   #define EVT_THERMAL_REBOOT_SUCCESS 0x0038
   #define EVT_PRE_CAUTION_THRES_EXCEED 0x0039
   #define EVT_MIN_FAN_SPEED_SETTING 0x003A
   #define EVT_MACHINE_LIQUID_COOLED_PUMP_FAIL 0x003B
   #define EVT_MACHINE_LIQUID_COOLING_PUMP_DEGRADED 0x003C
   #define EVT_MACHINE_LIQUID_COOLING_NOT_REDUNDANT 0x003D
   #define EVT_USER_DEF_CAUT_THRES_EXCEED 0x003F
   #define EVT_USER_DEF_CRIT_THRES_EXCEED 0x0040
   #define EVT_MACHINE_LIQUID_COOLING_PUMP_MISSING 0x0042
   #define EVT_TEMP_SENSOR_STALE 0x0043
   #define EVT_TEMP_SENSOR_STALE_2_66 0x0068
   #define EVT_NO_ACTIVE_RECORDS_FOUND_FOR_LC_MODULE 0x0069
   #define EVT_ERROR_READING_CREATING_WARRANTY_FILE 0x006A
   #define EVT_LIQUID_COOLING_TIME_LAPSED_WARNING_1 0x006B
   #define EVT_LIQUID_COOLING_TIME_LAPSED_WARNING_2 0x006C
   #define EVT_LIQUID_COOLING_TIME_LAPSED 0x006D
   #define EVT_AIR_FILTER_TIME_LAPSED_REMINDER_1 0x006E
   #define EVT_AIR_FILTER_TIME_LAPSED_FINAL_REMINDER 0x006F
   #define EVT_TEMP_SENSOR_STALE_2_66_1 0x0070
   #define EVT_CHASSIS_HOOD_REMOVAL 0x0071
   #define EVT_LIQUID_COOLING_LEAKAGE_DETECTED 0x0089
 
#define EVT_CLASS_MAIN_MEMORY 0x03
   #define EVT_DIMM_CORR_ERROR 0x0001
   #define EVT_DIMM_UNCORR_ERROR 0x0002
   #define EVT_DIMM_HOT 0x0003
   #define EVT_DIMM_VRD_HOT 0x0004
   #define EVT_DIMM_VRD_FAULT_WARN 0x0005
   #define EVT_DIMM_IE_MCTP_FAIL 0x0006
   #define EVT_DIMM_UNCORR_ERROR_MISC 0x0007
   #define EVT_DDR_INIT_FAILURES 0x0008
   #define EVT_DIMM_CONFIG_FAILURE 0x0009
   #define EVT_MEM_UNCORRECTABLE_ERROR 0x000B
 
#define EVT_CLASS_CACHE_MEMORY 0x04
 
#define EVT_CLASS_CPU 0x05
   #define EVT_CPU_UNCORR_MCE 0x0003
   #define EVT_AMD_CPU_UNCORR_MCE 0x0004
   #define EVT_PROCESSOR_INITIALIZATION_ERROR 0x0005
   #define EVT_SYS_PROC_PROP 0x0006
   #define EVT_CPU_THROTTLING_ENABLED 0x0007
   #define EVT_PROC_FAULT_OR_UNRECOVERR 0x0008
   #define EVT_PROC_CORR_ERROR 0x0009
   #define EVT_PROC_CRIT_STOP 0x000A
   #define EVT_RAS_INT_ERROR 0x000B
   #define EVT_BOOT_ERROR 0x000C
   #define EVT_SOC_VRD_FAULT_WARN 0x000D
   #define EVT_SOC_VRD_HOT 0x000E
   #define EVT_CORE_VRD_FAULT_WARN 0x000F
   #define EVT_CORE_VRD_HOT 0x0010
   #define EVT_CPU_UNC_ERROR 0x0011
   #define EVT_CPU_THROTTLING_DETECTED 0x0012
   #define EVT_AMD_FATAL_ERROR_ADDC 0x0013
   #define EVT_AMD_FATAL_ERROR_ADDC_1 0x0014
   #define EVT_CPU_THROTTLING_DETECTED_2_66 0x0016
   #define EVT_EVT_CPU_MISMTACH 0x0018
   #define EVT_PROC_UNCORRECTABLE_ERROR 0x0019
 
#define EVT_CLASS_HOST_BUS 0x06
   #define EVT_UPI_ERROR 0x0003
 
#define EVT_CLASS_EISA_BUS 0x07
 
#define EVT_CLASS_PCI_BUS 0x08
   #define EVT_PCIE_SLOT_ERROR 0x0002
   #define EVT_PCIE_NVME_ERROR 0x0003
   #define EVT_PCIE_SLOT_ERROR_NO_AER 0x0004
   #define EVT_PCIE_NVME_ERROR_NO_AER 0x0005
   #define EVT_PCIE_CORR_ERROR 0x0006
   #define EVT_PCIE_UNCORR_ERROR 0x0007
   #define EVT_PCIE_UNCORR_ERROR_AER 0x0008
   #define EVT_OCP_SLOT_ERROR 0x000A
   #define EVT_OCP_SLOT_ERROR_NO_AER 0x000B
   #define EVT_PCIE_UNCORRECTABLE_ERROR 0x000C
 
#define EVT_CLASS_EXPANSION_SLOT 0x09
 
#define EVT_CLASS_POST 0x0A
   #define EVT_OPROM_PCIE_DEVICE_INVALID 0x0101
   #define EVT_DIMM_CFG_ERR_ASR_TIMER 0x0104
   #define EVT_DIMM_INIT_MAPOUT 0x0218
   #define EVT_PWR_FAIL_FLEX_MEZZ 0x0225
   #define EVT_PWR_FAIL_EBD_STOR 0x0226
   #define EVT_PWR_FAIL_M2 0x0227
   #define EVT_SRIOV_NON_SRIOV_SLOT 0x0244
   #define EVT_SW1_SW3_ON 0x0251
   #define EVT_NON_INS_PROC_PCIE_SLT 0x0254
   #define EVT_NVM_CORRUPTION 0x0266
   #define EVT_NVRAM_RBSU_CFG_RESET 0x0267
   #define EVT_NVM_VAR_CORRUPTION 0x0268
   #define EVT_NVRAM_RBSU_CFG_RESTORE 0x0269
   #define EVT_ILO_FW_COM_FAIL_OLD 0x0270
   #define EVT_COUNTERFEIT_SMART_MEM 0x0272
   #define EVT_OPTION_MMIO_REQ_ERROR 0x0276
   #define EVT_SW12_ON 0x0281
   #define EVT_INVALID_SN_PID 0x0282
   #define EVT_DIMM_UNC_MEM_ERR 0x0284
   #define EVT_STOR_DEV_MISSING_BOOT_ORDER 0x0286
   #define EVT_NIC_DEV_MISSING_BOOT_ORDER 0x0287
   #define EVT_STOR_DEV_ADD_BOOT_ORDER 0x0288
   #define EVT_NIC_DEV_ADD_BOOT_ORDER 0x0289
   #define EVT_DEFAULT_IPL_ERR 0x0291
   #define EVT_SW_RAID_CHG_MODE 0x0292
   #define EVT_SW1_ON 0x0297
   #define EVT_SM_STOR_BATT_CFG_ERR_EXCEED_CAP 0x0311
   #define EVT_SM_STOR_BATT_FAIL_COM_FAIL 0x0312
   #define EVT_UNCORR_MEM_ERR_PRIOR_BOOT 0x0315
   #define EVT_SM_STOR_BATT_NVDIMM_UNSUPP 0x0316
   #define EVT_UNEXPECTED_SHUTDOWN 0x0319
   #define EVT_ENC_PWR_EVTEVT_BOOT_DELAY 0x0320
   #define EVT_DUAL_SD_CFG_ERR_ONE_NOT_INST 0x0321
   #define EVT_DUAL_SD_CFG_ERR_ALL_NOT_INST 0x0322
   #define EVT_DUAL_SD_CFG_ERR_ONE_FAIL 0x0323
   #define EVT_DUAL_SD_CFG_ERR_ALL_FAIL 0x0324
   #define EVT_DUAL_SD_CFG_ERR_CONFLICT_META_DATA 0x0325
   #define EVT_DUAL_SD_CFG_ERR_SLTX_FAIL_SLT1_ABSENT 0x0326
   #define EVT_CPU_AMP_MODE_ERROR 0x0327
   #define EVT_PMC_FW_ERR_REC_MODE 0x0328
   #define EVT_PMC_FW_ERR_COM_FW 0x0329
   #define EVT_RESTFUL_API_ERR_COM_ILO_FAIL_RESET_ILO 0x0333
   #define EVT_RESTFUL_API_ERR_GET_REQ_FAIL 0x0334
   #define EVT_RESTFUL_API_ERR_PUT_REG_FAIL 0x0335
   #define EVT_RESTFUL_API_ERR_COM_ILO_FAIL 0x0338
   #define EVT_NVDIMM_BACKUP_ERR 0x0340
   #define EVT_NVDIMM_RESTORE_ERR 0x0341
   #define EVT_NVDIMM_UNC_ERR 0x0342
   #define EVT_NVDIMM_BACKUP_PWR_ERR 0x0343
   #define EVT_NVDIMM_CTRL_ERR 0x0344
   #define EVT_NVDIMM_ERASE_ERR 0x0345
   #define EVT_NVDIMM_ARMING_ERR 0x0346
   #define EVT_SM_STOR_BATT_NOT_CHARGED_WAIT 0x0351
   #define EVT_SM_STOR_BATT_NOT_CHARGED_NO_WAIT 0x0352
   #define EVT_PASSWORD_CRC_FAIL 0x0353
   #define EVT_NVDIMM_SANI_OK 0x0355
   #define EVT_NVDIMM_SANI_FAIL 0x0356
   #define EVT_NVDIMM_NON_SMART_MEM 0x0357
   #define EVT_NVDIMM_NOT_SUPP_BY_CPLD 0x0360
   #define EVT_INVALID_PROC_RAPL_WATT 0x0361
   #define EVT_INVALID_DIMM_RAPL_WATT 0x0362
   #define EVT_NVDIMM_SET_GUID_MISMATCH 0x0363
   #define EVT_NVDIMM_FW_ERROR 0x0364
   #define EVT_NEW_NVDIMM_INTERLEAVE_ON 0x0371
   #define EVT_NEW_NVDIMM_INTERLEAVE_OFF 0x0372
   #define EVT_NVDIMM_REMOVED_INTERLEAVE_ON 0x0373
   #define EVT_MRC_ERR_INTERLEAVE_ON 0x0374
   #define EVT_MRC_ERR_INTERLEAVE_OFF 0x0375
   #define EVT_NVDIMM_INTERLEAVE_ON 0x0376
   #define EVT_NVDIMM_INTERLEAVE_OFF 0x0377
   #define EVT_PROC_TYPE_INTERLEAVE_ON 0x0378
   #define EVT_PROC_TYPE_INTERLEAVE_OFF 0x0379
   #define EVT_NVDIMM_CFG_ERR_SNC_ON 0x0382
   #define EVT_NVDIMM_CFG_ERR_SNC_OFF 0x0383
   #define EVT_CHNL_INTERLEAVE_ON 0x0384
   #define EVT_CHNL_INTERLEAVE_OFF 0x0385
   #define EVT_METADATA_CORRUPTED_INTERLEAVE_ON 0x0386
   #define EVT_METADATA_CORRUPTED_INTERLEAVE_OFF 0x0387
   #define EVT_MEMORY_MAP_CHANGED 0x0388
   #define EVT_NUMA_NOT_SUPPORTED 0x0391
   #define EVT_AMP_MODE_NOT_SUPPORTED 0x0392
   #define EVT_SYSTEM_GUID_MISMATCH 0x0393
   #define EVT_NVDIMM_EVT_NOTIFY_ERR_INFO 0x0394
   #define EVT_NVDIMM_PERSIS_LOST_ERR_INFO 0x0395
   #define EVT_NVDIMM_PERSIS_RESTORE_INFO 0x0396
   #define EVT_NVDIMM_LIFECYCLE_WARN 0x0397
   #define EVT_NVDIMM_SLOT_BACKUP_POWER_ERROR 0x0398
   #define EVT_NVDIMM_EXTENDED_DIAGS_INFO 0x0399
   #define EVT_CHASSIS_HOOD_NOT_INSTALLED 0x0400
   #define EVT_CHASSIS_HOOD_REMOVED 0x0401
   #define EVT_IE_FW_ERR 0x0410
   #define EVT_SPS_FW_ERR 0x0414
   #define EVT_TLS_CFG_VERIFY_FAILED 0x0420
   #define EVT_TLS_CFG_HOSTNAME_MISMATCH 0x0421
   #define EVT_TLS_CFG_DEPTH_ZERO_SELF_SIGNED_CERT 0x0422
   #define EVT_TLS_CFG_UNABLE_TO_GET_ISSUER_CERT 0x0423
   #define EVT_TLS_CFG_NO_CERT_INSTALLED 0x0424
   #define EVT_DIMM_CORRECTED_ERROR_THRESHOLD 0x0460
   #define EVT_DIMM_CORRECTED_ERROR_RATE 0x0461
   #define EVT_DIMM_UNC_MIRROR_ENGAGED 0x0463
   #define EVT_DIMM_ONLINE_SPARE_COPY_STARTED 0x0464
   #define EVT_DIMM_ONLINE_SPARE_COPY_DONE 0x0465
   #define EVT_CHANNEL_CORRECTED_ERROR_THRESHOLD 0x0466
   #define EVT_PROC_UNC_ERROR 0x0467
   #define EVT_ELOG_UCE_DETECTED 0x0469
   #define EVT_NVDIMM_FW_UPDATE_SUCCESS 0x0480
   #define EVT_NVDIMM_FW_UPDATE_ERROR 0x0481
   #define EVT_NVDIMM_FW_IMAGE_INVALID 0x0482
   #define EVT_ILO_CRITICAL_HEALTH_SHUTDOWN 0x0490
   #define EVT_ILO_CRITICAL_HEALTH_HALT 0x0491
   #define EVT_ASR_NMI_DETECTED 0x0500
   #define EVT_IPMI_WATCHDOG_NMI_DETECTED 0x0501
   #define EVT_APP_WATCHDOG_NMI_DETECTED 0x0502
   #define EVT_INVALID_BP_CFG 0x0521
   #define EVT_IPT_CORE_BOOST_DISABLED 0x0530
   #define EVT_IPT_CORE_BOOST_MISSING_ILO_LICENSE 0x0531
   #define EVT_ARM_MAX_PERFORMANCE_DISABLED 0x0532
   #define EVT_NVME_FW_UPDATE_SUCCESS 0x0550
   #define EVT_NVME_FW_UPDATE_ERROR 0x0551
   #define EVT_AEP_FW_UPDATE_SUCCESS 0x0552
   #define EVT_AEP_FW_UPDATE_ERROR 0x0553
   #define EVT_DEVICE_FW_UPDATE_SUCCESS 0x0554
   #define EVT_TPM_FW_UPDATE_ERROR 0x0555
   #define EVT_PCIE_FW_UPDATE_SUCCESS 0x0558
   #define EVT_PCIE_FW_UPDATE_ERROR 0x0559
   #define EVT_AEP_GOAL_CONFIG_FIRMWARE_ERRORS 0x0575
   #define EVT_AEP_GOAL_CONFIG_DIMM_NOT_FOUND_ERRORS 0x0576
   #define EVT_AEP_GOAL_CONFIG_MEMORY_REQUEST_ERRORS 0x0577
   #define EVT_AEP_GOAL_CONFIG_INTERLEAVE_ERRORS 0x0578
   #define EVT_AEP_BOOT_STATUS_REGISTER_WARNING 0x0579
   #define EVT_AEP_RSVD_GOAL_CONFIG_CREATE_FAIL 0x0580
   #define EVT_PMEM_READ_SCAN 0x0581
   #define EVT_ILO_DISCOVERY_RETRY 0x0585
   #define EVT_ILO_DISCOVERY_FAILED 0x0586
   #define EVT_UNSUP_PS_CFG_UNSUP_DETECT 0x1626
   #define EVT_TPM_MODULE_ERR 0x1636
   #define EVT_SA_HII_NORMAL_STRING 0x1700
   #define EVT_SA_MEM_SELFTEST_ERROR 0x1703
   #define EVT_SA_CACHE_BATTERY_REPLACE 0x1705
   #define EVT_SA_BOOTSTRAP_NV_CHECKSUM_FAIL 0x1707
   #define EVT_SA_BOOTSTRAP_NV_RESTORED 0x1708
   #define EVT_SA_DRIVE_NOT_HP_DRIVE 0x1709
   #define EVT_SA_STRIPE_SIZE_TOO_LARGE_RAID56 0x1711
   #define EVT_SA_RED_REPROG_FAIL 0x1713
   #define EVT_SA_RED_CHECKSUM_ERROR 0x1714
   #define EVT_SA_MEM_ERROR 0x1715
   #define EVT_SA_UC_MEDIA_ERROR 0x1716
   #define EVT_SA_DRIVE_OVERHEAT 0x1717
   #define EVT_SA_SOME_DRIVE_IGNORED 0x1718
   #define EVT_SA_CONTROLLER_FAIL 0x1719
   #define EVT_SA_SMART_DETECT_FAILURE 0x1720
   #define EVT_SA_DRIVE_POS_CHANGE 0x1724
   #define EVT_SA_CACHE_SIZE_OR_BATT_CHANGE 0x1726
   #define EVT_SA_NEW_DRIVE 0x1727
   #define EVT_SA_SHUTDOWN_WB_CACHE_ENABLED 0x1728
   #define EVT_SA_OPTIMAL_SCAN 0x1729
   #define EVT_SA_ENC_FW_UPGRADE_ERROR 0x1733
   #define EVT_SA_ENC_PATH_CONFIG_ERROR 0x1735
   #define EVT_SA_RED_CABLE_EXCEED 0x1737
   #define EVT_SA_ENCL_RED_CABLE_EXCEED 0x1738
   #define EVT_SA_RED_CABLE_NOT_RECOMMENDED 0x1739
   #define EVT_SA_DRIVE_ERASE_IN_PROGRESS 0x1744
   #define EVT_SA_DRIVE_ERASE_COMPLETED 0x1745
   #define EVT_SA_CACHE_FLASH_ERASED 0x1749
   #define EVT_SA_RAID_LV_CONFIG_INVALID 0x1754
   #define EVT_SA_CAPACITY_EXP_TEMP_DIS 0x1764
   #define EVT_SA_RESUMEING_LD_CAPACITY 0x1768
   #define EVT_SA_DRVE_DIS_FAIL_EXPAN 0x1769
   #define EVT_SA_DRIVE_FW_UPGRADE_RECOMMENDED 0x1770
   #define EVT_SA_OBSOLETE_DATA_IN_CACHE 0x1774
   #define EVT_SA_STOR_ENC_ERROR 0x1777
   #define EVT_SA_RESUMING_AUTO_DATA 0x1778
   #define EVT_SA_RP_DRIVE_DETECTED 0x1779
   #define EVT_SA_DRIVE_ARRAY_CONTROLLER_FAIL 0x1783
   #define EVT_SA_LD_FAIL 0x1784
   #define EVT_SA_DRIVE_ARRAY_NOT_CONFIG 0x1785
   #define EVT_SA_DRIVE_ARRAY_RECOV_NEEDED 0x1786
   #define EVT_SA_DRIVE_ARRAY_DEGRADED_MODE 0x1787
   #define EVT_SA_DRIVE_ARRAY_INCORRECT_DRIVE_REPLACEMENT 0x1788
   #define EVT_SA_DRIVE_ARRAY_NOT_RESPONDING 0x1789
   #define EVT_SA_VALID_DATA_IN_WB_CACHE 0x1792
   #define EVT_SA_DATA_IN_WB_CACHE_LOST 0x1793
   #define EVT_SA_CACHE_BATT_CHARGING 0x1794
   #define EVT_SA_WB_CACHE_CONFIG_ERROR 0x1795
   #define EVT_SA_CACHE_NOT_RESPONDING 0x1796
   #define EVT_SA_WB_CACHE_BACKUP_FAIL 0x1797
   #define EVT_SA_DRIVE_ARRAY_CACHE_SELFTEST_FAIL 0x1798
   #define EVT_SA_DRIVE_ARRAY_DRIVE_DIS_WB_CACHE_LOSS 0x1799
   #define EVT_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_DIS_CONTROLLER 0x1804
   #define EVT_SA_DRIVE_ARRAY_SUPER_CAP_NOT_INST 0x1805
   #define EVT_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_DIS_ACCESS 0x1808
   #define EVT_CRYPTO_COMM_FAIL 0x1809
   #define EVT_CRYPTO_MASTER_KEY_FAIL 0x1810
   #define EVT_CRYPTO_DRIVE_KEY_GET_FAIL 0x1811
   #define EVT_CRYPTO_DRIVE_KEY_INVALID 0x1812
   #define EVT_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_CHARGING_FAIL 0x1813
   #define EVT_CYRPTO_COMM_SLOT_FAIL 0x1814
   #define EVT_SA_ENCRY_FAIL_LD_OFFLINE_PW_FAIL 0x1815
   #define EVT_SA_ENCRY_FAIL_LD_NOT_ENCRYPTED 0x1816
   #define EVT_SA_ENCRY_EN_CONTROLLER_MASTER_KEY_NOT_SET 0x1817
   #define EVT_SA_ENCRY_FAIL_KM_MODE_MISMATCH 0x1818
   #define EVT_SA_ENCRY_FAIL_UNSUPP_ROM 0x1819
   #define EVT_SA_ENCRY_FAIL_ENCRY_LD_OFFLINE 0x1820
   #define EVT_SA_ENCRY_FAIL_FW_VER_NOT_SUPPORT_ENCRY 0x1821
   #define EVT_CRYPTO_MASTER_KEY_IMPORT 0x1822
   #define EVT_SA_ENCRY_FAIL_UNSUPPOR_ILO_FW 0x1823
   #define EVT_SA_STOR_CABLE_FAIL_DISCOV 0x1824
   #define EVT_SA_ENCRY_FAIL_NV_CORRUPT 0x1825
   #define EVT_SA_ENCRY_FAIL_ENCRY_ENG_FAIL 0x1826
   #define EVT_SA_DRIVE_ARRAY_DATA_IN_WB_LOST 0x1831
   #define EVT_SA_DRIVE_NOT_EXPOSED 0x1832
   #define EVT_SA_UNSUPPOR_ARRAY_CONFIG 0x1833
   #define EVT_SA_CTRL_FW_UPDATE_PENDING 0x1834
   #define EVT_SA2_DRIVE_ARRAY_CONTROLLER_FAIL 0x1900
   #define EVT_SA2_CONTROLLER_FAIL 0x1901
   #define EVT_SA2_DRIVE_ARRAY_NOT_CONFIG 0x1902
   #define EVT_SA2_MEM_ERROR 0x1903
   #define EVT_SA2_RED_REPROG_FAIL 0x1904
   #define EVT_SA2_RED_CHECKSUM_ERROR 0x1905
   #define EVT_SA2_DRIVE_ARRAY_CONFIG_NOT_COMMIT 0x1906
   #define EVT_SA2_CONTROLLER_DEGRADED 0x1907
   #define EVT_SA2_CONTROLLER_BOOT_PASSWORD 0x1908
   #define EVT_SA2_DRIVE_NOT_HP_DRIVE 0x1910
   #define EVT_SA2_DRIVE_FAIL 0x1911
   #define EVT_SA2_DRIVE_OVERHEAT 0x1912
   #define EVT_SA2_DRIVE_ERASE_IN_PROGRESS 0x1913
   #define EVT_SA2_SMART_DETECT_FAILURE 0x1914
   #define EVT_SA2_DRIVE_MEDIA_ERROR 0x1915
   #define EVT_SA2_STOR_ENC_ERROR 0x1920
   #define EVT_SA2_ENC_FW_UPGRADE_ERROR 0x1921
   #define EVT_SA2_SOME_DRIVE_IGNORED 0x1922
   #define EVT_SA2_CONTROLLER_LINK_ERROR 0x1923
   #define EVT_SA2_VALID_DATA_IN_WB_CACHE 0x1930
   #define EVT_SA2_DATA_IN_WB_CACHE_LOST 0x1931
   #define EVT_SA2_WB_CACHE_CONFIG_ERROR 0x1932
   #define EVT_SA2_CACHE_BATT_NOT_PRESENT 0x1934
   #define EVT_SA2_CACHE_BATT_CHARGING 0x1935
   #define EVT_SA2_DRIVE_ARRAY_CACHE_SELFTEST_FAIL 0x1936
   #define EVT_SA2_CACHE_BATT_CABLE_MISSING 0x1937
   #define EVT_SA2_LD_FAIL 0x1940
   #define EVT_SA2_MISSING_LOGICAL_DRIVE 0x1941
   #define EVT_SA2_DRIVE_ARRAY_NOT_RESPONDING 0x1942
   #define EVT_SA2_RAID_LV_CONFIG_INVALID 0x1943
   #define EVT_SA2_IMPORT_FOREIGN_CONFIG 0x1944
   #define EVT_SA2_DEGRADED_LOGICAL_DRIVE 0x1945
   #define EVT_SA2_DISABLED_LOGICAL_DRIVE 0x1946
   #define EVT_SLTX_SAN_ERR_LNK_DN_2 0x2100
   #define EVT_SLTX_SAN_ERR_FABRIC_LOGIN_FAIL_2 0x2101
   #define EVT_SLTX_SAN_ERR_NAME_SERVER_LOGIN_FAIL_2 0x2102
   #define EVT_SLTX_SAN_ERR_NO_TARGET_2 0x2103
   #define EVT_SLTX_SAN_ERR_ADP_RST_2 0x2104
   #define EVT_SLTX_ERR_VPD_NA_2 0x2105
   #define EVT_SLTX_NIC_ERR_2 0x2106
   #define EVT_SLTX_ERR_FW_UPDATE_FAIL_2 0x2107
   #define EVT_SLTX_ERR_FW_RECOVERY_FAIL_2 0x2108
   #define EVT_SLTX_ERR_APPLY_VC_FAIL_2 0x2109
   #define EVT_SLTX_ERR_CONTROLLER_IO_TO_2 0x2110
   #define EVT_SLTX_SCSI_ERR_ACQ_DHCP_INIT_ADR 0x2111
   #define EVT_SLTX_SCSI_ERR_ACQ_DHCP_TARG_ADR 0x2112
   #define EVT_SLTX_SCSI_ERR_ACQ_DHCP_ISNS_ADR_2 0x2113
   #define EVT_ISCSI_ERR_LOGIN_2 0x2114
   #define EVT_ISCSI_ERR_BOOT_LUN_2 0x2115
   #define EVT_ISCSI_ERR_FW_NOT_RE_RDY_2 0x2116
   #define EVT_SLTX_MODULE_ERROR_2 0x2119
   #define EVT_SLTX_NVM_OLD_2 0x2120
   #define EVT_SLTX_NVM_NEW_2 0x2121
   #define EVT_SLTX_NVM_NEW_STOP_2 0x2122
   #define EVT_DIMM_CORRECTED_ERROR 0x2150
   #define EVT_SEC_BOOT_ENROLL_PK 0x2202
   #define EVT_SEC_BOOT_ENROLL_KEK 0x2203
   #define EVT_SEC_BOOT_ENROLL_DB 0x2204
   #define EVT_SEC_BOOT_ENROLL_DBX 0x2205
   #define EVT_SEC_BOOT_ENROLL_DBT 0x2206
   #define EVT_SEC_BOOT_RESET_ALL 0x2207
   #define EVT_SEC_BOOT_RESET_KEK 0x2208
   #define EVT_SEC_BOOT_RESET_PK 0x2209
   #define EVT_SEC_BOOT_RESET_DB 0x2210
   #define EVT_SEC_BOOT_RESET_DBX 0x2211
   #define EVT_SEC_BOOT_RESET_DBT 0x2212
   #define EVT_SEC_BOOT_DEL_VAR_ALL 0x2213
   #define EVT_SEC_BOOT_DEL_VAR_PK 0x2214
   #define EVT_SEC_BOOT_DEL_VAR_KEK 0x2215
   #define EVT_SEC_BOOT_DEL_VAR_DB 0x2216
   #define EVT_SEC_BOOT_DEL_VAR_DBX 0x2217
   #define EVT_SEC_BOOT_DEL_VAR_DBT 0x2218
   #define EVT_SEC_BOOT_DEL_ENTRY_KEK 0x2219
   #define EVT_SEC_BOOT_DEL_ENTRY_DB 0x2220
   #define EVT_SEC_BOOT_DEL_ENTRY_DBX 0x2221
   #define EVT_SEC_BOOT_DEL_ENTRY_DBT 0x2222
   #define EVT_SEC_BOOT_EN_DIS_FAIL 0x2223
   #define EVT_SEC_BOOT_ENROLL_FAIL 0x2224
   #define EVT_SEC_BOOT_RESET_FAIL 0x2225
   #define EVT_SEC_BOOT_DEL_VAR_FAIL 0x2226
   #define EVT_SEC_BOOT_DEL_ENTRY_FAIL 0x2227
   #define EVT_TEST_EVENT 0x2319
   #define EVT_ILO_TEST_CERT_FOUND 0x2320
   #define EVT_SLTX_SAN_ERR_LNK_DN 0x2400
   #define EVT_SLTX_SAN_ERR_FABRIC_LOGIN_FAIL 0x2401
   #define EVT_SLTX_SAN_ERR_NAME_SERVER_LOGIN_FAIL 0x2402
   #define EVT_SLTX_SAN_ERR_NO_TARGET 0x2403
   #define EVT_SLTX_SAN_ERR_ADP_RST 0x2404
   #define EVT_SLTX_ERR_VPD_NA 0x2405
   #define EVT_SLTX_NIC_ERR 0x2406
   #define EVT_SLTX_ERR_FW_UPDATE_FAIL 0x2407
   #define EVT_SLTX_ERR_FW_RECOVERY_FAIL 0x2408
   #define EVT_SLTX_ERR_APPLY_VC_FAIL 0x2409
   #define EVT_SLTX_ERR_CONTROLLER_IO_TO 0x2410
   #define EVT_ISCSI_ERR_CLIENT 0x2411
   #define EVT_ISCSI_ERR_TARGET 0x2412
   #define EVT_SLTX_SCSI_ERR_ACQ_DHCP_ISNS_ADR 0x2413
   #define EVT_ISCSI_ERR_LOGIN 0x2414
   #define EVT_ISCSI_ERR_BOOT_LUN 0x2415
   #define EVT_ISCSI_ERR_FW_NOT_RE_RDY 0x2416
   #define EVT_SLTX_MODULE_ERROR 0x2419
   #define EVT_SLTX_NVM_OLD 0x2420
   #define EVT_SLTX_NVM_NEW 0x2421
   #define EVT_SLTX_NVM_NEW_STOP 0x2422
   #define EVT_SLTX_FW_RECOVERY_MODE 0x2423
   #define EVT_SLTX_CRITICAL_DATA_CORRUPTED 0x2424
   #define EVT_SLTX_TOPOLOGY_MEDIA_CONFLICT 0x2425
   #define EVT_SLTX_FW_ROLLBACK_MODE 0x2426
   #define EVT_TPM_BINDING_SUCCESS 0x3100
   #define EVT_TPM_NOT_BINDING 0x3101
   #define EVT_SERVER_CONFIG_LOCK_PCI_NVME_MISMATCH 0x3104
   #define EVT_TL_ON_UNSUPPORTED_SLOT 0x3105
   #define EVT_SERVER_CONFIG_LOCK_DIMM_MISMATCH 0x3106
   #define EVT_SERVER_CONFIG_LOCK_SYSTEM_BOARD_MISMATCH 0x3107
   #define EVT_SERVER_CONFIG_LOCK_CPU_MISMATCH 0x3108
   #define EVT_SERVER_CONFIG_LOCK_PCI_SLOT_MISMATCH 0x3109
   #define EVT_SERVER_CONFIG_LOCK_SECURITY_CONFIG_MISMATCH 0x3110
   #define EVT_SERVER_CONFIG_LOCK_FIRMWARE_CONFIG_MISMATCH 0x3111
   #define EVT_AEP_CAUTION_HEALTH_STATE_FAILURE 0x3113
   #define EVT_AEP_CRITICAL_HEALTH_STATE_FAILURE 0x3115
   #define EVT_AEP_FATAL_HEALTH_STATE_FAILURE 0x3116
   #define EVT_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_CAUTION 0x3117
   #define EVT_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_WARNING 0x3118
   #define EVT_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_CRITICAL 0x3119
   #define EVT_AEP_LAST_SHUTDOWN_STATE_WARNING 0x3120
   #define EVT_TOR_TIMEOUT_SLOT_ERROR 0x3121
   #define EVT_TOR_TIMEOUT_NVME_ERROR 0x3127
   #define EVT_PS_NUMBER_RED_CFG_MISMATCH 0x3130
   #define EVT_TPM_SECURE_ERASE_FAIL 0x3134
   #define EVT_AEP_SECURE_ERASE_PASS 0x3136
   #define EVT_AEP_SECURE_ERASE_FAIL 0x3137
   #define EVT_SPI_SECURE_ERASE_FAIL 0x3140
   #define EVT_ENABLE_ENCRYPTION_FOR_DCPMM_FAILED 0x3143
   #define EVT_DISABLE_ENCRYPTION_FOR_DCPMM_FAILED 0x3145
   #define EVT_PASSPHRASE_MODIFICATION_FOR_DCPMM_FAILED 0x3146
   #define EVT_DCPMM_LOCKED_UNTIL_NEXT_BOOT 0x3148
   #define EVT_ENCRYPTION_POLICY_CHANGED_TO_LKMS 0x314A
   #define EVT_ENCRYPTION_FOR_DCPMM_DISABLED 0x314B
   #define EVT_ENCRYPTION_PASSPHRASE_MODIFIED_FOR_DCPMM 0x314C
   #define EVT_ATTEMPTING_UNLOCK_DCPMM_SUCCESS 0x314E
   #define EVT_SATA_ERASE_FAILURE 0x3150
   #define EVT_SMART_ARRAY_DISK_SECURE_ERASE_FAIL 0x3151
   #define EVT_NVMe_ERASE_FAILURE 0x3152
   #define EVT_ENCRYPTION_POLICY_CHANGED_TO_RKMS 0x3154
   #define EVT_ENCRYPTION_FOR_DCPMM_ENABLED 0x3155
   #define EVT_AEP_STATUS_SOCKET_INTERLEAVING_NOT_SUPPORTED 0x3156
   #define EVT_AEP_STATUS_MISSING_DIMM_IN_INTERLEAVED_SET 0x3157
   #define EVT_PCICONFIG_RESET_ERASE_FAIL 0x3158
   #define EVT_AEP_STATUS_INTERLEAVED_DIMMS_POPULATED_IN_WRONG_ORDER 0x3159
   #define EVT_AEP_STATUS_CHANNEL_INTERLEAVING_NOT_SUPPORTED 0x315B
   #define EVT_AEP_STATUS_NEW_DIMM_POPULATED_IN_SYSTEM 0x315C
   #define EVT_IE_DIAGNOSTIC_MODE 0x3160
   #define EVT_JITTER_FREE_FREQUENCY_NOT_FOUND 0x3161
   #define EVT_SERVER_CONFIG_LOCK_UNEXPECTED_ERROR 0x3162
   #define EVT_SECURE_ERASE_ATTEMPT_COUNT 0x3164
   #define EVT_IE_IMAGE_CORRUPTION 0x3165
   #define EVT_ESKM_CONNECTION_FAILURE 0x3166
   #define EVT_CPU_X64_EXCEPTION 0x3167
   #define EVT_ENABLE_ENCRYPTION_FOR_OPAL_FAILED 0x3168
   #define EVT_DISABLE_ENCRYPTION_FOR_OPAL_FAILED 0x3169
   #define EVT_PASSPHRASE_MODIFICATION_FOR_OPAL_FAILED 0x316A
   #define EVT_OPAL_LOCKED_UNTIL_NEXT_BOOT 0x316B
   #define EVT_ENCRYPTION_PASSPHRASE_MODIFIED_FOR_OPAL 0x316C
   #define EVT_ATTEMPTING_UNLOCK_OPAL_SUCCESS 0x316E
   #define EVT_ENCRYPTION_FOR_OPAL_DISABLED 0x316F
   #define EVT_KEY_MANAGEMENT_MODE_DISABLED 0x3171
   #define EVT_ENCRYPTION_FOR_OPAL_ENABLED 0x3172
   #define SECLOG_SED_PASSPHRASE_MODIFIED 0x3173
   #define SECLOG_RKMS_POLICY_CHANGE 0x3174
   #define SECLOG_LKMS_POLICY_CHANGE 0x3175
   #define SECLOG_DCPMM_DEVICE_ENCRYPTION_ENABLED 0x3176
   #define SECLOG_DCPMM_DEVICE_ENCRYPTION_DISABLED 0x3177
   #define SECLOG_DCPMM_DEVICE_PASSPHRASE_MODIFIED 0x3178
   #define SECLOG_DCPMM_DEVICE_UNLOCKED 0x3179
   #define SECLOG_DCPMM_UNLOCK_EXCESSIVE_FAILURES 0x317A
   #define SECLOG_RBSU_PASSWORD_ADDED 0x317B
   #define SECLOG_RBSU_PASSWORD_REMOVED 0x317C
   #define SECLOG_RBSU_PASSWORD_CHANGED 0x317D
   #define SECLOG_RBSU_LOGIN_EXCESSIVE_FAILURES 0x317E
   #define SECLOG_RBSU_LOGIN_VIA_ILO_ALLOWED 0x317F
   #define SECLOG_RBSU_LOGIN_VIA_ILO_DISABLED 0x3180
   #define SECLOG_INTELLIGENT_PROVISIONING_ENABLED 0x3181
   #define SECLOG_INTELLIGENT_PROVISIONING_DISABLED 0x3182
   #define SECLOG_BACKUP_ROM_AUTHENTICATION_DISABLED 0x3183
   #define SECLOG_BACKUP_ROM_AUTHENTICATION_ENABLED 0x3184
   #define SECLOG_AES_NI_SUPPORT_ENABLED 0x3185
   #define SECLOG_AES_NI_SUPPORT_DISABLED 0x3186
   #define SECLOG_ONE_TIME_BOOT_MENU_ENABLED 0x3187
   #define SECLOG_ONE_TIME_BOOT_MENU_DISABLED 0x3188
   #define SECLOG_INTRUSION_DETECTION_ENABLED 0x3189
   #define SECLOG_INTRUSION_DETECTION_DISABLED 0x318A
   #define SECLOG_INTEL_TXT_ENABLED 0x318B
   #define SECLOG_INTEL_TXT_DISABLED 0x318C
   #define SECLOG_SL_ILO_TEST_CERT_DETECTED 0x318D
   #define EVT_DEBUG_IE_INSTALLED_IML 0x318F
   #define SECLOG_SECURE_BOOT_ENABLED 0x3191
   #define SECLOG_SECURE_BOOT_DISABLED 0x3192
   #define SECLOG_TLS_STRICT_HOSTNAME_CHECK_ENABLED 0x3193
   #define SECLOG_TLS_STRICT_HOSTNAME_CHECK_DISABLED 0x3194
   #define SECLOG_TLS_PEER_CERTIFICATE_VALIDATION_ENABLED 0x3195
   #define SECLOG_TLS_PEER_CERTIFICATE_VALIDATION_DISABLED 0x3196
   #define SECLOG_TLS_ALL_CERTIFICATES_DELETED 0x3197
   #define SECLOG_TLS_EXPORT_CERTS 0x3198
   #define EVT_DCPMM_PERSIS_LOST_ERR_INFO 0x3199
   #define SECLOG_SECURE_BOOT_KEY_RESET 0x319A
   #define SECLOG_SECURE_BOOT_KEY_DELETED 0x319B
   #define SECLOG_SECURE_BOOT_KEY_EXPORTED 0x319C
   #define SECLOG_SECURITY_TLS_CFG_UNABLE_TO_GET_ISSUER_CERT 0x319F
   #define SECLOG_SECURITY_TLS_CFG_DEPTH_ZERO_SELF_SIGNED_CERT 0x31A0
   #define SECLOG_SECURITY_TLS_CFG_HOSTNAME_MISMATCH 0x31A1
   #define SECLOG_SECURITY_TLS_CONFIG_RESET 0x31A2
   #define SECLOG_SECURITY_TLS_CIPHERS_UPDATED 0x31A3
   #define SECLOG_SECURITY_TLS_CERTIFICATE_ADDED 0x31A4
   #define SECLOG_SECURITY_TLS_CERTIFICATE_DELETED 0x31A5
   #define SECLOG_SECURITY_TLS_VERSION_CHANGED 0x31A6
   #define SECLOG_SECURITY_TLS_HOSTNAME_VERIFY_ENABLED 0x31A7
   #define SECLOG_SECURITY_TLS_HOSTNAME_VERIFY_DISABLED 0x31A8
   #define SECLOG_NVRAM_RBSU_CFG_RESTORE 0x31A9
   #define EVT_PCIE_EDPC_DETECTION 0x31AC
   #define EVT_PCIE_EDPC_DETECTION_NVME 0x31AD
   #define SECLOG_SECURE_BOOT_AUTH_FAIL_CERT2 0x31AE
   #define SECLOG_SECURE_BOOT_AUTH_FAIL2 0x31AF
   #define EVT_DIMM_CONFIG_NOT_VALIDATED 0x31B3
   #define EVT_DIMM_CONFIG_NOT_VALIDATED_ERR 0x31B4
   #define EVT_ENERGY_SOURCE_NOT_CHARGED_WAIT 0x31B5
   #define EVT_ENERGY_SOURCE_NOT_CHARGED_NO_WAIT 0x31B6
   #define EVT_NVDIMM_BACKUP_PWR_ERROR 0x31B7
   #define EVT_EDPC_OPTION_NOT_SUPP_BY_OS 0x31B8
   #define SECLOG_SL_SERVER_CONFIG_LOCK_ENABLED 0x31B9
   #define SECLOG_SL_SERVER_CONFIG_LOCK_DISABLED 0x31BA
   #define SECLOG_SGX_HW_CONFIG_INVALID 0x31BB
   #define EVT_SANITIZE_CONTROLLER_SECURE_ERASE_FAIL 0x31BC
   #define EVT_FACTORY_PCIE_ERROR_EXCEEDED 0x31BD
   #define EVT_TPM_UNSUPPORTED_VERSION 0x31BE
   #define SECLOG_SECURED_CORE_ENABLED 0x31C0
   #define SECLOG_SECURED_CORE_DISABLED 0x31C1
   #define EVT_PMEM_CURRENT_BSR_WARNING 0x31C3
   #define EVT_SERVER_CONFIG_LOCK_PASSWORD_FAIL2 0x31C4
   #define EVT_PWR_FAIL_OCP 0x31C6
   #define EVT_EVT_SMARTNIC_TIMEOUT 0x31C7
   #define EVT_SMARTIO_INIT_ERROR 0x31C8
   #define EVT_SMARTIO_ABSENT 0x31C9
   #define EVT_SMARTIO_TOKEN_NOT_READY 0x31CA
   #define EVT_PCIE_EDPC_DETECTION_EVENT 0x31CB
   #define EVT_SMBUS_RECOVERY_FAIL_G10PLUS 0x31CE
   #define EVT_HBM_UNC_MEM_ERR 0x31D1
   #define EVT_HBM_CORRECTED_ERROR_THRESHOLD 0x31D2
   #define EVT_DIMM_CFG_POP_ORDER_FIFTH 0x31D3
   #define EVT_SMARTIO_REMOVED_FROM_PCI_BUS 0x31D4
   #define EVT_HBM_UCE_MAPOUT 0x31D5
   #define EVT_DIMM_INIT_MAPOUT_CHANNEL 0x31D6
   #define EVT_NVMEOF_ERR_CLIENT 0x31D7
   #define EVT_NVMEOF_ERR_TARGET 0x31D8
   #define EVT_NVMEOF_ERR_BOOT_NID 0x31D9
   #define EVT_SPS_FIRMWARE_UPDATE_ERROR 0x31DA
   #define EVT_AMD_EMCR_FEATURE_DISABLED 0x31DB
   #define EVT_NVMEOF_ERR_LOGIN 0x31DC
   #define EVT_NON_BOOTABLE_FIXED_DRIVE_BOOT_OPTION_DISABLE 0x31DD
   #define EVT_NVME_HOTPLUG_SYNC_ERROR 0x31DE
   #define EVT_OCP_NVMEOF_ERR_CLIENT 0x31DF
   #define EVT_OCP_NVMEOF_ERR_TARGET 0x31E0
   #define EVT_OCP_NVMEOF_ERR_BOOT_NID 0x31E1
   #define EVT_OCP_NVMEOF_ERR_LOGIN 0x31E2
   #define EVT_OCP_ISCSI_ERR_CLIENT 0x31E3
   #define EVT_OCP_ISCSI_ERR_TARGET 0x31E4
   #define EVT_OCP_ISCSI_ERR_LOGIN 0x31E5
   #define EVT_OCP_ISCSI_ERR_BOOT_LUN 0x31E6
   #define EVT_NVMe_SECURE_ERASE_FAILURE 0x31E7
   #define EVT_NVMe_SECURE_ERASE_START_COMPLETE 0x31E8
   #define EVT_MEM_SPEED_CHANGE_TO_AUTO 0x31E9
   #define EVT_PCIE_EDR_FAIL_EVENT 0x31EA
   #define EVT_PCIE_EDR_FAIL_NVME 0x31EB
 
#define EVT_CLASS_POWER_SUPPLY 0x0B
   #define EVT_PS_MISMATCH 0x0015
   #define EVT_PS_EFUSE_FAULT 0x001B
   #define EVT_PS_NOT_DETECTED 0x001C
   #define EVT_PS_STORBAT_REMOVED 0x001E
   #define EVT_PS_POWER_ON_DENIED 0x0024
   #define EVT_PS_FAILURE 0x0028
   #define EVT_PS_FAILURE_EXT_CHASSIS 0x0029
   #define EVT_PS_FAILURE_STORAGE 0x002A
   #define EVT_PS_FAILURE_ENCLOSURE 0x002B
   #define EVT_PS_REMOVED 0x002C
   #define EVT_PS_REMOVED_EXT_CHASSIS 0x002D
   #define EVT_PS_REMOVED_STORAGE 0x002E
   #define EVT_PS_REMOVED_ENCLOSURE_ADDR 0x002F
   #define EVT_PS_REMOVED_ENCLOSURE_SERIAL 0x0030
   #define EVT_PS_INSERTED 0x0031
   #define EVT_PS_INSERTED_EXT_CHASSIS 0x0032
   #define EVT_PS_INSERTED_STORAGE 0x0033
   #define EVT_PS_INSERTED_ENCLOSURE_ADDR 0x0034
   #define EVT_PS_INSERTED_ENCLOSURE_SERIAL 0x0035
   #define EVT_PS_NOT_REDUNDANT 0x0036
   #define EVT_PS_NOT_REDUNDANT_EXT_CHASSIS 0x0037
   #define EVT_PS_NOT_REDUNDANT_STORAGE 0x0038
   #define EVT_PS_NOT_REDUNDANT_ENCLOSURE_SERIAL 0x003A
   #define EVT_PS_NOT_REDUNDANT_ENCLOSURE_ADDR 0x003B
   #define EVT_PS_SERVER_POWER_FAULT 0x003C
   #define EVT_PS_SERVER_POWER_FAULT_OVERLOAD 0x003D
   #define EVT_PS_STORBAT_FAILED 0x003E
   #define EVT_PS_STORBAT_FAILED_INFO_3 0x003F
   #define EVT_PS_STORBAT_FAILED_INFO_4 0x0040
   #define EVT_PS_STORBAT_FAILED_INFO_5 0x0041
   #define EVT_PS_STORBAT_FAILED_INFO_7 0x0042
   #define EVT_PS_STORBAT_FAILED_INFO_11 0x0043
   #define EVT_PS_FAILURE_SAS 0x0044
   #define EVT_PS_AC_LOST 0x0052
   #define EVT_PS_SERVER_PWR_EXCEEDED_REDUNDANT_WARN_LIMIT 0x0053
   #define EVT_PS_RECOVERABLE_FAILURE 0x0054
   #define EVT_PS_BBU_FAILURE 0x0055
   #define EVT_PS_STORBAT_PREFAIL_INFO_12 0x0056
   #define EVT_PS_BBU_DISCHARGING 0x0057
   #define EVT_PPA_DISABLED 0x0058
   #define EVT_PS_SERVER_PWR_EXCEEDED_LIMIT 0x0059
   #define EVT_PS_UNSUPPORTED 0x0090
   #define EVT_MCRPS_OVER_CURRENT_WARNING 0x0092
   #define EVT_MCRPS_OVER_CURRENT_FAULT 0x0093
   #define EVT_MCRPS_OVER_TEMPERATURE_WARNING 0x0094
   #define EVT_MCRPS_OVER_TEMPERATURE_FAULT 0x0095
   #define EVT_PDB_UNSUPPORTED 0x0096
   #define EVLOG_UBB_PWR_ALERT 0x0097
 
#define EVT_CLASS_UPS 0x0C
 
#define EVT_CLASS_ASR 0x0D
   #define EVT_ASR_DETECTED 0x0001
   #define EVT_ASR_LIMIT 0x0003
   #define EVT_ME_FD0V_DURING_AUTO_POWER_ON 0x0004
 
#define EVT_CLASS_OS 0x0E
   #define EVT_OS_AUTO_SHUTDOWN 0x0002
   #define EVT_OS_NMI_DUMP_SWITCH 0x0004
   #define EVT_OS_VIRTUAL_NMI_DUMP_SWITCH 0x0006
 
#define EVT_CLASS_DIAGS 0x0F
 
#define EVT_CLASS_NETWORK_ADAPTER 0x11
   #define EVT_NIC_LINK_DOWN_1 0x0008
   #define EVT_NIC_LINK_DOWN_2 0x0009
   #define EVT_NIC_LINK_CONNECTIVITY_LOST 0x000A
   #define EVT_FCA_HOST_CNTRL_STATUS_CHANGE 0x000B
   #define EVT_NIC_LINK_REDUNDANCY_LOST 0x000C
   #define EVT_NIC_ALL_LINK_CONNECTIVITY_LOST 0x000D
   #define EVT_NIC_SOME_LINK_CONNECTIVITY_UP 0x000E
   #define EVT_DPU_SMARTNIC 0x000F
   #define EVT_NIC_LINK_CONNECTIVITY_UP_DOWN 0x0010
   #define EVT_NIC_CONFIG_CHANGE 0x0011
 
#define EVT_CLASS_SCSI_SUBSYSTEM 0x12
   #define EVT_iSCSI_LINK_UP 0x0001
   #define EVT_iSCSI_LINK_DOWN 0x0002
 
#define EVT_CLASS_DRIVEARRAY_SUBSYSTEM 0x13
   #define EVT_ARRAY_CTRL_FAILED_1 0x0012
   #define EVT_ARRAY_CTRL_FAILED_2 0x0013
   #define EVT_ARRAY_DEVICE_FAILED_SAS_1 0x0014
   #define EVT_ARRAY_SAS_SMART_WEAR_ERROR_1 0x0015
   #define EVT_ARRAY_DEVICE_PREDICT_FAIL_SAS_1 0x0016
   #define EVT_IDA_ACCEL_STAT_CHG 0x0017
   #define EVT_CARRIER_AUTH_FAILURE 0x0018
   #define EVT_PHY_DRIVE_STATUS 0x001E
   #define EVT_SAS_PHY_DRIVE_WEAR_STATUS_CHANGE 0x001F
   #define EVT_IDE_ATA_DISK_STATUS_CHANGE 0x0020
   #define EVT_IDA_LOG_DRV_STATUS_CHANGE 0x0021
   #define EVT_IDA_ACCEL_BADDATA 0x0023
   #define EVT_IDA_ACCEL_BATT_FAILED 0x0024
   #define EVT_STSYS_FAN_STAT_CHG 0x0028
   #define EVT_STSYS_TEMP_STAT_CHG 0x0029
   #define EVT_STSYS_PWR_STAT_CHG 0x002A
   #define EVT_STSYS_CONN_STAT_CHG 0x002B
   #define EVT_IDA_SPR_STAT_CHG 0x002C
   #define EVT_ARRAY_DEVICE_DRIVE_INSERTED_REMOVED 0x002F
   #define EVT_IDE_ATA_DISK_STATUS_CHANGE2 0x0030
   #define EVT_IDE_ATA_DISK_DRIVE_WEAR_STATUS_CHANGE2 0x0033
   #define EVT_IDE_SATA_DISK_WEAR_STATUS_CHANGE 0x0052
 
#define EVT_CLASS_UNRECOV_SYSTEM_ERR 0x14
   #define EVT_UNRECOVERABLE_IO_ERROR 0x0005
   #define EVT_UNCORR_CRITICAL_FAULT 0x0007
   #define EVT_UNRECOV_INPUT_PWR_ERROR 0x0008
   #define EVT_TVS_FUSE 0x0009
   #define EVT_INPUT_POWER_LOSS 0x000A
   #define EVT_POWER_ON_FAULT 0x000B
   #define EVT_RUNTIME_FAULT 0x000C
   #define EVT_CORR_ERROR 0x000D
   #define EVT_UNCORR_ERROR 0x000E
   #define EVT_UNCORR_ERROR_2P_ALI_WITH_LINK 0x000F
   #define EVT_UNCORR_ERROR_WITH_ROOT_COMPLEX 0x0010
   #define EVT_UNCORR_ERROR_2P_CCIX_WITH_LINK 0x0011
   #define EVT_UNCORR_ERROR_RASDP_WITH_ROOT_COMPLEX 0x0012
   #define EVT_UNCORR_ERROR_MISC 0x0013
   #define EVT_MEZZANINE_CARD_FAULT 0x0016
   #define EVT_CPU_ERROR_CODE 0x0131
 
#define EVT_CLASS_SYSTEM_REV 0x20
   #define EVT_FIRMWARE_FLASHED 0x0002
   #define EVT_FI 0x0003
   #define EVT_FI_REP_FAIL 0x0004
   #define EVT_FW_SCAN_RECOVERY_COMPLETE 0x0007
   #define EVT_FW_RECOVERY_REQUEST 0x0008
   #define EVT_ME_FD0V_FAILED 0x0009
   #define EVT_FW_VER_MATCH_FAILED 0x000A
   #define EVT_S3M_BOOT_FAIL 0x000C
   #define EVT_BIOS_FIRMWARE_UPDATE 0x000D
   #define EVT_BIOS_VERSION_MISMATCH 0x000E
 
#define EVT_CLASS_MAINTENANCE 0x21
   #define EVT_MAINT_IML_CLEARED 0x0001
   #define EVT_MAINT_NOTE 0x0002
   #define EVT_SECURE_SYSTEM_ERASE_STATUS 0x0003
   #define SECLOG_SECURITY_LOG_CLEARED 0x0004
   #define SECLOG_AHS_CLEARED 0x0006
   #define SECLOG_SEC_JUMPER_ON 0x0007
   #define SECLOG_SEC_JUMPER_OFF 0x0009
   #define EVT_CORRUPTION_DETECTED 0x000A
   #define SECLOG_CORRUPTION_DETECTED 0x000B
   #define EVT_FACTORY_CA_ABOUT_TO_EXPIRE 0x000D
 
#define EVT_CLASS_INFRASTRUCTURE_ENVIRONMENT 0x22
   #define EVT_ENCL_INADEQUATE_POWER_ENC_SERIAL 0x001B
   #define EVT_ENCL_INADEQUATE_POWER_ENC_ADDR 0x001C
   #define EVT_ENCL_RACK_INFRASTRUCTURE_RCK_NAME_CHG_1 0x001D
   #define EVT_ENCL_RACK_INFRASTRUCTURE_RCK_NAME_CHG_2 0x001E
   #define EVT_ENCL_RACK_INFRASTRUCTURE_NAME_CHG1 0x001F
   #define EVT_ENCL_RACK_INFRASTRUCTURE_NAME_CHG2 0x0020
   #define EVT_ENCL_RACK_INFRASTRUCTURE_SERVICE_CHG_1 0x0021
   #define EVT_ENCL_RACK_INFRASTRUCTURE_SERVICE_CHG_2 0x0022
   #define EVT_ENCL_RACK_INFRASTRUCTURE_NAME_CONFLICT_1 0x0023
   #define EVT_ENCL_RACK_INFRASTRUCTURE_NAME_CONFLICT_2 0x0024
   #define EVT_ENCL_RACK_INFRASTRUCTURE_UID_CHG_1 0x0025
   #define EVT_ENCL_RACK_INFRASTRUCTURE_UID_CHG_2 0x0026
   #define EVT_ENCL_RACK_INFRASTRUCTURE_LAN_CHG_1 0x0027
   #define EVT_ENCL_RACK_INFRASTRUCTURE_LAN_CHG_2 0x0028
   #define EVT_ENCL_RACK_INFRASTRUCTURE_UID_LED_CHG_1 0x0029
   #define EVT_ENCL_RACK_INFRASTRUCTURE_UID_LED_CHG_2 0x002A
   #define EVT_ENCL_RACK_INFRASTRUCTURE_CHG_1 0x002B
   #define EVT_ENCL_RACK_INFRASTRUCTURE_CHG_2 0x002C
   #define EVT_ENCL_INFRASTRUCTURE_FIRMWARE_MISMATCH_1 0x002D
   #define EVT_ENCL_INFRASTRUCTURE_FIRMWARE_MISMATCH_2 0x002E
   #define EVT_ENCL_POWER_REQUEST_DENIED_1 0x002F
   #define EVT_ENCL_POWER_REQUEST_DENIED_2 0x0030
 
#define EVT_IOP_SYSTEM 0x23
   #define EVLOG_POWER_OFF 0x0001
   #define EVLOG_POWER_ON 0x0003
   #define EVLOG_HOST_RESET 0x0005
   #define EVLOG_FAILED_LOGIN 0x0006
   #define EVLOG_FLINT_RESET 0x0009
   #define EVLOG_FLINT_CLOCK_SET 0x000A
   #define EVLOG_CLEARED 0x000D
   #define EVLOG_FLINT_RESET_DIAGS 0x0016
   #define EVLOG_FLINT_RESET_FACTORY_DEFAULTS 0x0017
   #define EVLOG_FLINT_RESET_UNEXPECTED 0x0019
   #define EVLOG_FLINT_RESET_ROM_UPGRADE 0x001B
   #define EVLOG_SYSTEM_HALTED 0x003F
   #define EVLOG_NIC_LINK_DOWN 0x0049
   #define EVLOG_NIC_LINK_UP 0x004A
   #define EVLOG_FW_UPGRADE 0x005A
   #define EVLOG_FAILED_FLASH 0x0061
   #define EVLOG_SEC_JUMPER_ON 0x0068
   #define EVLOG_SEC_JUMPER_OFF 0x0069
   #define EVLOG_RACK_POWER_REQUEST_SOURCE 0x0073
   #define EVLOG_XML_FAILED_FLASH 0x007C
   #define EVLOG_LIC_FEATURE_ACCESS 0x0080
   #define EVLOG_LIC_ADD_2 0x0081
   #define EVLOG_LIC_REMOVE_2 0x0082
   #define EVLOG_LIC_FAILURE_2 0x0083
   #define EVLOG_USER_ADDED_2 0x0084
   #define EVLOG_USER_DELETED_2 0x0085
   #define EVLOG_USER_MODIFIED_2 0x0086
   #define EVLOG_CLEARED_BY_USER_2 0x0087
   #define EVLOG_MAINT 0x0089
   #define EVLOG_VMEDIA_FLOPPY_CONN_2 0x008A
   #define EVLOG_VMEDIA_FLOPPY_DISCON_2 0x008B
   #define EVLOG_SERVER_PWROFF_BY_USER_2 0x008C
   #define EVLOG_SERVER_PWRON_BY_USER_2 0x008D
   #define EVLOG_SERVER_RESET_BY_USER_2 0x008E
   #define EVLOG_VIRTUAL_NMI_2 0x008F
   #define EVLOG_RBSU_LOGIN_2 0x0093
   #define EVLOG_RBSU_EXIT 0x0094
   #define EVLOG_UPGRADED_FIRMWARE_VERSION 0x0097
   #define EVLOG_VIRTUAL_MEDIA_TIMEOUT 0x0098
   #define EVLOG_LIC_EXPIRED 0x0099
   #define EVLOG_CLI_LOGIN 0x009F
   #define EVLOG_CLI_LOGOUT 0x00A0
   #define EVLOG_CLI_FAILED_LOGIN 0x00A1
   #define EVLOG_VMEDIA_SCRIPT_CONN 0x00A8
   #define EVLOG_VMEDIA_SCRIPT_DISCON 0x00A9
   #define EVLOG_DCLI_BOOTORDER_SET 0x00AC
   #define EVLOG_OLD_HOST_ROM 0x00AD
   #define EVLOG_DUPLICATE_IP 0x00AF
   #define EVLOG_POWER_REGULATOR_SETTING_CHANGED 0x00B2
   #define EVLOG_BMC_WDT_RESET 0x00B3
   #define EVLOG_AES_ENFORCE_ENABLE 0x00B5
   #define EVLOG_AES_ENFORCE_DISABLE 0x00B6
   #define EVLOG_SSO_SRV_ADD 0x00B7
   #define EVLOG_SSO_SRV_DEL 0x00B8
   #define EVLOG_SSO_TRUST_CHANGE 0x00B9
   #define EVLOG_SSO_ROLE_CHANGE 0x00BA
   #define EVLOG_SSO_LOGIN_FAIL_ENABLED 0x00BD
   #define EVLOG_SSO_LOGIN_FAIL 0x00BE
   #define EVLOG_SSO_LOGIN_FAIL_NO_SIM 0x00BF
   #define EVLOG_SSO_LOGIN_FAIL_CERT 0x00C0
   #define EVLOG_SCRIPTED_VM_ERROR 0x00C5
   #define EVLOG_FLASH_COMPLETED 0x00CD
   #define EVLOG_THRESHOLD_BREACHED 0x00CE
   #define EVLOG_OA_TIME_SYNC 0x00D5
   #define EVLOG_FLINT_RESET_NETWORK 0x00DE
   #define EVLOG_RBSU_FAILED_LOGIN 0x00E2
   #define EVLOG_VMEDIA_HTTP_ERR 0x00E3
   #define EVLOG_SSL_CERT_INSTALLED 0x00E4
   #define EVLOG_SHARED_SESSION_CLOSED 0x00E5
   #define EVLOG_SHARED_SESSION_OPENED 0x00E6
   #define EVLOG_RESET_FOR_NEW_HW 0x00E7
   #define EVLOG_CHANGED_POWER_CAP 0x00E8
   #define EVLOG_HW_PWR_LOSS 0x00E9
   #define EVLOG_DISABLED_POWER_CAP 0x00EA
   #define EVLOG_PMC_UPDATE_START 0x00EB
   #define EVLOG_PMC_UPDATE_FAIL 0x00EC
   #define EVLOG_PMC_UPDATE_COMPLETE 0x00ED
   #define EVLOG_UDC_ACTIVATED 0x00F2
   #define EVLOG_UDC_DEACTIVATED 0x00F3
   #define EVLOG_EMBMEDIA_EVENT_FAIL 0x00F4
   #define EVLOG_EMBMEDIA_EVENT_CAUTION 0x00F5
   #define EVLOG_EMBMEDIA_EVENT_INFO 0x00F6
   #define EVLOG_AHS_CLEARED 0x00F9
   #define EVLOG_AHS_ENABLED 0x00FA
   #define EVLOG_AHS_DISABLED 0x00FB
   #define EVLOG_BB_HW_DISABLED 0x0101
   #define EVLOG_BB_HW_ENABLED 0x0102
   #define EVLOG_LANGPAK_ADD 0x0103
   #define EVLOG_LANGPAK_REMOVE 0x0104
   #define EVLOG_CLI_FAILED_FLASH 0x0105
   #define EVLOG_AUX_POWER_CYCLED_FOR_UPDATE 0x0106
   #define EVLOG_COMP_FAILED_FLASH 0x0107
   #define EVLOG_APO_REMAIN_OFF 0x0108
   #define EVLOG_APO_RESTORED_ON 0x0109
   #define EVLOG_APO_RESTORED_STANDBY 0x010A
   #define EVLOG_APO_ATTEMPTING_POWER_ON 0x010B
   #define EVLOG_BROWNOUT_APO_OFF 0x010C
   #define EVLOG_BROWNOUT_RECOVER 0x010D
   #define EVLOG_LOGIN_BANNER_ENABLED 0x010E
   #define EVLOG_LOGIN_BANNER_DISABLED 0x010F
   #define EVLOG_RIBCL_SET_ASSET_TAG 0x0110
   #define EVLOG_SET_SERVER_NAME 0x0111
   #define EVLOG_SSO_SRV_REC_DEL 0x0112
   #define EVLOG_ROMSWAP 0x0114
   #define EVLOG_SSH_KEY_ADD 0x0115
   #define EVLOG_SSH_KEY_DEL 0x0116
   #define EVLOG_BB_RIBCL_CLEARED 0x0117
   #define EVLOG_XML_FAILED_UPGRADE 0x011D
   #define EVLOG_SNMP_CFG_MODIFIED 0x011F
   #define EVLOG_ALERTMAIL_MODIFIED 0x0120
   #define EVLOG_SYSLOG_MODIFIED 0x0121
   #define EVLOG_HOST_RTC_SET_BY_IOP 0x0122
   #define EVLOG_SNMP_FQDN_FAILED 0x0123
   #define EVLOG_RCKMGMT_EFUSE_ERR 0x0124
   #define EVLOG_RCKMGMT_EM_COM_ERR 0x0125
   #define EVLOG_ENABLE_PERSMOUSE 0x0126
   #define EVLOG_DISABLE_PERSMOUSE 0x0127
   #define EVLOG_NTP_COMM_FAIL 0x0128
   #define EVLOG_SET_SERVER_FQDN 0x0129
   #define EVLOG_SET_SMH_FQDN 0x012A
   #define EVLOG_PWRINV_NOT_READY 0x0130
   #define EVLOG_FIPS_ENABLED 0x0172
   #define EVLOG_FIPS_KAT_FAILED 0x0173
   #define EVLOG_FIPS_DISABLED 0x0174
   #define EVLOG_RDP_ENABLED 0x0176
   #define EVLOG_RDP_DISABLED 0x0177
   #define EVLOG_HOTKEY_MODIFIED 0x0178
   #define EVLOG_ALERTMAIL_SEND 0x0179
   #define EVLOG_PROFILE_ADD 0x017A
   #define EVLOG_PROFILE_DEL 0x017B
   #define EVLOG_KEYMGR_IMPORT_FAILED 0x017D
   #define EVLOG_KEYMGR_EXPORT_FAILED 0x017E
   #define EVLOG_KEYMGR_ESKM_MODIFY 0x017F
   #define EVLOG_KEYMGR_ESKM_REDUNDANCY 0x0180
   #define EVLOG_ACCESSMON_RESET 0x0181
   #define EVLOG_USER_ADDED_BY 0x0190
   #define EVLOG_USER_DELETED_BY 0x0191
   #define EVLOG_USER_MODIFIED_BY 0x0192
   #define EVLOG_REMOTE_CONSOLE_COMPLOCK_ENABLE 0x0193
   #define EVLOG_REMOTE_CONSOLE_COMPLOCK_DISABLE 0x0194
   #define EVLOG_IRC_TRUST_SETTINGS_ENABLE 0x0195
   #define EVLOG_IRC_TRUST_SETTINGS_DISABLE 0x0196
   #define EVLOG_IPMI_ACCESS_MODIFIED 0x0197
   #define EVLOG_DIRECTORY_SETTINGS_CHANGED 0x019E
   #define EVLOG_APO_SETTINGS_MODIFIED 0x019F
   #define EVLOG_SNTP_MODIFIED 0x01A0
   #define EVLOG_LANGPACK_FAILED_UPGRADE 0x01A1
   #define EVLOG_DEFAULT_LANG 0x01A2
   #define EVLOG_SNMP_ALERT_PWR_THRESHOLD 0x01A3
   #define EVLOG_ONETIME_BOOTORDER_SET 0x01A4
   #define EVLOG_FED_GROUP_ADDED_BY 0x01A5
   #define EVLOG_FED_GROUP_DELETED_BY 0x01A6
   #define EVLOG_FED_GROUP_MODIFIED_BY 0x01A7
   #define EVLOG_BOOT_MODE_SET 0x01A8
   #define EVLOG_FEDERATION_LOGIN_IP46 0x01AA
   #define EVLOG_FEDERATION_LOGOUT_IP46 0x01AB
   #define EVLOG_FEDERATION_FAILED_LOGIN_IP46 0x01AC
   #define EVLOG_GROUP_ADDED_BY 0x01AD
   #define EVLOG_GROUP_DELETED_BY 0x01AE
   #define EVLOG_GROUP_MODIFIED_BY 0x01AF
   #define EVLOG_MCAST_MODIFIED_BY 0x01B0
   #define EVLOG_BMC_IPMI 0x01B1
   #define EVLOG_NETWORK_CFG_MODIFIED_BY 0x01B2
   #define EVLOG_CERTIFICATE_WARNING_BAD_NAME 0x01B3
   #define EVLOG_SIDEBAND_PORT_FALLBACK 0x01B4
   #define EVLOG_RESTAPI_MEMORY_CLEAR 0x01B5
   #define EVLOG_RESTAPI_PROVIDER_ADDED 0x01B6
   #define EVLOG_RESTAPI_PROVIDER_REMOVED 0x01B7
   #define EVLOG_HD_ZONE_UPDATED 0x01B8
   #define EVLOG_HD_ZONE_FACTORY_DEFAULT 0x01B9
   #define EVLOG_RESTAPI_PROVIDER_REG_FAILED 0x01BA
   #define EVLOG_SERVER_SIGNATURE_CHANGE_NETWORK_AND_PROFILE 0x01BB
   #define EVLOG_SERVER_SIGNATURE_CHANGE_PROFILE 0x01BC
   #define EVLOG_CLEAR_REST_API_STATE 0x01BD
   #define EVLOG_SERVER_SIGNATURE_CHANGED 0x01BE
   #define EVLOG_RIS_EV_CREATED 0x01BF
   #define EVLOG_RIS_EV_DELETED 0x01C0
   #define EVLOG_RIS_EV_CANCELLED 0x01C1
   #define EVLOG_RIS_EV_UPDATED 0x01C2
   #define EVLOG_RIS_EV_CREATE_FAIL 0x01C3
   #define EVLOG_RIS_EV_EXPIRED 0x01C4
   #define EVLOG_PS_UPDATE_START 0x01C5
   #define EVLOG_PS_UPDATE_FAIL 0x01C6
   #define EVLOG_PS_UPDATE_COMPLETE 0x01C7
   #define EVLOG_PS_UPDATE_NOT_REDUNDANT 0x01C8
   #define EVLOG_BBU_SETTING_CHANGED 0x01CA
   #define EVLOG_ILO_RESET_CANBUS 0x01CB
   #define EVLOG_USBFP_ARRIVED 0x01CC
   #define EVLOG_USBFP_DEPARTED 0x01CD
   #define EVLOG_USBFP_ERROR 0x01CE
   #define EVLOG_USBFP_UNSUPPORTED 0x01CF
   #define EVLOG_USBFP_CMD 0x01D0
   #define EVLOG_PEF_ACTION 0x01D1
   #define EVLOG_PWRBTN_EARLY_PRESS 0x01D2
   #define EVLOG_EMBMEDIA_SD_CARD_EVENT_CAUTION 0x01D3
   #define EVLOG_EMBMEDIA_SD_CARD_EVENT_FAIL 0x01D4
   #define EVLOG_EMBMEDIA_SD_CARD_EVENT_INFO 0x01D5
   #define EVLOG_USBFP_FULL_SPEED 0x01D6
   #define EVLOG_USBFP_LOGIN 0x01D7
   #define EVLOG_USBFP_LOGOUT 0x01D8
   #define EVLOG_USBFP_FAILED_LOGIN 0x01D9
   #define EVLOG_USBFP_WARNING 0x01DA
   #define EVLOG_LDAP_CERT_VAL_FAILED 0x01DB
   #define EVLOG_INTERFACE_ENABLED 0x01DC
   #define EVLOG_INTERFACE_DISABLED 0x01DD
   #define EVLOG_DATA_EXTRACT_VER_MISMATCH 0x01DE
   #define EVLOG_UPDATE_TASK_STATE_CHANGED 0x01DF
   #define EVLOG_REPO_COMPONENT_ADDED 0x01E0
   #define EVLOG_FAILED_LOGIN_IP46 0x03E8
   #define EVLOG_FW_UPGRADE_IP46 0x03E9
   #define EVLOG_REMOTE_CONSOLE_LOGIN_FAILED_IP46 0x03EA
   #define EVLOG_XML_FAILED_LOGIN_IP46 0x03EB
   #define EVLOG_RMCP_FAILED_LOGIN_IP46 0x03EC
   #define EVLOG_WSMAN_FAILED_LOGIN_IP46 0x03ED
   #define EVLOG_SHARED_SESSION_CLOSED_IP46 0x03EE
   #define EVLOG_SHARED_SESSION_OPENED_IP46 0x03EF
   #define EVLOG_SSH_FAILED_LOGIN_IP46 0x03F0
   #define EVLOG_RC_LOGIN_2_IP46 0x03F3
   #define EVLOG_RC_LOGOUT_2_IP46 0x03F4
   #define EVLOG_XML_LOGIN_IP46 0x03F7
   #define EVLOG_XML_LOGOUT_IP46 0x03F8
   #define EVLOG_WEB_LOGIN_IP46 0x03F9
   #define EVLOG_WEB_LOGOUT_IP46 0x03FA
   #define EVLOG_PT_LOGIN_IP46 0x03FB
   #define EVLOG_PT_LOGOUT_IP46 0x03FC
   #define EVLOG_SSH_LOGIN_IP46 0x03FD
   #define EVLOG_SSH_LOGOUT_IP46 0x03FE
   #define EVLOG_RMCP_LOGOUT_IP46 0x0400
   #define EVLOG_RMCP_LOGIN_IP46 0x0401
   #define EVLOG_WSMAN_LOGIN_IP46 0x0402
   #define EVLOG_WSMAN_LOGOUT_IP46 0x0403
   #define EVLOG_POM_CLEARED_IP46 0x0404
   #define EVLOG_SSO_TRY_LOGIN_IP46 0x0405
   #define EVLOG_SNTP_SYNCH_IP46 0x0406
   #define EVLOG_VSP_START_IP46 0x0407
   #define EVLOG_VSP_STOP_IP46 0x0408
   #define EVLOG_TEXTCON_LOGIN_IP46 0x0409
   #define EVLOG_TEXTCON_LOGOUT_IP46 0x040A
   #define EVLOG_FLINT_BUTTON_RESET 0x040B
   #define EVLOG_FLINT_BUTTON_RESET_HARD 0x040C
   #define EVLOG_DUPLICATE_IP46 0x040D
   #define EVLOG_CHANGED_GROUP_POWER_CAP 0x040E
   #define EVLOG_DISABLED_GROUP_POWER_CAP 0x040F
   #define EVLOG_CORRECTABLE_MEMORY_ERROR 0x0410
   #define EVLOG_FLINT_LINK_AUTO_DET 0x0411
   #define EVLOG_LANGPACK_INSTALL_COMPLETE 0x0412
   #define EVLOG_ACCESS_SETTINGS_MODIFIED_BY 0x0414
   #define EVLOG_VMEDIA_INTENT 0x0415
   #define EVLOG_SERVICE_PORT_SETTINGS_MODIFIED_BY 0x0416
   #define EVLOG_USBFP_NIC_LINK_UP 0x0417
   #define EVLOG_USBFP_NIC_LINK_DOWN 0x0418
   #define EVLOG_EMBMEDIA_NAND_WEAR_OUT 0x0419
   #define EVLOG_EMBMEDIA_NAND_CRITICAL_FAILURE 0x041A
   #define EVLOG_EMBMEDIA_NAND_NOT_COMPLIANT 0x041B
   #define EVLOG_UEFI_TO_PIP_XFER_OK 0x0420
   #define EVLOG_UEFI_TO_PIP_XFER_FAIL 0x0421
   #define EVLOG_GLOBAL_SETTINGS_MODIFIED_BY 0x0422
   #define EVLOG_CAC_SETTINGS_MODIFIED_BY 0x0423
   #define EVLOG_CAC_CERT_ADDED_BY 0x0424
   #define EVLOG_CAC_CERT_REMOVED_BY 0x0425
   #define EVLOG_FI_SETTINGS_CHANGED 0x0426
   #define EVLOG_ERS_REGISTER_INSIGHT_ONLINE 0x0427
   #define EVLOG_ERS_REGISTER_IRS_SERVER 0x0428
   #define EVLOG_ERS_REGISTRATION_FAILED 0x0429
   #define EVLOG_ERS_UNREGISTER_IRS_SERVER 0x042A
   #define EVLOG_ERS_UNREGISTER_INSIGHT_ONLINE 0x042B
   #define EVLOG_ERS_UNREGISTRATION_FAILED 0x042C
   #define EVLOG_ERS_SERVICE_EVENT_SENT 0x042D
   #define EVLOG_ERS_SERVICE_EVENT_FAILED 0x042E
   #define EVLOG_ERS_DATA_COLLECTION_SENT 0x042F
   #define EVLOG_ERS_DATA_COLLECTION_FAILED 0x0430
   #define EVLOG_ERS_AHS_REPORT_SENT 0x0431
   #define EVLOG_ERS_AHS_REPORT_FAILED 0x0432
   #define EVLOG_ERS_PROXY_CONFIG_SET 0x0433
   #define EVLOG_ERS_PROXY_CONFIG_FAILED 0x0434
   #define EVLOG_ERS_PROXY_CONFIG_CLEARED 0x0435
   #define EVLOG_ERS_MAINT_MODE_EXPIRED 0x0436
   #define EVLOG_ERS_REGISTRATION_INITIATED 0x0437
   #define EVLOG_ERS_MAINT_MODE_SET 0x0438
   #define EVLOG_ERS_MAINT_MODE_CLEARED 0x0439
   #define EVLOG_ERS_UNREGISTER_INITIATED 0x043A
   #define EVLOG_ERS_DISABLED 0x043B
   #define EVLOG_ERS_ENABLED 0x043C
   #define EVLOG_ERS_SERVICE_EVENT_CLEARED 0x043D
   #define EVLOG_EVLOG_BBU_RUNNING 0x043E
   #define EVLOG_EVLOG_BBU_STOPPED 0x043F
   #define EVLOG_BACKUP_PERFORMED 0x0440
   #define EVLOG_ILO_RESTORE 0x0441
   #define EVLOG_ALERTMAIL_FAILURE 0x0442
   #define EVLOG_AUX_POWER_CYCLE_INITIATED 0x0443
   #define EVLOG_APOLLO_POWER_REGULATION_SETTING_CHANGED 0x0444
   #define EVLOG_APOLLO_POWER_ZONE_UPDATED 0x0445
   #define EVLOG_APOLLO_POWER_CAP_CHANGED 0x0446
   #define EVLOG_APOLLO_POWER_CAP_DISABLED 0x0447
   #define EVLOG_FW_UPDATE_UPLOAD_FAILED 0x0448
   #define EVLOG_FW_UPDATE_UPLOAD_SUCCESS 0x0449
   #define EVLOG_USBFP_MOUNT_ERROR 0x044A
   #define EVLOG_USBFP_BAD_JSON 0x044B
   #define EVLOG_UNAUTHORIZED_LOGIN_ATTEMPTS 0x044C
   #define EVLOG_SELFTEST_ERROR 0x044D
   #define EVLOG_SERVER_POWER_ON_FAILURE 0x044E
   #define EVLOG_DEFAULT_ACCOUNT_SETTINGS_MODIFIED 0x0451
   #define EVLOG_EMBMEDIA_MANAGER_ATTACH_FAIL 0x0452
   #define EVLOG_EMBMEDIA_WRITE_VERIFY_TEST_FAIL 0x0453
   #define EVLOG_EMBMEDIA_INIT_FAIL 0x0454
   #define EVLOG_EMBMEDIA_FILE_SYSTEM_INCONSISTENT 0x0455
   #define EVLOG_EMBMEDIA_CONTROLLER_EXCEPTION 0x0456
   #define EVLOG_EMBMEDIA_FW_IMAGE_FETCH_FAIL 0x0457
   #define EVLOG_EMBMEDIA_SELF_TEST_FAIL 0x0458
   #define EVLOG_EMBMEDIA_CONTROLLER_START_FAIL 0x0459
   #define EVLOG_EMBMEDIA_CONTROLLER_ATTACH_FAIL 0x045A
   #define EVLOG_EMBMEDIA_RESTART_FAIL 0x045B
   #define EVLOG_EMBMEDIA_RESTARTED 0x045C
   #define EVLOG_EMBMEDIA_NAND_WRITES_RESUMED 0x045D
   #define EVLOG_EMBMEDIA_7DAY_WRITE_LIMIT_EXCEEDED 0x045E
   #define EVLOG_EMBMEDIA_24HR_WRITE_LIMIT_EXCEEDED 0x0461
   #define EVLOG_EMBMEDIA_BLOBSTORE_24HR_WRITE_LIMIT_EXCEEDED 0x0462
   #define EVLOG_INSTALL_SET_REMOVED_BY 0x0463
   #define EVLOG_SECURITY_STATE_CHANGED 0x0464
   #define EVLOG_REST_SUBSCRIBER_CERT_VAL_FAILED 0x0465
   #define EVLOG_APOLLO_POWER_CALIBRATION_ACTION 0x0466
   #define EVLOG_ALERTMAIL_AUTHENTICATION_FAILURE 0x0467
   #define EVLOG_ALERTMAIL_TLS_CONNECTION_FAILURE 0x0468
   #define EVLOG_BROWNOUT_RECOVERY_ENABLED 0x0469
   #define EVLOG_BROWNOUT_RECOVERY_DISABLED 0x046A
   #define EVLOG_HOST_REST_LOGIN 0x046B
   #define EVLOG_HOST_REST_LOGOUT 0x046C
   #define EVLOG_HOST_REST_FAILED_LOGIN 0x046D
   #define EVLOG_LANGPAK_REMOVE_LANG 0x046E
   #define EVLOG_LANGPAK_ADD_LANG 0x046F
   #define EVLOG_DEFAULT_LANG_SET 0x0470
   #define EVLOG_ALERTMAIL_CONNECTION_REJECTED 0x0471
   #define EVLOG_IRS_COMM_FAILURE 0x0472
   #define EVLOG_INVALID_FILE_ADDED 0x0473
   #define EVLOG_FILE_REMOVED 0x0474
   #define EVLOG_INSTALL_SET_MODIFIED_BY 0x0475
   #define EVLOG_INSTALL_SET_CREATED_BY 0x0476
   #define EVLOG_MAINT_WIN_BY 0x0477
   #define EVLOG_MAINT_WIN_REMOVED_BY 0x0478
   #define EVLOG_REMOTE_CONSOLE_COMPLOCK_MODIFIED 0x0479
   #define EVLOG_VNIC_CFG_MODIFIED_BY 0x047A
   #define EVLOG_REST_SUBSCRIBER_CA_CERTIFICATE_IMPORTED_BY 0x047B
   #define EVLOG_REST_SUBSCRIBER_CA_CERTIFICATE_REMOVED_BY 0x047C
   #define EVLOG_DG_POL_MOD 0x047E
   #define EVLOG_ONEVIEW_REIMAGE_BUTTON_PRESS 0x047F
   #define EVLOG_BACKUP_FILE_REMOVED 0x0480
   #define EVLOG_UPDATE_TASK_MOD 0x0481
   #define EVLOG_GLOBAL_MCTP_DEVICE 0x0482
   #define EVLOG_INDIVIDUAL_MCTP_DEVICE 0x0483
   #define EVLOG_DEVICE_NO_MANAGE 0x0484
   #define EVLOG_FLASH_FAILED 0x0485
   #define EVLOG_REST_TASK_EV_CREATED 0x0486
   #define EVLOG_REST_TASK_EV_DELETED 0x0487
   #define EVLOG_REST_TASK_EV_CREATE_LIMIT_REACHED 0x0488
   #define EVLOG_REST_TASK_EV_EXPIRED 0x0489
   #define EVLOG_IST_THRESHOLD_MODIFIED 0x048A
   #define EVLOG_IST_DWELLTIME_MODIFIED 0x048B
   #define EVLOG_IST_THRESHOLD_ALERT_DISABLED 0x048C
   #define EVLOG_PROPERTY_UNUSUAL_CONTENT 0x048D
   #define EVLOG_CONFIGURATION_OPTION_SET 0x048E
   #define EVLOG_SECDB_IGNORED_BY 0x048F
   #define EVLOG_SECDB_OVERALL_STATUS_CHANGE 0x0490
   #define EVLOG_SECDB_CONFIGURATION_STATE_IS_RISK 0x0491
   #define EVLOG_REIMAGE_BUTTON 0x0492
   #define EVLOG_FAILED_TO_GENERATE_SNMPv3_ENGINEID 0x0493
   #define EVLOG_REST_TASK_EV_STATE_CHANGE 0x0494
   #define EVLOG_HD_ZONE_BACKUP 0x0495
   #define EVLOG_ILO_RESET_DISABLE_DEV_MODE 0x0496
   #define EVLOG_ILO_ENABLE_DEV_MODE 0x0497
   #define EVLOG_SECURE_ERASE_REPORT_DELETED 0x0499
   #define EVLOG_VNIC_IP_CONFLICT 0x049A
   #define EVLOG_KEYMGR_LOG_CLEARED 0x049D
   #define EVLOG_THERMAL_CONFIGURATION_CHANGE 0x049E
   #define EVLOG_ILO_RESET_IN_POST 0x04A0
   #define EVLOG_IMPORT_REMOVE_CRL 0x04A1
   #define EVLOG_BUNDLE_UPDATE_START 0x04A2
   #define EVLOG_INVALID_INSTALL_SET_FILE 0x04A3
   #define EVLOG_INVOKE_INSTALL_START_BUNDLE_UPDATE 0x04A4
   #define EVLOG_WEB_PROXY_SETTINGS_MODIFIED 0x04A5
   #define EVLOG_CBM_ENABLED 0x04A6
   #define EVLOG_CBM_DISABLED 0x04A7
   #define EVLOG_CBM_CONNECTION_SUCCESS 0x04A8
   #define EVLOG_CBM_CONN_STATUS_CHANGED 0x04A9
   #define EVLOG_CBM_CONNECTION_FAILED 0x04AA
   #define EVLOG_CBM_ACTIVATION_CERT_FAILURE 0x04AB
   #define EVLOG_CBM_ACTIVATION_CONNECTIVITY_FAILURE 0x04AC
   #define EVLOG_CBM_ACTIVATION_CCS_FAILURE 0x04AD
   #define EVLOG_INSTALL_SET_DOWNLOAD_FAILED 0x04AE
   #define EVLOG_WEBSERVER_INTERNAL_ERROR 0x4505
   #define EVLOG_COMPONENT_DOWNLOAD_FAIL 0x4506
   #define EVLOG_CBM_LOGIN 0x4507
   #define EVLOG_CBM_LOGOUT 0x4508
   #define EVLOG_EVT_ILO_NIC_NOT_PRESENT 0x4509
   #define EVLOG_ADDON_FEATURE_DISABLE 0x450B
   #define EVLOG_SMARTNIC_DPU 0x450C
   #define EVLOG_MGMT_INTF_ACTIVE 0x450D
   #define EVLOG_DOWNLOAD_PERF_CFG_MODIFIED 0x450E
   #define EVLOG_CORRUPTION_DETECTED 0x450F
   #define EVLOG_POWER_REGULATOR_SET_FAILED 0x4510
   #define EVLOG_SSL_CERT_READ_ERROR 0x4511
   #define EVLOG_CA_CRL_READ_ERROR 0x4512
   #define EVLOG_CONF_READ_ERROR 0x4513
   #define EVLOG_SSH_KEY_READ_ERROR 0x4514
   #define EVLOG_EXTERNAL_MANAGER_CHANGE 0x4515
   #define EVLOG_BUNDLE_UPDATE_FAILED 0x4516
   #define EVLOG_AUTH_FAIL_FW_RECOVERY_INIT 0x4518
   #define EVLOG_HOST_SHTDWN_FOR_RECOV 0x4519
   #define EVLOG_FW_RECOV_STAT 0x451A
   #define EVLOG_CUSTOM_BACKUP 0x451B
   #define EVLOG_CUSTOM_RESTORE 0x451C
   #define EVLOG_BACKUP_RESTORE_FAILED 0x451E
   #define EVLOG_BACKUP_RESTORE_SUCCESS 0x451F
   #define EVT_MUTUAL_AUTH_ILO_SECURE_ELM 0x4520
   #define EVLOG_ILO_HEALTH_FAILED 0x4521
   #define EVLOG_SSL_CERT_FILE_ERROR 0x4522
   #define EVLOG_ILO_TPM_PCR_MEASUREMENT 0x4523
   #define EVLOG_OPENBMC_USB_VERIFICATION_FAILURE 0x4524
   #define EVLOG_OPENBMC_ENABLED 0x4525
   #define EVLOG_OPENBMC_SE_FAILURE 0x4526
   #define EVLOG_OPENBMC_AUTH_FAILURE 0x4527
   #define EVLOG_EVLOG_ILO6_CONFIG_FILES_ERROR 0x4528
   #define EVLOG_CBM_CONNECTION_ENDPOINTS 0x4529
   #define EVLOG_APOB_DATA_COPY 0x452A
   #define EVLOG_TFA_ENABLED 0x452D
   #define EVLOG_TFA_DISABLED 0x452E
   #define EVLOG_TFA_ENABLED_SL 0x452F
   #define EVLOG_SL_TFA_DISABLED 0x4530
   #define EVLOG_ILO6_CONFIG_FILES_ERROR 0x4533
   #define EVLOG_POWER_HEM_SETTING_CHANGED 0x4535
   #define EVLOG_ILO6_SMTP_TFA_DISABLED 0x4536
   #define EVLOG_ILO6_SMTP_TFA_ENABLED 0x4538
   #define EVLOG_CBM_AUTOCONNECT_DISABLE 0x4541
   #define EVLOG_LDAP_MODE_CHANGED 0x4542
   #define EVLOG_ILO_APO_POWERED_ON 0x4544
   #define EVLOG_SET_SERVER_POWER_AUTO 0x4545
   #define EVLOG_CBM_FAILINFO_FROM_COM 0x4546
   #define EVLOG_CBM_INVALID_ACTIVATION_KEY 0x4547
   #define EVLOG_CBM_ILO_TIME_ERROR 0x4548
   #define EVLOG_CBM_ILO_PROXY_ERROR 0x4549
   #define EVLOG_CBM_ILO_ACTIVATION_KEY_MISSING 0x454A
   #define EVLOG_CLOSE_LOOP_LC_WARRANTY_ADDED 0x454B
   #define EVLOG_CLOSED_LOOP_LC_WARRANTY_UPDATED 0x454C
   #define EVLOG_CLOSE_LOOP_LC_WARRANTY_DELETED 0x4550
   #define EVLOG_AIR_FILTER_RECORD_ADDED 0x4551
   #define EVLOG_AIR_FILTER_RECORD_DISABLED 0x4552
   #define EVLOG_CBM_FALLBACK_CONNECT 0x4553
   #define EVLOG_CBM_EXPIRED_ACTIVATION_KEY 0x4554
   #define EVLOG_CBM_ILO_INTERNAL_ERROR 0x4555
   #define EVLOG_TULIP_DOT_PROV_FAILURE 0x4556
   #define EVT_TULIP_MCTP_EROT_DISCOVERY_TIMEOUT 0x4557
   #define EVLOG_CBM_EXTERNAL_ERROR 0x4558
   #define EVT_FUM_FACTORY_DOT_PROV_FAILURE 0x4559
   #define EVT_FUM_FACTORY_DOT_PROV_SUCCESS 0x455A
   #define EVLOG_UPDATE_QUEUE_TASK_INSERTED 0x455B
   #define EVT_MAC_MISSING_IN_EEPROM 0x455C
   #define EVLOG_ILO_RTC_RESET 0x455D
   #define EVT_HPM_AUTH_BIND_FAIL 0x455E
   #define EVT_HPM_AUTH_SUCCESS 0x455F
   #define EVT_BIOS_SYNC_COMPLETED 0x4560
   #define EVT_BIOS_SYNC_FAILED 0x4561
   #define EVLOG_LC_LEAKAGE_REPAIRED 0x4563
   #define EVLOG_SECDB_IGNORED_BY_35 0x4564
   #define EVLOG_HOSTAPP_ADDED_BY 0x4565
   #define EVLOG_HOSTAPP_DELETED_BY 0x4566
   #define EVLOG_HOST_APP_LOGIN 0x4567
   #define EVLOG_HOST_APP_LOGOUT 0x4568
   #define EVLOG_HOST_APP_FAILED_LOGIN 0x4569
   #define EVLOG_LC_LEAK_PREVENT_POWER_ON 0x456A
   #define EVT_FALLBACK_TEMP_SENSOR_STATUS 0x456B
   #define EVLOG_FALLBACK_SENSOR_STATUS_CHANGE 0x456C
   #define EVLOG_DATETIME_MODIFIED 0x456D
 
#define EVT_CLASS_EMBEDDED_HEALTH 0x24
   #define EVLOG_UBB_TMP_CLK 0x0001
 
#define EVT_CLASS_XNC 0x25
 
#define EVT_CLASS_SMART_CARRIER 0x26
 
#define EVT_CLASS_POWER_CAPPING 0x27
   #define EVT_PCAP_REDUCED_PERF 0x0001
   #define EVT_PCAP_UNREACHABLE_WITH_CAP_VALUE 0x0003
   #define EVT_PCAP_FAST_CAP_SET_FAILURE 0x0004
   #define EVT_PS_NPSS_UNSUPPORTED 0x0005
   #define EVT_APOLLO_POWER_STATE_CHANGED 0x0007
 
#define EVT_CLASS_FLASH_MEDIA 0x28
   #define EVT_FM_BOOT_FROM_FLASH_ERROR 0x0001
   #define EVT_FM_BOOT_FROM_FLASH_READ_ERROR 0x0002
   #define EVT_FM_BOOT_FROM_FLASH_WRITE_ERROR 0x0003
   #define EVT_FM_BOOT_FROM_FLASH_REDUNDANCY_LOST 0x0004
   #define EVT_FM_BOOT_FROM_FLASH_SYC_FAILED 0x0005
   #define EVT_EMBMEDIA_SECURE_ERASE_FAILED 0x0006
   #define EVT_FM_BOOT_FROM_FLASH_REDUNDANCY_RESTORED 0x0007
 
#define EVT_CLASS_INTERLOCK 0x29
   #define EVT_IL_DEV_NOT_SEATED_OR_MISSING 0x0001
   #define EVT_IL_DEV_INSTALLED_STATE 0x0002
   #define EVT_IL_DEV_SUPPORTED_STATE 0x0003
   #define EVT_IL_DEV_BACKPLANE_TYPE 0x0004
   #define EVT_IL_DEV_SLOT_NUMBER 0x0005
 
#define EVT_CLASS_NVDIMM 0x2A
 
#define EVT_CLASS_EARLY_POST 0x32
   #define EVT_CRIT_ERROR_OCCURRED 0x0120
   #define EVT_TIME_NOT_SET 0x0163
   #define EVT_DIMM_CFG_ERR_NOT_SUPP_AMP_MODE 0x0209
   #define EVT_DIMM_CFG_INTERLEAVE_MODE 0x0210
   #define EVT_DIMM_CFG_NO_ECC 0x0211
   #define EVT_CPU_UPI_INIT_ERROR 0x0212
   #define EVT_DIMM_CFG_MAX_SYSTEM_RANKS 0x0213
   #define EVT_DIMM_CFG_INVALID_FREQ 0x0214
   #define EVT_DIMM_CPU_INIT_ERROR 0x0215
   #define EVT_DIMM_INIT_FATAL_ERROR 0x0216
   #define EVT_DIMM_INIT_VOLTAGE 0x0217
   #define EVT_DIMM_AMOUNT_EXCEEDS_CPU_SUPPORT 0x0219
   #define EVT_KTI_INIT_ERROR 0x0220
   #define EVT_UNKNOWN_MRC_ERROR 0x0221
   #define EVT_CHANNEL_TRAIN_ERROR_WITHOUT_CHANNEL_NUMBER 0x0223
   #define EVT_DIMM_CFG_POP_ORDER 0x0228
   #define EVT_DIMM_CFG_UNSUPPORTED_DIMM 0x0229
   #define EVT_DIMM_CFG_MAX_CHANNEL_RANKS 0x0230
   #define EVT_DIMM_CFG_NO_MEM 0x0231
   #define EVT_DIMM_INIT_ERROR 0x0232
   #define EVT_CHANNEL_TRAIN_ERROR 0x0233
   #define EVT_DIMM_TRAIN_ERROR 0x0234
   #define EVT_DIMM_CFG_UDIMM 0x0235
   #define EVT_DIMM_CFG_VOLTAGE 0x0236
   #define EVT_DIMM_CFG_OCTAL_QUAD_RANK 0x0237
   #define EVT_DIMM_CFG_LRDIMM_MIX_RANK 0x0238
   #define EVT_DIMM_CFG_MIXED_DIMM_TYPE 0x0239
   #define EVT_UNSUP_PROC_CFG_THREE_PROC 0x0242
   #define EVT_UNSUP_PROC_ON_4_PROC_SYSTEM 0x0243
   #define EVT_UNSUPP_PROC_CFG_MODEL_NUM 0x0259
   #define EVT_SPS_FW_RECOVERY_MODE 0x0264
   #define EVT_NVM_CAP_EXCEEDED 0x0265
   #define EVT_ILO_FW_COM_FAIL 0x0270
   #define EVT_UNSUPP_PROC_CFG_STEP 0x0275
   #define EVT_BOOT_MODE_TOGGLE_LEGACY 0x0298
   #define EVT_BOOT_MODE_TOGGLE_UEFI 0x0299
   #define EVT_TPM_SELFTEST_ERR 0x0318
   #define EVT_UNSUP_PROC_CFG_INCORRECT_ORDER 0x0330
   #define EVT_NVDIMM_POP_RDIMM 0x0348
   #define EVT_NVDIMM_POP_ORDER_ERR 0x0350
   #define EVT_NVDIMM_SUPERCAP 0x0358
   #define EVT_NVDIMM_POP_NO_RDIMM 0x0359
   #define EVT_NVDIMM_CFG_INCOMPATIBLE 0x0365
   #define EVT_BIOS_AUTH_ERR_IMAGE_FAIL_NO_RECOVERY 0x0367
   #define EVT_BIOS_AUTH_ERR_IMAGE_FAIL 0x0368
   #define EVT_BIOS_AUTH_ERR_RED_FAIL 0x0369
   #define EVT_RED_BIOS_AUTH_ERR_RED_FAIL 0x0370
   #define EVT_EELOG_ERR_NO_SRC 0x0389
   #define EVT_IE_AUTH_ERR_IMAGE_FAIL 0x0413
   #define EVT_UNSUPPORTED_AEP_DETECTED 0x0453
   #define EVT_DIMM_UNC_ERROR_THRESHOLD 0x0462
   #define EVT_AEP_FW_UPDATE_NEEDED 0x0540
   #define EVT_AEP_NOT_SUPPORTED 0x0560
   #define EVT_AEP_SOCKET_MISSING_DIMM 0x0561
   #define EVT_AEP_S0C0D0_MISSING_DIMM 0x0562
   #define EVT_DIMM_NOT_SUPPORTED_WITH_AEP 0x0563
   #define EVT_AEPS_ON_SAME_CHANNEL 0x0564
   #define EVT_AEP_CHANNEL_ORDER_ERROR 0x0565
   #define EVT_DUAL_DIE_LRDIMM_NO_AEP 0x0566
   #define EVT_AEP_NOT_ON_IMC0 0x0567
   #define EVT_AEP_NOT_ON_CPU1 0x0568
   #define EVT_AEP_2LM_3DS_LRDIMMS 0x0570
   #define EVT_AEP_2LM_UNBALANCED 0x0571
   #define EVT_AEP_2LM_DIMM_IMC_MISMATCH 0x0573
   #define EVT_AEP_CAP_MISMATCH 0x0574
   #define EVT_FRONT_EXPANSION_PCIE_HDR_CABLES_SWAPPED 0x0600
   #define EVT_DOUBLE_WIDE_MEZZ_INSTALL_ERROR 0x0601
   #define EVT_RISER_CABLE_INSTALL_ERROR 0x0602
   #define EVT_FACTORY_BUILD_ERROR 0x0603
   #define EVT_HPE_CPU_BIST 0x3013
   #define EVT_EVT_DIMM_CFG_NO_MEM_DT 0x3016
   #define EVT_SPS_AUTH_ERR_IMAGE_FAIL 0x3017
   #define EVT_SPS_AUTH_ERR_IMAGE_OUT_OF_DATE 0x3018
   #define EVT_SPS_FIRMWARE_RECOVERY_MODE 0x3019
   #define EVT_PCIE_SLOT_FAILURE 0x3020
   #define EVT_PCIE_FULL_SLOT_FAILURE 0x3021
   #define EVT_PCIE_BIFUR_SLOT_FAILURE 0x3022
   #define EVT_FLEXLOM_LINK_FAILURE 0x3023
   #define EVT_FLEXLOM_LINK_DEGRADED 0x3024
   #define EVT_AEP_MIXED_SKU 0x3025
   #define EVT_AEP_COMM_FAILURE 0x3026
   #define EVT_SMART_PPR_BEGIN 0x3027
   #define EVT_SMART_PPR_END 0x3028
   #define EVT_SMART_PPR_REPAIR 0x3029
   #define EVT_AEP_POP_WARN 0x3030
   #define EVT_SAFE_MODE_BOOT 0x3031
   #define EVT_AUTO_HEAL_START 0x3032
   #define EVT_AUTO_HEAL_EXIT 0x3033
   #define EVT_AUTO_HEAL_RESOLUTION 0x3034
   #define EVT_SPS_FIRMWARE_FULL_IMAGE_RECOVERY_MODE 0x3038
   #define EVT_LTSX_BIOS_ACM_ERROR 0x303A
   #define EVT_LTSX_SINIT_ACM_ERROR 0x303B
   #define EVT_SPS_FW_UPDATE 0x303D
   #define EVT_EVT_MEM_REMAP_INITIATED 0x303E
   #define EVT_EVT_ACPI_EINJ_ERR_INJECTED 0x303F
   #define EVT_EVT_MEM_REMAP_INITIATED_DUE_TO_DIMM_MOVEMENT 0x3040
   #define EVT_SAFE_MODE_BOOT_PASS 0x3041
   #define EVT_SAFE_MODE_BOOT_FAIL 0x3042
   #define EVT_STEP_BEGIN 0x3043
   #define EVT_STEP_END 0x3044
   #define EVT_STEP_REPAIR 0x3045
   #define EVT_DIMM_CFG_POP_ORDER_TERTIARY 0x3046
   #define EVT_DIMM_CFG_POP_ORDER_FOURTH 0x3047
   #define EVT_AEP_INIT_ERROR 0x3048
   #define SECLOG_ILO_HIGH_SEC_NO_ADMIN_PWD 0x3049
   #define EVT_BPS_2LM_TOO_MUCH_NM 0x304A
   #define EVT_BPS_2LM_NM_FM_RATIO 0x304B
   #define EVT_SMART_PPR_RESTART  0x304C
   #define EVT_STEP_RESTART 0x304D
   #define EVT_STEP_REPAIR_FAIL 0x304E
   #define EVT_PCIE_RETRAIN_ERROR 0x31D1
   #define EVT_MPH_CABLE_RISER_INSTALL_ERROR 0x5440
   #define EVT_HBM_TRAIN_FAILURE 0x5443
   #define EVT_HBM_2LM_UNSUPPORTED 0x5444
   #define EVT_NEWER_PROCESSOR_FW_VERSION 0x5445
   #define EVT_CFR_PROVISION_FAIL 0x5446
   #define EVT_HBM_2LM_FM_NM_RATIO_INCORRECTED 0x544A
   #define EVT_SMART_PPR_AMD_TEST_DURATION 0x544B
   #define EVT_HBM_AMT_INIT 0x544C
   #define EVT_HBM_AMT_COMPLETE 0x544D
   #define EVT_HBM_STEP_REPAIR 0x544E
   #define EVT_DIMM_UNC_ERROR_THRESHOLD_MAPOUT_CHANNEL 0x544F
   #define EVT_UNSUPP_PROC_CFG_MISMATCH 0x5450
   #define EVT_DIMM_PWR_FAIL_ERROR 0x5451
   #define EVT_PROCESSOR_FW_MISMATCH 0x5452
   #define EVT_CXL_NUM_LIMIT_EXCEEDED 0x5453
   #define EVT_CXL_CACHE_LIMIT 0x5454
   #define EVT_CXL_1P1_LIMIT_EXCEED 0x5455
   #define EVT_CXL_1P1_CFG_ERROR 0x5456
   #define EVT_STEP_BEGIN_G12 0x5457
   #define EVT_STEP_END_G12 0x5458
   #define EVT_STEP_REPAIR_G12 0x5459
   #define EVT_STEP_REPAIR_FAIL_G12 0x545A
   #define EVT_STEP_RESTART_G12 0x545B
 
#define EVT_CLASS_NVME 0x33
   #define EVT_PCIe_DRIVE_TEMP_FAILED 0x0001
   #define EVT_PCIe_DRIVE_COND_CHANGE 0x0002
   #define EVT_PCIe_DRIVE_WEAR_STATUS_CHANGE 0x0003
   #define EVT_PCIe_DRIVE_ADDED_POWERON 0x0004
   #define EVT_PCIe_DRIVE_REMOVED_POWEROFF 0x0005
   #define EVT_PCIe_DRIVE_INVALID_TYPE 0x0006
   #define EVT_BACKPLANE_FRU_INVALID_DATA 0x0007
   #define EVT_NVME_UNMASK_FAILURE 0x0008
 
#define EVT_CLASS_CHASSIS_MANAGER 0x34
   #define EVT_PS_OVERCURRENT 0x0001
   #define EVT_CHASSIS_PEFORMANCE 0x0002
   #define EVT_ZONE_PERFORMANCE 0x0003
 
#define EVT_CLASS_PERFORMANCE 0x35
   #define EVT_IST_PERFORMANCE_THRESHOLD 0x0001
 
#define EVT_CLASS_SECURITY_COMPLIANCE 0x36
   #define SECLOG_FIPS_KAT_FAILED 0x0001
   #define SECLOG_FIPS_DISABLED 0x0002
   #define SECLOG_HEALTH_TEST_FAILURE 0x0003
 
#define EVT_CLASS_SECURITY_CONFIGURATION 0x37
   #define SECLOG_SECDB_IGNORED_BY 0x0002
   #define SECLOG_SECURITY_STATE_CHANGED 0x0004
   #define SECLOG_SECDB_CONFIGURATION_STATE_IS_RISK 0x0005
   #define SECLOG_CERT_VAL_FAILED 0x0006
   #define SECLOG_CERT_VAL_INCOMPATIBLE 0x0007
   #define SECLOG_SSO_TRUST_CHANGE 0x0009
   #define SECLOG_SSO_ROLE_CHANGE 0x000A
   #define SECLOG_SSO_LOGIN_REJECT_ERROR 0x000B
   #define SECLOG_SSL_CERT_INSTALLED 0x000C
   #define SECLOG_HOST_AUTHENTICATION 0x000D
   #define SECLOG_LOGIN_BANNER 0x000E
   #define SECLOG_SSH_KEY 0x0010
   #define SECLOG_FIPS_ENABLED 0x0011
   #define SECLOG_IPMI_ACCESS_MODIFIED 0x0012
   #define SECLOG_NETWORK_CFG_MODIFIED_BY 0x0013
   #define SECLOG_CERTIFICATE_WARNING_BAD_NAME 0x0014
   #define SECLOG_SERVER_SIGNATURE_CHANGED 0x0015
   #define SECLOG_ACCESS_SETTINGS_MODIFIED_BY 0x0016
   #define SECLOG_SERVICE_PORT_SETTINGS_MODIFIED_BY 0x0017
   #define SECLOG_CAC_SETTINGS_MODIFIED_BY 0x0018
   #define SECLOG_REST_SUBSCRIBER_CERT_VAL_FAILED 0x0019
   #define SECLOG_ILO_ENABLE_DEV_MODE 0x001A
   #define SECLOG_ILO_RESET_DISABLE_DEV_MODE 0x001B
   #define SECLOG_DG_POL_MOD 0x001C
   #define SECLOG_INVALID_FILE_ADDED 0x001D
   #define SECLOG_REST_SUBSCRIBER_CA_CERTIFICATE_IMPORTED_BY 0x001E
   #define SECLOG_CAC_CERT_ADD_REMOVE 0x001F
   #define SECLOG_KEYMGR_ESKM_MODIFY 0x0020
   #define SECLOG_SSO_SRV 0x0022
   #define SECLOG_SSO_SRV_REC_DEL 0x0023
   #define SECLOG_FW_RECOVERY_REQUEST 0x0024
   #define SECLOG_FI_SETTINGS_CHANGED 0x0025
   #define SECLOG_IMPORT_CERT_LDAP 0x0029
   #define SECLOG_CRL_FILE_CORRUPT 0x0042
   #define SECLOG_DSA_SIGNED_SSH_KEYS_STATUS 0x0043
   #define SECLOG_ACCOUNT_SERVICE_SETTINGS_MODIFIED_BY 0x0261
   #define SECLOG_IMPORT_REMOVE_CA_CERT 0x0263
   #define SECLOG_IMPORT_REMOVE_CRL 0x0264
   #define SECLOG_EAP_TLS_AUTH_SUCCESS 0x0265
   #define SECLOG_EAP_TLS_SETTINGS_MODIFIED 0x0266
   #define SECLOG_EAP_TLS_AUTH_FAILURE 0x0267
   #define SECLOG_EAP_TLS_CERT_RETRIEVE_FAILURE 0x0269
   #define SECLOG_ACE_CERT_STAT_SUCCESS 0x026A
   #define SECLOG_ACE_CERT_STAT_FAILED 0x026B
   #define SECLOG_ACE_SCEP_SETTING_CHANGED 0x026C
   #define SECLOG_ACE_SCEP_STAT_CHANGED 0x026D
   #define SECLOG_ACE_CERT_ISSUE_FAILED 0x026E
   #define SECLOG_ACE_CERT_VAL_FAILED 0x026F
   #define SECLOG_ACE_CSR_GEN_FAILED 0x0270
   #define EVT_SPDM_IGNORE_FAILURE 0x0271
   #define EVT_SPDM_HALT_REASON_FAILED 0x0272
   #define EVT_SPDM_HALT_REASON_ERROR 0x0273
   #define SECLOG_CAC_LOGIN_FAILURE_CRL_REVOKED 0x0274
   #define SECLOG_SPDM_AUTH_FAILURE 0x0275
   #define SECLOG_SPDM_AUTH_SUCCESS 0x0276
   #define SECLOG_GLOBAL_COMPONENT_INTEGRITY 0x0277
   #define SECLOG_COMPONENT_INTEGRITY_POLICY 0x0278
   #define SECLOG_TLS_VERSION_STATUS 0x0279
   #define SECLOG_SSL_CERT_COMMON_FAILURES 0x027B
   #define SECLOG_SSL_CERT_SIDE_LOADED_FAILURES 0x027C
   #define SECLOG_SSL_CERT_CA_SIGNED_FAILURES 0x027D
   #define SECLOG_SSL_CERT_SIDE_LOADED_SEC_STATE_FAILURES 0x027F
   #define SECLOG_DEVID_CERT_FAILURE 0x0641
   #define SECLOG_DEVID_SUCCESS 0x0642
   #define SECLOG_OPENBMC_TRANSFER_OUT 0x0643
   #define SECLOG_OPENBMC_TRANSFER_IN 0x0644
   #define SECLOG_OPENBMC_INHIBIT 0x0645
   #define SECLOG_OPENBMC_EEPROM_CORRUPTION 0x0646
   #define SECLOG_PCR_MEASUREMENTS_CHANGED 0x0647
   #define SECLOG_PCR_MEASUREMENTS_UPDATED 0x0648
   #define SECLOG_LOGIN_BANNER_MESSAGE 0x1610
   #define SECLOG_ACCOUNT_STATUS_CHANGED 0x1611
   #define SECLOG_SECDB_SEC_PARAM_STATUS 0x1614
   #define SECLOG_SECDB_OVERALL_STATUS 0x1615
   #define SECLOG_SECDB_OVERALL_STATUS_ILO5 0x1616
   #define SECLOG_WEAK_CIPHERS_STATUS 0x1617
   #define SECLOG_HPM_AUTH_FAILURE 0x1618
   #define SECLOG_TULIP_AUTH_CHECK_FAILURE 0x1619
   #define SECLOG_SECDB_IGNORED_BY_55 0x161D
   #define EVT_DRIVE_KEY_LIMIT_EXHAUST 0x161E
   #define EVT_HARDWARE_DATA_CHANGED 0x161F
   #define SECLOG_TPM_QUOTE_SIGNATURE_INVALID 0x1620
 
#define EVT_CLASS_DENIAL_OF_SERVICE 0x38
   #define SECLOG_SPI_AUTH_FAIL 0x0001
   #define SECLOG_UNAUTHORIZED_LOGIN_ATTEMPTS 0x0002
   #define SECLOG_SCP_AUTH_FAIL 0x0003
 
#define EVT_CLASS_PERMANENT_DENIAL_OF_SERVICE 0x39
   #define SECLOG_FW_SCAN_RECOVERY_COMPLETE 0x0002
   #define SECLOG_FI 0x0003
   #define SECLOG_FI_REP_FAIL 0x0004
   #define SECLOG_ME_FD0V_VALIDATION_FAILED 0x0005
 
#define EVT_CLASS_HARDWARE_INTRUSION 0x3A
   #define SECLOG_INTRUSION_HARDWARE_INSTALLED 0x0005
   #define SECLOG_INTRUSION_HARDWARE_REMOVAL 0x0006
   #define SECLOG_HOOD_REMOVAL 0x0007
   #define SECLOG_HOOD_REPLACED 0x0008
   #define SECLOG_CHASSIS_HOOD_REMOVAL 0x0009
 
#define EVT_CLASS_OS_SECURITY 0x3B
   #define SECLOG_EVT_OS_SECURITY_SCAN 0x0001
   #define SECLOG_EVT_OS_SECURITY_ADD 0x0002
   #define SECLOG_EVT_OS_SECURITY_REMOVE 0x0003
   #define SECLOG_EVT_OS_SECURITY_CFG_CHANGE 0x000D
   #define SECLOG_EVT_OS_SECURITY_UNEXPECTED_CHANGE 0x000E
   #define SECLOG_EVT_OS_SECURITY_UPDATE_TIMEOUT 0x000F
   #define SECLOG_EVT_OS_SECURITY_CORRUPTION_CORRECTION 0x0010
 
#define EVT_CLASS_DPU 0x3C
   #define EVT_SMARTNIC_DPU 0x0001
   #define EVT_DPU_CLEARED 0x0002
 
#define EVT_CLASS_RECOVERABLE_SYSTEM_ERROR 0x3D
   #define EVT_RECOV_INPUT_POWER_LOSS 0x0001
   #define EVT_RECOV_POWER_ON_FAULT 0x0002
   #define EVT_RECOV_RUNTIME_FAULT 0x0003
   #define EVT_RECOV_MEZZANINE_CARD_FAULT 0x0004
 
#define EVT_CLASS_RDE 0x3E
   #define EVT_RDE_GENERIC_IML 0x0001
 
    
//
// Number of IML Entries
//
#define EVT_IML_GEN_DATA_ENTRIES 854
#define EVT_IML_ACT_DATA_ENTRIES 629
#define EVT_IML_DESC_DATA_ENTRIES 854
#define EVT_IML_VAR_DATA_ENTRIES 671
#define EVT_IML_TRAP_DATA_ENTRIES 397
#define EVT_IML_RIS_ALERT_DATA_ENTRIES 415
#define EVT_IML_SER_EVENT_DATA_ENTRIES 47
    
//
// Number of IEL Entries
//
#define EVT_IEL_GEN_DATA_ENTRIES 463
#define EVT_IEL_ACT_DATA_ENTRIES 67
#define EVT_IEL_DESC_DATA_ENTRIES 463
#define EVT_IEL_VAR_DATA_ENTRIES 324
#define EVT_IEL_TRAP_DATA_ENTRIES 11
#define EVT_IEL_RIS_ALERT_DATA_ENTRIES 33
#define EVT_IEL_SER_EVENT_DATA_ENTRIES 0
    
//
// Number of SL Entries
//
#define EVT_SL_GEN_DATA_ENTRIES 161
#define EVT_SL_ACT_DATA_ENTRIES 102
#define EVT_SL_DESC_DATA_ENTRIES 161
#define EVT_SL_VAR_DATA_ENTRIES 89
#define EVT_SL_TRAP_DATA_ENTRIES 12
#define EVT_SL_RIS_ALERT_DATA_ENTRIES 39
#define EVT_SL_SER_EVENT_DATA_ENTRIES 0
    
    
#pragma pack(1)
    
    
//------------------------------------------------------------------------------------
//                            START ENCODING STRUCTURES                               
//------------------------------------------------------------------------------------
    
//
// Common Header
//
typedef struct _evtLogHdr
{
  WORD evtLength;            // Length of event including header
  DWORD evtNumber;           // Unique event number (can wrap)
  BYTE hdrRev;               // Header version 2
  BYTE severity:4;           // Event severity code
  BYTE flags:4;              // Event flags
  WORD evtClass;             // Event class or sub-system
  WORD evtCode;              // Event code for event in the class
  DWORD evtInitTime;         // Time of the event
  DWORD evtUpdatedTime;      // Time of the event
  DWORD count;               // Occurrence count (at least 1)
} EVT_HEADER, *PEVT_HEADER;
    
//
// Test IML Event: %1
//
typedef struct _evtIML_TEST_IML_EVENT_1_1
{
  char text[1];
} EVT_IML_TEST_IML_EVENT_1_1, *PEVT_IML_TEST_IML_EVENT_1_1;
    
//
// System Overheating (Temperature Sensor %1, Location %2, Temperature %3)
//
typedef struct _evtIML_MACHINE_OVERHEAT_2_19
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE zoneId;
  BYTE zoneType;
  BYTE temperature;
  BYTE locale;
  BYTE thermalDegradedAction;
  WORD sensorIndex;
  char chassisName[1];
} EVT_IML_MACHINE_OVERHEAT_2_19, *PEVT_IML_MACHINE_OVERHEAT_2_19;
    
//
// External Chassis Overheating (Chassis %1, Temperature Sensor %2, Location %3, Temperature %4)
//
typedef struct _evtIML_MACHINE_OVERHEAT_EXT_CHASSIS_2_20
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE zoneId;
  BYTE zoneType;
  BYTE temperature;
  BYTE locale;
  BYTE thermalDegradedAction;
  char chassisName[1];
} EVT_IML_MACHINE_OVERHEAT_EXT_CHASSIS_2_20, *PEVT_IML_MACHINE_OVERHEAT_EXT_CHASSIS_2_20;
    
//
// %1 Storage System Overheating (%2Slot %3, Temperature Sensor %4, Location %5, Temperature %6)
//
typedef struct _evtIML_MACHINE_OVERHEAT_STORAGE_2_21
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE zoneId;
  BYTE zoneType;
  BYTE temperature;
  BYTE locale;
  BYTE thermalDegradedAction;
  WORD sensorIndex;
  char chassisName[1];
} EVT_IML_MACHINE_OVERHEAT_STORAGE_2_21, *PEVT_IML_MACHINE_OVERHEAT_STORAGE_2_21;
    
//
// %1 Overheating (Temperature Sensor %2, Location %3, Temperature %4, %5)
//
typedef struct _evtIML_MACHINE_OVERHEAT_ENCLOSURE_2_22
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE zoneId;
  BYTE zoneType;
  BYTE temperature;
  BYTE locale;
  BYTE thermalDegradedAction;
  char chassisName[1];
} EVT_IML_MACHINE_OVERHEAT_ENCLOSURE_2_22, *PEVT_IML_MACHINE_OVERHEAT_ENCLOSURE_2_22;
    
//
// Fan Failure (Fan %1, Location %2)
//
typedef struct _evtIML_MACHINE_FAN_FAIL_2_23
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_FAIL_2_23, *PEVT_IML_MACHINE_FAN_FAIL_2_23;
    
//
// External Chassis Fan Failure (Chassis %1, Fan %2, Location %3)
//
typedef struct _evtIML_MACHINE_FAN_FAIL_EXT_CHASSIS_2_24
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_FAIL_EXT_CHASSIS_2_24, *PEVT_IML_MACHINE_FAN_FAIL_EXT_CHASSIS_2_24;
    
//
// %1 Storage System Fan Failure (%2 Slot %3, Fan %4, Location %5)
//
typedef struct _evtIML_MACHINE_FAN_FAIL_STORAGE_2_25
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_FAIL_STORAGE_2_25, *PEVT_IML_MACHINE_FAN_FAIL_STORAGE_2_25;
    
//
// %1 Fan Failure (Fan %2, Location %3, %4)
//
typedef struct _evtIML_MACHINE_FAN_FAIL_ENCLOSURE_2_26
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_FAIL_ENCLOSURE_2_26, *PEVT_IML_MACHINE_FAN_FAIL_ENCLOSURE_2_26;
    
//
// System Fan Removed (Fan %1, Location %2)
//
typedef struct _evtIML_MACHINE_FAN_REMOVED_2_27
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_REMOVED_2_27, *PEVT_IML_MACHINE_FAN_REMOVED_2_27;
    
//
// External Chassis Fan Removed (Chassis %1, Fan %2, Location %3)
//
typedef struct _evtIML_MACHINE_FAN_REMOVED_EXT_CHASSIS_2_28
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_REMOVED_EXT_CHASSIS_2_28, *PEVT_IML_MACHINE_FAN_REMOVED_EXT_CHASSIS_2_28;
    
//
// %1 Storage System Fan Removed (%2Slot %3, Fan %4, Location %5)
//
typedef struct _evtIML_MACHINE_FAN_REMOVED_STORAGE_2_29
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_REMOVED_STORAGE_2_29, *PEVT_IML_MACHINE_FAN_REMOVED_STORAGE_2_29;
    
//
// %1 Fan Removed (Fan %2, Location %3, %4)
//
typedef struct _evtIML_MACHINE_FAN_REMOVED_ENCLOSURE_2_30
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_REMOVED_ENCLOSURE_2_30, *PEVT_IML_MACHINE_FAN_REMOVED_ENCLOSURE_2_30;
    
//
// System Fan Inserted (Fan %1, Location %2)
//
typedef struct _evtIML_MACHINE_FAN_INSERTED_2_31
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_INSERTED_2_31, *PEVT_IML_MACHINE_FAN_INSERTED_2_31;
    
//
// External Chassis Fan Inserted (Chassis %1, Fan %2, Location %3)
//
typedef struct _evtIML_MACHINE_FAN_INSERTED_EXT_CHASSIS_2_32
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_INSERTED_EXT_CHASSIS_2_32, *PEVT_IML_MACHINE_FAN_INSERTED_EXT_CHASSIS_2_32;
    
//
// %1 Storage System Fan Inserted (%2Slot %3, Fan %4, Location %5)
//
typedef struct _evtIML_MACHINE_FAN_INSERTED_STORAGE_2_33
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_INSERTED_STORAGE_2_33, *PEVT_IML_MACHINE_FAN_INSERTED_STORAGE_2_33;
    
//
// %1 Fan Inserted (Fan %2, Location %3, %4)
//
typedef struct _evtIML_MACHINE_FAN_INSERTED_ENCLOSURE_2_34
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_INSERTED_ENCLOSURE_2_34, *PEVT_IML_MACHINE_FAN_INSERTED_ENCLOSURE_2_34;
    
//
// System Fans Not Redundant (Location %1)
//
typedef struct _evtIML_MACHINE_FAN_NOT_REDUNDANT_2_35
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_NOT_REDUNDANT_2_35, *PEVT_IML_MACHINE_FAN_NOT_REDUNDANT_2_35;
    
//
// External Chassis Fans Not Redundant (Chassis %1, Location %2)
//
typedef struct _evtIML_MACHINE_FAN_NOT_REDUNDANT_EXT_CHASSIS_2_36
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_NOT_REDUNDANT_EXT_CHASSIS_2_36, *PEVT_IML_MACHINE_FAN_NOT_REDUNDANT_EXT_CHASSIS_2_36;
    
//
// %1 Storage System Fans Not Redundant (%2Slot %3, Location %4)
//
typedef struct _evtIML_MACHINE_FAN_NOT_REDUNDANT_STORAGE_2_37
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  BYTE chassisName;
} EVT_IML_MACHINE_FAN_NOT_REDUNDANT_STORAGE_2_37, *PEVT_IML_MACHINE_FAN_NOT_REDUNDANT_STORAGE_2_37;
    
//
// %1 Fans Not Redundant (Location %2, %3)
//
typedef struct _evtIML_MACHINE_FAN_NOT_REDUNDANT_ENCLOSURE_2_38
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_NOT_REDUNDANT_ENCLOSURE_2_38, *PEVT_IML_MACHINE_FAN_NOT_REDUNDANT_ENCLOSURE_2_38;
    
//
// Critical Temperature Threshold Exceeded
//
typedef struct _evtIML_MACHINE_CRITICAL_OVERHEAT_2_39
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE zoneId;
  BYTE zoneType;
  BYTE temperature;
  BYTE locale;
  WORD sensorIndex;
  char chassisName[1];
} EVT_IML_MACHINE_CRITICAL_OVERHEAT_2_39, *PEVT_IML_MACHINE_CRITICAL_OVERHEAT_2_39;
    
//
// Critical Temperature Threshold Exceeded (Temperature Sensor %1, Location %2, Temperature %3C %4)
//
typedef struct _evtIML_MACHINE_CRITICAL_OVERHEAT_THRESHOLD_2_40
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE zoneId;
  BYTE zoneType;
  BYTE temperature;
  BYTE locale;
  WORD sensorIndex;
  char chassisName[1];
} EVT_IML_MACHINE_CRITICAL_OVERHEAT_THRESHOLD_2_40, *PEVT_IML_MACHINE_CRITICAL_OVERHEAT_THRESHOLD_2_40;
    
//
// External Chassis Overheating (Chassis %1, Temperature Sensor %2, Location %3, Temperature %4)
//
typedef struct _evtIML_MACHINE_CRITICAL_OVERHEAT_EXT_CHASSIS_2_41
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE zoneType;
  BYTE temperature;
  char chassisName[1];
} EVT_IML_MACHINE_CRITICAL_OVERHEAT_EXT_CHASSIS_2_41, *PEVT_IML_MACHINE_CRITICAL_OVERHEAT_EXT_CHASSIS_2_41;
    
//
// %1 Storage System Overheating (%2Slot %3, Temperature Sensor %4, Location %5, Temperature %6)
//
typedef struct _evtIML_MACHINE_CRITICAL_OVERHEAT_EXT_STORAGE_2_42
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE zoneId;
  BYTE zoneType;
  BYTE temperature;
  char chassisName[1];
} EVT_IML_MACHINE_CRITICAL_OVERHEAT_EXT_STORAGE_2_42, *PEVT_IML_MACHINE_CRITICAL_OVERHEAT_EXT_STORAGE_2_42;
    
//
// %1 Overheating (Temperature Sensor %2, Location %3, Temperature %4, %5)
//
typedef struct _evtIML_MACHINE_CRITICAL_OVERHEAT_ENCLOSURE_2_43
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE zoneId;
  BYTE zoneType;
  BYTE temperature;
  char chassisName[1];
} EVT_IML_MACHINE_CRITICAL_OVERHEAT_ENCLOSURE_2_43, *PEVT_IML_MACHINE_CRITICAL_OVERHEAT_ENCLOSURE_2_43;
    
//
// Temperature exceeded on PCIe disk %1.
//
typedef struct _evtIML_MACHINE_DISK_OVERHEAT_2_44
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE busId;
  BYTE deviceId;
  BYTE functionId;
  BYTE temperature;
  BYTE threshold;
  char location[1];
} EVT_IML_MACHINE_DISK_OVERHEAT_2_44, *PEVT_IML_MACHINE_DISK_OVERHEAT_2_44;
    
//
// %1 Storage Enclosure Fan Failure (Fan %2, Location %3, Box %4, %5)
//
typedef struct _evtIML_MACHINE_FAN_FAIL_SAS_2_49
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  BYTE boxId;
  char portId[1];
  //char chassisName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_MACHINE_FAN_FAIL_SAS_2_49, *PEVT_IML_MACHINE_FAN_FAIL_SAS_2_49;
    
//
// %1 Storage Enclosure Overheating (Temperature Sensor %2, Location %3, Box %4, %5)
//
typedef struct _evtIML_OVERHEAT_SAS_2_50
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE sensorId;
  BYTE sensorZoneType;
  BYTE box;
  char portId[1];
  //char chassisName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_OVERHEAT_SAS_2_50, *PEVT_IML_OVERHEAT_SAS_2_50;
    
//
// Fan Degraded (Fan %1, Location %2)
//
typedef struct _evtIML_MACHINE_FAN_DEGRADE_2_51
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE fanId;
  BYTE fanZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_FAN_DEGRADE_2_51, *PEVT_IML_MACHINE_FAN_DEGRADE_2_51;
    
//
// Inlet ambient temperature sensor :  %1C, exceeded the user defined pre-caution threshold : %2C.
//
typedef struct _evtIML_PRE_CAUTION_THRES_EXCEED_2_57
{
  BYTE currentTemperature;
  BYTE userDefinedTemperature;
} EVT_IML_PRE_CAUTION_THRES_EXCEED_2_57, *PEVT_IML_PRE_CAUTION_THRES_EXCEED_2_57;
    
//
// Minimum fan speed is changed to %1 percent by: %2.
//
typedef struct _evtIML_MIN_FAN_SPEED_SETTING_2_58
{
  DWORD number;
  char userName[1];
} EVT_IML_MIN_FAN_SPEED_SETTING_2_58, *PEVT_IML_MIN_FAN_SPEED_SETTING_2_58;
    
//
// Liquid Cooling module Failure (%1, Location %2)
//
typedef struct _evtIML_MACHINE_LIQUID_COOLED_PUMP_FAIL_2_59
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE liquidCoolingZoneType;
  BYTE liquidCoolingId;
  char liquidCoolingModuleName[1];
} EVT_IML_MACHINE_LIQUID_COOLED_PUMP_FAIL_2_59, *PEVT_IML_MACHINE_LIQUID_COOLED_PUMP_FAIL_2_59;
    
//
// Liquid Cooling Module Degraded (%1, Location %2)
//
typedef struct _evtIML_MACHINE_LIQUID_COOLING_PUMP_DEGRADED_2_60
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE liquidCoolingZoneType;
  BYTE liquidCoolingId;
  char liquidCoolingModuleName[1];
} EVT_IML_MACHINE_LIQUID_COOLING_PUMP_DEGRADED_2_60, *PEVT_IML_MACHINE_LIQUID_COOLING_PUMP_DEGRADED_2_60;
    
//
// System Liquid cooling modules are Not Redundant (Location %1)
//
typedef struct _evtIML_MACHINE_LIQUID_COOLING_NOT_REDUNDANT_2_61
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE liquidCoolingId;
  BYTE liquidCoolingZoneType;
  char chassisName[1];
} EVT_IML_MACHINE_LIQUID_COOLING_NOT_REDUNDANT_2_61, *PEVT_IML_MACHINE_LIQUID_COOLING_NOT_REDUNDANT_2_61;
    
//
// User Defined Temperature Threshold (Temperature Sensor %1 (%2), Threshold %3C, Temperature %4C)
//
typedef struct _evtIML_USER_DEF_CAUT_THRES_EXCEED_2_63
{
  BYTE sensorNumber;
  BYTE userDefinedTemperatureThreshold;
  BYTE currentTemperature;
  char sensorName[1];
} EVT_IML_USER_DEF_CAUT_THRES_EXCEED_2_63, *PEVT_IML_USER_DEF_CAUT_THRES_EXCEED_2_63;
    
//
// User Defined Temperature Threshold (Temperature Sensor %1 (%2), Threshold %3C, Temperature %4C)
//
typedef struct _evtIML_USER_DEF_CRIT_THRES_EXCEED_2_64
{
  BYTE sensorNumber;
  BYTE userDefinedTemperatureThreshold;
  BYTE currentTemperature;
  char sensorName[1];
} EVT_IML_USER_DEF_CRIT_THRES_EXCEED_2_64, *PEVT_IML_USER_DEF_CRIT_THRES_EXCEED_2_64;
    
//
// Liquid Cooling Module Missing(%1, Location %2)
//
typedef struct _evtIML_MACHINE_LIQUID_COOLING_PUMP_MISSING_2_66
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE liquidCoolingZoneType;
  BYTE liquidCoolingId;
  char liquidCoolingModuleName[1];
} EVT_IML_MACHINE_LIQUID_COOLING_PUMP_MISSING_2_66, *PEVT_IML_MACHINE_LIQUID_COOLING_PUMP_MISSING_2_66;
    
//
// #ILO thermal monitoring has determined that the %1 temperature sensor is not updating and has been marked stale.
//
typedef struct _evtIML_TEMP_SENSOR_STALE_2_67
{
  char sensorName[1];
} EVT_IML_TEMP_SENSOR_STALE_2_67, *PEVT_IML_TEMP_SENSOR_STALE_2_67;
    
//
// #ILO thermal monitoring has determined that the %1 temperature sensor is not updating and has been marked stale.
//
typedef struct _evtIML_TEMP_SENSOR_STALE_2_66_2_104
{
  char sensorName[1];
} EVT_IML_TEMP_SENSOR_STALE_2_66_2_104, *PEVT_IML_TEMP_SENSOR_STALE_2_66_2_104;
    
//
// No active warranty notification record for Closed-Loop Liquid Cooling Heat Sink for %1 location found.
//
typedef struct _evtIML_NO_ACTIVE_RECORDS_FOUND_FOR_LC_MODULE_2_105
{
  BYTE location;
} EVT_IML_NO_ACTIVE_RECORDS_FOUND_FOR_LC_MODULE_2_105, *PEVT_IML_NO_ACTIVE_RECORDS_FOUND_FOR_LC_MODULE_2_105;
    
//
// The Closed-Loop Liquid Cooling Heat Sink device on %1 has now been in operation for 54 months and will reach its 5-year Maximum Usage Limitation within 6 months. Replacement is required before or when the limitation is reached. 
//
typedef struct _evtIML_LIQUID_COOLING_TIME_LAPSED_WARNING_1_2_107
{
  BYTE location;
} EVT_IML_LIQUID_COOLING_TIME_LAPSED_WARNING_1_2_107, *PEVT_IML_LIQUID_COOLING_TIME_LAPSED_WARNING_1_2_107;
    
//
// The Closed-Loop Liquid Cooling Heat Sink device on %1 has now been in operation for 57 months and will reach its 5-year Maximum Usage Limitation within 3 months. Replacement is required before or when the limitation is reached. 
//
typedef struct _evtIML_LIQUID_COOLING_TIME_LAPSED_WARNING_2_2_108
{
  BYTE location;
} EVT_IML_LIQUID_COOLING_TIME_LAPSED_WARNING_2_2_108, *PEVT_IML_LIQUID_COOLING_TIME_LAPSED_WARNING_2_2_108;
    
//
// The Closed-Loop Liquid Cooling Heat Sink device on %1 has now been in operation  for 60 months and has reached its 5-year Maximum Usage Limitation. Replacement is required immediately.
//
typedef struct _evtIML_LIQUID_COOLING_TIME_LAPSED_2_109
{
  BYTE location;
} EVT_IML_LIQUID_COOLING_TIME_LAPSED_2_109, *PEVT_IML_LIQUID_COOLING_TIME_LAPSED_2_109;
    
//
// The air filter installed in the server has now operated for %1 days and will reach its maximum usage limit for high particulate environments in %2 days. To ensure optimal performance, it is advised that you inspect the air filter and replace it if necessary.
//
typedef struct _evtIML_AIR_FILTER_TIME_LAPSED_REMINDER_1_2_110
{
  WORD warning_days;
  WORD remaining_days;
} EVT_IML_AIR_FILTER_TIME_LAPSED_REMINDER_1_2_110, *PEVT_IML_AIR_FILTER_TIME_LAPSED_REMINDER_1_2_110;
    
//
// The air filter installed in the server has now operated for %1 days and has reached its maximum usage limit for high particulate environments. To ensure optimal performance, it is advised that you inspect the air filter and replace it if necessary.
//
typedef struct _evtIML_AIR_FILTER_TIME_LAPSED_FINAL_REMINDER_2_111
{
  WORD expiry_days;
} EVT_IML_AIR_FILTER_TIME_LAPSED_FINAL_REMINDER_2_111, *PEVT_IML_AIR_FILTER_TIME_LAPSED_FINAL_REMINDER_2_111;
    
//
// #ILO thermal monitoring has determined that the %1 temperature sensor is not updating and has been marked stale.
//
typedef struct _evtIML_TEMP_SENSOR_STALE_2_66_1_2_112
{
  char sensorName[1];
} EVT_IML_TEMP_SENSOR_STALE_2_66_1_2_112, *PEVT_IML_TEMP_SENSOR_STALE_2_66_1_2_112;
    
//
// Intrusion Alert Detection - The server chassis hood was removed %1.
//
typedef struct _evtIML_CHASSIS_HOOD_REMOVAL_2_113
{
  char time_stamp[1];
} EVT_IML_CHASSIS_HOOD_REMOVAL_2_113, *PEVT_IML_CHASSIS_HOOD_REMOVAL_2_113;
    
//
// Liquid cooling leakage detected (%1, Location %2)
//
typedef struct _evtIML_LIQUID_COOLING_LEAKAGE_DETECTED_2_137
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE liquidCoolingZoneType;
  BYTE liquidCoolingId;
  char liquidCoolingModuleName[1];
} EVT_IML_LIQUID_COOLING_LEAKAGE_DETECTED_2_137, *PEVT_IML_LIQUID_COOLING_LEAKAGE_DETECTED_2_137;
    
//
// Correctable Memory Error was detected (Processor %1)
//
typedef struct _evtIML_DIMM_CORR_ERROR_3_1
{
  BYTE processorNumber;
} EVT_IML_DIMM_CORR_ERROR_3_1, *PEVT_IML_DIMM_CORR_ERROR_3_1;
    
//
// An uncorrectable memory error was detected (Processor: %1,  MCU: %2, DIMM: %3, Error Status: %4, Error Address Low: %5, Error Address High: %6, Overflow: %7)
//
typedef struct _evtIML_DIMM_UNCORR_ERROR_3_2
{
  BYTE processorNumber;
  WORD mCU;
  BYTE dIMM;
  DWORD errorStatus;
  DWORD errorAddressLow;
  DWORD errorAddressHigh;
  BYTE overflow;
} EVT_IML_DIMM_UNCORR_ERROR_3_2, *PEVT_IML_DIMM_UNCORR_ERROR_3_2;
    
//
// Processor %1 DIMM %2 Channel %3 is HOT (Temp %4C)
//
typedef struct _evtIML_DIMM_HOT_3_3
{
  BYTE processorNumber;
  BYTE dimmNumber;
  BYTE channelNumber;
  WORD tempReading;
} EVT_IML_DIMM_HOT_3_3, *PEVT_IML_DIMM_HOT_3_3;
    
//
// Processor %1 DIMM VRD %2 is HOT (Temp %3C)
//
typedef struct _evtIML_DIMM_VRD_HOT_3_4
{
  BYTE processorNumber;
  BYTE dimmVrdNumber;
  WORD tempReading;
} EVT_IML_DIMM_VRD_HOT_3_4, *PEVT_IML_DIMM_VRD_HOT_3_4;
    
//
// Processor %1 DIMM VRD %2 Fault/Warning Detected.
//
typedef struct _evtIML_DIMM_VRD_FAULT_WARN_3_5
{
  BYTE processorNumber;
  BYTE dimmVrdNumber;
} EVT_IML_DIMM_VRD_FAULT_WARN_3_5, *PEVT_IML_DIMM_VRD_FAULT_WARN_3_5;
    
//
// An uncorrectable memory error was detected (Processor: %1, Error Component: %2, MCU: %3, Error Status: %4, Error Address Low: %5, Error Address High: %6, Overflow: %7)
//
typedef struct _evtIML_DIMM_UNCORR_ERROR_MISC_3_7
{
  BYTE processorNumber;
  BYTE errorComponent;
  WORD mCU;
  DWORD errorStatus;
  DWORD errorAddressLow;
  DWORD errorAddressHigh;
  BYTE overflow;
} EVT_IML_DIMM_UNCORR_ERROR_MISC_3_7, *PEVT_IML_DIMM_UNCORR_ERROR_MISC_3_7;
    
//
// DIMM Initialization Error - %1
//
typedef struct _evtIML_DDR_INIT_FAILURES_3_8
{
  BYTE dimmInitFailCause;
} EVT_IML_DDR_INIT_FAILURES_3_8, *PEVT_IML_DDR_INIT_FAILURES_3_8;
    
//
// DIMM %1 %2 Failure.
//
typedef struct _evtIML_DIMM_CONFIG_FAILURE_3_9
{
  BYTE entity;
  BYTE slot;
  BYTE mCU;
  BYTE dimm;
} EVT_IML_DIMM_CONFIG_FAILURE_3_9, *PEVT_IML_DIMM_CONFIG_FAILURE_3_9;
    
//
// An Uncorrectable Memory error was detected (Address: 0x%1%2, Module: 0x%3, Bank: 0x%4, Error type: %5)
//
typedef struct _evtIML_MEM_UNCORRECTABLE_ERROR_3_11
{
  DWORD physicalAddress_high;
  DWORD physicalAddress_low;
  WORD module;
  WORD bank;
  BYTE errorType;
} EVT_IML_MEM_UNCORRECTABLE_ERROR_3_11, *PEVT_IML_MEM_UNCORRECTABLE_ERROR_3_11;
    
//
// Uncorrectable Machine Check Exception (%1 %2, APIC ID 0x%3, Bank 0x%4, Status 0x%5'%6, Address 0x%7'%8, Misc 0x%9'%10). 
//
typedef struct _evtIML_CPU_UNCORR_MCE_5_3
{
  BYTE boardProcessor;
  BYTE deviceNumber;
  DWORD apicId;
  DWORD bank;
  DWORD status1;
  DWORD status2;
  DWORD address1;
  DWORD address2;
  DWORD misc1;
  DWORD misc2;
  BYTE recommendedAction;
  DWORD cpuSlot;
  DWORD cpuSpeed;
  DWORD cpuStep;
  DWORD cpuStatus;
  DWORD cpuExtSpeed;
  DWORD cpuSocketNumber;
  char cpuName[1];
  //char cpuHwLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_CPU_UNCORR_MCE_5_3, *PEVT_IML_CPU_UNCORR_MCE_5_3;
    
//
// Uncorrectable Machine Check Exception Extended Registers (Conf 0x%1'%2, Ipid 0x%3'%4, Synd 0x%5'%6, DeStat 0x%7'%8, DeAddr 0x%9'%10 Misc1 0x%11%12. 
//
typedef struct _evtIML_AMD_CPU_UNCORR_MCE_5_4
{
  DWORD config_1;
  DWORD config_2;
  DWORD ipid_1;
  DWORD ipid_2;
  DWORD synd_1;
  DWORD synd_2;
  DWORD deStat_1;
  DWORD deStat_2;
  DWORD deAddr_1;
  DWORD deAddr_2;
  DWORD misc1_1;
  DWORD misc1_2;
} EVT_IML_AMD_CPU_UNCORR_MCE_5_4, *PEVT_IML_AMD_CPU_UNCORR_MCE_5_4;
    
//
// System processor property is unexpected (%1)
//
typedef struct _evtIML_SYS_PROC_PROP_5_6
{
  BYTE proc_state;
} EVT_IML_SYS_PROC_PROP_5_6, *PEVT_IML_SYS_PROC_PROP_5_6;
    
//
// Processor %1 encountered Fault or Unrecoverable Error during early boot - Restart Initiated.
//
typedef struct _evtIML_PROC_FAULT_OR_UNRECOVERR_5_8
{
  BYTE processorNumber;
} EVT_IML_PROC_FAULT_OR_UNRECOVERR_5_8, *PEVT_IML_PROC_FAULT_OR_UNRECOVERR_5_8;
    
//
// Correctable Error was detected on Processor %1
//
typedef struct _evtIML_PROC_CORR_ERROR_5_9
{
  BYTE processorNumber;
} EVT_IML_PROC_CORR_ERROR_5_9, *PEVT_IML_PROC_CORR_ERROR_5_9;
    
//
// Processor %1 encountered a Critical Stop due to OS Crash or CPU Hang
//
typedef struct _evtIML_PROC_CRIT_STOP_5_10
{
  BYTE processorNumber;
} EVT_IML_PROC_CRIT_STOP_5_10, *PEVT_IML_PROC_CRIT_STOP_5_10;
    
//
// %1 Firmware RAS Internal Error Encountered
//
typedef struct _evtIML_RAS_INT_ERROR_5_11
{
  BYTE entityName;
} EVT_IML_RAS_INT_ERROR_5_11, *PEVT_IML_RAS_INT_ERROR_5_11;
    
//
// SoC %1 VRD Fault/Warning detected.
//
typedef struct _evtIML_SOC_VRD_FAULT_WARN_5_13
{
  BYTE soCNumber;
} EVT_IML_SOC_VRD_FAULT_WARN_5_13, *PEVT_IML_SOC_VRD_FAULT_WARN_5_13;
    
//
// SoC %1 VRD is HOT (Temp %2C)
//
typedef struct _evtIML_SOC_VRD_HOT_5_14
{
  BYTE soCNumber;
  WORD tempReading;
} EVT_IML_SOC_VRD_HOT_5_14, *PEVT_IML_SOC_VRD_HOT_5_14;
    
//
// Processor %1 Core VRD %2 Fault/Warning Detected.
//
typedef struct _evtIML_CORE_VRD_FAULT_WARN_5_15
{
  BYTE processorNumber;
  BYTE coreVRDNumber;
} EVT_IML_CORE_VRD_FAULT_WARN_5_15, *PEVT_IML_CORE_VRD_FAULT_WARN_5_15;
    
//
// Processor %1 Core VRD %2 is HOT (Temp %3C)
//
typedef struct _evtIML_CORE_VRD_HOT_5_16
{
  BYTE processorNumber;
  BYTE coreVRDNumber;
  WORD tempReading;
} EVT_IML_CORE_VRD_HOT_5_16, *PEVT_IML_CORE_VRD_HOT_5_16;
    
//
// Uncorrectable Processor Error was detected (Processor: %1, Error Component: %2, Cluster Processor Module: %3, Error Status: %4, Error Address Low: %5, Error Address High: %6, Overflow: %7)
//
typedef struct _evtIML_CPU_UNC_ERROR_5_17
{
  BYTE processorNumber;
  BYTE errorComponent;
  WORD clusterProcessorModule;
  DWORD errorStatus;
  DWORD errorAddressLow;
  DWORD errorAddressHigh;
  BYTE overflow;
} EVT_IML_CPU_UNC_ERROR_5_17, *PEVT_IML_CPU_UNC_ERROR_5_17;
    
//
// Fatal error detected - %1 - Recovery: %2
//
typedef struct _evtIML_AMD_FATAL_ERROR_ADDC_5_19
{
  BYTE action;
  BYTE recovery;
} EVT_IML_AMD_FATAL_ERROR_ADDC_5_19, *PEVT_IML_AMD_FATAL_ERROR_ADDC_5_19;
    
//
// Processor Mismatch Found. Number of Processor(s) discovered %1. Expected Processor(s) %2.
//
typedef struct _evtIML_EVT_CPU_MISMTACH_5_24
{
  BYTE discoveredProcCount;
  BYTE expectedProcCount;
} EVT_IML_EVT_CPU_MISMTACH_5_24, *PEVT_IML_EVT_CPU_MISMTACH_5_24;
    
//
// An Uncorrectable Processor Error was detected (Processor: %1, Error Type: %2, Error count: %3)
//
typedef struct _evtIML_PROC_UNCORRECTABLE_ERROR_5_25
{
  BYTE processorNumber;
  BYTE errorType;
  BYTE errorCount;
} EVT_IML_PROC_UNCORRECTABLE_ERROR_5_25, *PEVT_IML_PROC_UNCORRECTABLE_ERROR_5_25;
    
//
// Uncorrectable UPI Error was detected on Processor %1
//
typedef struct _evtIML_UPI_ERROR_6_3
{
  BYTE processorNumber;
} EVT_IML_UPI_ERROR_6_3, *PEVT_IML_UPI_ERROR_6_3;
    
//
// Uncorrectable PCI Express Error Detected. %1 %2 (Segment 0x%3, Bus 0x%4, Device 0x%5, Function 0x%6).  Uncorrectable Error Status: 0x%7
//
typedef struct _evtIML_PCIE_SLOT_ERROR_8_2
{
  BYTE slotNumber;
  WORD segmentNumber;
  BYTE busNumber;
  BYTE deviceNumber;
  BYTE functionNumber;
  DWORD errorStatusReg;
  BYTE deviceType;
} EVT_IML_PCIE_SLOT_ERROR_8_2, *PEVT_IML_PCIE_SLOT_ERROR_8_2;
    
//
// Uncorrectable PCI Express Error Detected. NVMe Box %1 Bay %2 (Segment 0x%3, Bus 0x%4, Device 0x%5, Function 0x%6).  Uncorrectable Error Status: 0x%7
//
typedef struct _evtIML_PCIE_NVME_ERROR_8_3
{
  BYTE boxNumber;
  WORD segmentNumber;
  BYTE busNumber;
  BYTE deviceNumber;
  BYTE functionNumber;
  DWORD errorStatusReg;
  BYTE bayNumber;
} EVT_IML_PCIE_NVME_ERROR_8_3, *PEVT_IML_PCIE_NVME_ERROR_8_3;
    
//
// Uncorrectable PCI Express Error Detected. %1 %2 (Segment 0x%2, Bus 0x%3, Device 0x%4, Function 0x%5). 
//
typedef struct _evtIML_PCIE_SLOT_ERROR_NO_AER_8_4
{
  BYTE slotNumber;
  WORD segmentNumber;
  BYTE busNumber;
  BYTE deviceNumber;
  BYTE functionNumber;
  BYTE deviceType;
} EVT_IML_PCIE_SLOT_ERROR_NO_AER_8_4, *PEVT_IML_PCIE_SLOT_ERROR_NO_AER_8_4;
    
//
// Uncorrectable PCI Express Error Detected. NVMe Box %1 Bay %2 (Segment 0x%3, Bus 0x%4, Device 0x%5, Function 0x%6).
//
typedef struct _evtIML_PCIE_NVME_ERROR_NO_AER_8_5
{
  BYTE boxNumber;
  WORD segmentNumber;
  BYTE busNumber;
  BYTE deviceNumber;
  BYTE functionNumber;
  BYTE bayNumber;
} EVT_IML_PCIE_NVME_ERROR_NO_AER_8_5, *PEVT_IML_PCIE_NVME_ERROR_NO_AER_8_5;
    
//
// PCI Express Uncorrectable Error Detected (Processor: %1, Segment: %2, Bus: %3, Device: %4, Function: %5, AER Uncorrectable Error Status: %6, Overflow: %7, Slot ID: %8, Slot: %9)
//
typedef struct _evtIML_PCIE_UNCORR_ERROR_8_7
{
  BYTE processorNumber;
  WORD segment;
  BYTE bus;
  BYTE device;
  BYTE function;
  DWORD aERUncorrectableErrorStatus;
  BYTE overflow;
  WORD pCIeSlotID;
  char pCIeSlot[1];
} EVT_IML_PCIE_UNCORR_ERROR_8_7, *PEVT_IML_PCIE_UNCORR_ERROR_8_7;
    
//
// PCI Express Uncorrectable Error Detected on Root Port (Processor: %1, Segment: %2, AER Uncorrectable Error Status: %3, Overflow: %4, Bus: %5, Device: %6, Function: %7)
//
typedef struct _evtIML_PCIE_UNCORR_ERROR_AER_8_8
{
  BYTE processorNumber;
  WORD segment;
  DWORD aERUncorrectableErrorStatus;
  BYTE overflow;
  BYTE bus;
  BYTE device;
  BYTE function;
} EVT_IML_PCIE_UNCORR_ERROR_AER_8_8, *PEVT_IML_PCIE_UNCORR_ERROR_AER_8_8;
    
//
// Uncorrectable PCI Express Error Detected. OCP Slot %1 (Segment 0x%2, Bus 0x%3, Device 0x%4, Function 0x%5). Uncorrectable Error Status: 0x%6
//
typedef struct _evtIML_OCP_SLOT_ERROR_8_10
{
  WORD segmentNumber;
  BYTE busNumber;
  BYTE deviceNumber;
  BYTE functionNumber;
  DWORD errorStatusReg;
  char slotString[1];
} EVT_IML_OCP_SLOT_ERROR_8_10, *PEVT_IML_OCP_SLOT_ERROR_8_10;
    
//
// Uncorrectable PCI Express Error Detected. OCP Slot %1 (Segment 0x%2, Bus 0x%3, Device 0x%4, Function 0x%5). 
//
typedef struct _evtIML_OCP_SLOT_ERROR_NO_AER_8_11
{
  WORD segmentNumber;
  BYTE busNumber;
  BYTE deviceNumber;
  BYTE functionNumber;
  char slotString[1];
} EVT_IML_OCP_SLOT_ERROR_NO_AER_8_11, *PEVT_IML_OCP_SLOT_ERROR_NO_AER_8_11;
    
//
// An Uncorrectable PCI Express Error Detected on Port type: %1 (Segment: 0x%2, Bus: %3, Device: %4, Function: %5) %6
//
typedef struct _evtIML_PCIE_UNCORRECTABLE_ERROR_8_12
{
  BYTE portType;
  WORD segment;
  BYTE bus;
  BYTE device;
  BYTE function;
  char pCIeSlot[1];
} EVT_IML_PCIE_UNCORRECTABLE_ERROR_8_12, *PEVT_IML_PCIE_UNCORRECTABLE_ERROR_8_12;
    
//
// Power Fault Detected-Mezzanine %1.
//
typedef struct _evtIML_PWR_FAIL_FLEX_MEZZ_10_549
{
  BYTE mezzanineCardNumber;
} EVT_IML_PWR_FAIL_FLEX_MEZZ_10_549, *PEVT_IML_PWR_FAIL_FLEX_MEZZ_10_549;
    
//
// Power Fault Detected - Embedded Storage Controller %1.
//
typedef struct _evtIML_PWR_FAIL_EBD_STOR_10_550
{
  BYTE storageControllerNumber;
  char oem[1];
} EVT_IML_PWR_FAIL_EBD_STOR_10_550, *PEVT_IML_PWR_FAIL_EBD_STOR_10_550;
    
//
// Power Fault Detected - M.2 riser
//
typedef struct _evtIML_PWR_FAIL_M2_10_551
{
  char oem[1];
} EVT_IML_PWR_FAIL_M2_10_551, *PEVT_IML_PWR_FAIL_M2_10_551;
    
//
// The device in PCIe Slot %1 is SRIOV capable but is installed in a slot that does NOT support SRIOV.
//
typedef struct _evtIML_SRIOV_NON_SRIOV_SLOT_10_580
{
  BYTE slotNumber;
} EVT_IML_SRIOV_NON_SRIOV_SLOT_10_580, *PEVT_IML_SRIOV_NON_SRIOV_SLOT_10_580;
    
//
// Switches SW1 and SW3 are ON. This is only used to recover %1 functionality.
//
typedef struct _evtIML_SW1_SW3_ON_10_593
{
  char bmc[1];
} EVT_IML_SW1_SW3_ON_10_593, *PEVT_IML_SW1_SW3_ON_10_593;
    
//
// The PCIe Device installed in %1 %2 has no corresponding processor installed and will not function.
//
typedef struct _evtIML_NON_INS_PROC_PCIE_SLT_10_596
{
  BYTE slotNumber;
  BYTE processorNumber;
  BYTE deviceType;
} EVT_IML_NON_INS_PROC_PCIE_SLT_10_596, *PEVT_IML_NON_INS_PROC_PCIE_SLT_10_596;
    
//
// Non-Volatile Memory Corruption Detected. Configuration settings restored to defaults. If enabled, Secure Boot security settings may be lost.
//
typedef struct _evtIML_NVM_CORRUPTION_10_614
{
  char oem[1];
} EVT_IML_NVM_CORRUPTION_10_614, *PEVT_IML_NVM_CORRUPTION_10_614;
    
//
// UEFI Non-Volatile Variable Store Corruption Detected. If enabled, Secure Boot security settings may be lost.
//
typedef struct _evtIML_NVM_VAR_CORRUPTION_10_616
{
  char oem[1];
} EVT_IML_NVM_VAR_CORRUPTION_10_616, *PEVT_IML_NVM_VAR_CORRUPTION_10_616;
    
//
// %1 FW Communication Issue - Unable to communicate with %2 FW. Certain management functionality is not available.
//
typedef struct _evtIML_ILO_FW_COM_FAIL_OLD_10_624
{
  char bmc[1];
  //char oem[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_ILO_FW_COM_FAIL_OLD_10_624, *PEVT_IML_ILO_FW_COM_FAIL_OLD_10_624;
    
//
// %1 %2, DIMM %3 may not be a Genuine %4 DIMM.
//
typedef struct _evtIML_COUNTERFEIT_SMART_MEM_10_626
{
  BYTE boardProcessor;
  BYTE deviceNumber;
  BYTE dimmNumber;
  char oemSmartMemory[1];
} EVT_IML_COUNTERFEIT_SMART_MEM_10_626, *PEVT_IML_COUNTERFEIT_SMART_MEM_10_626;
    
//
// DIMM Failure - Uncorrectable Memory Error (%1 %2, DIMM %3)
//
typedef struct _evtIML_DIMM_UNC_MEM_ERR_10_644
{
  BYTE boardProcessor;
  BYTE deviceNumber;
  BYTE dimm;
} EVT_IML_DIMM_UNC_MEM_ERR_10_644, *PEVT_IML_DIMM_UNC_MEM_ERR_10_644;
    
//
// Invalid %1 Software RAID Configuration. %2 SW RAID Mode is NOT supported when the Boot Mode is configured for legacy BIOS Mode.
//
typedef struct _evtIML_SW_RAID_CHG_MODE_10_658
{
  char oem[1];
} EVT_IML_SW_RAID_CHG_MODE_10_658, *PEVT_IML_SW_RAID_CHG_MODE_10_658;
    
//
// %1 Security is disabled by the associated switch being set to the ON position.  Platform security is DISABLED.
//
typedef struct _evtIML_SW1_ON_10_663
{
  char bmc[1];
} EVT_IML_SW1_ON_10_663, *PEVT_IML_SW1_ON_10_663;
    
//
// %1 Configuration Error - The system has exceeded the installed energy pack capacity.
//
typedef struct _evtIML_SM_STOR_BATT_CFG_ERR_EXCEED_CAP_10_785
{
  char batteryBranding[1];
  //char bmcBranding[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SM_STOR_BATT_CFG_ERR_EXCEED_CAP_10_785, *PEVT_IML_SM_STOR_BATT_CFG_ERR_EXCEED_CAP_10_785;
    
//
// %1 %2 Communication Failure - Communication with the energy pack failed. Its output may not be enabled.
//
typedef struct _evtIML_SM_STOR_BATT_FAIL_COM_FAIL_10_786
{
  BYTE batteryNumber;
  char batteryBranding[1];
  //char bmcBranding[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char oemBranding[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SM_STOR_BATT_FAIL_COM_FAIL_10_786, *PEVT_IML_SM_STOR_BATT_FAIL_COM_FAIL_10_786;
    
//
// %1 Dual microSD Device Unsupported Configuration - A microSD card is not installed in Slot %2
//
typedef struct _evtIML_DUAL_SD_CFG_ERR_ONE_NOT_INST_10_801
{
  BYTE slotNumber;
  char oem[1];
} EVT_IML_DUAL_SD_CFG_ERR_ONE_NOT_INST_10_801, *PEVT_IML_DUAL_SD_CFG_ERR_ONE_NOT_INST_10_801;
    
//
// %1 Dual microSD Device Unsupported Configuration - No microSD cards are installed.
//
typedef struct _evtIML_DUAL_SD_CFG_ERR_ALL_NOT_INST_10_802
{
  char oem[1];
} EVT_IML_DUAL_SD_CFG_ERR_ALL_NOT_INST_10_802, *PEVT_IML_DUAL_SD_CFG_ERR_ALL_NOT_INST_10_802;
    
//
// %1 Dual microSD Device Error - The microSD card in Slot %2 has failed.
//
typedef struct _evtIML_DUAL_SD_CFG_ERR_ONE_FAIL_10_803
{
  BYTE slotNumber;
  char oem[1];
} EVT_IML_DUAL_SD_CFG_ERR_ONE_FAIL_10_803, *PEVT_IML_DUAL_SD_CFG_ERR_ONE_FAIL_10_803;
    
//
// %1 Dual microSD Device Error - Both microSD cards have failed.
//
typedef struct _evtIML_DUAL_SD_CFG_ERR_ALL_FAIL_10_804
{
  char oem[1];
} EVT_IML_DUAL_SD_CFG_ERR_ALL_FAIL_10_804, *PEVT_IML_DUAL_SD_CFG_ERR_ALL_FAIL_10_804;
    
//
// %1 Dual microSD Device Error - microSD cards have conflicting metadata. Configuration required. 
//
typedef struct _evtIML_DUAL_SD_CFG_ERR_CONFLICT_META_DATA_10_805
{
  char oem[1];
} EVT_IML_DUAL_SD_CFG_ERR_CONFLICT_META_DATA_10_805, *PEVT_IML_DUAL_SD_CFG_ERR_CONFLICT_META_DATA_10_805;
    
//
// %1 Dual microSD Device Error - The microSD card in Slot %2 has failed. A microSD card is not installed in Slot %3.
//
typedef struct _evtIML_DUAL_SD_CFG_ERR_SLTX_FAIL_SLT1_ABSENT_10_806
{
  BYTE slotNumber1;
  BYTE slotNumber2;
  char oem[1];
} EVT_IML_DUAL_SD_CFG_ERR_SLTX_FAIL_SLT1_ABSENT_10_806, *PEVT_IML_DUAL_SD_CFG_ERR_SLTX_FAIL_SLT1_ABSENT_10_806;
    
//
// Power Management Controller FW Error - Unable to communicate with the FW.
//
typedef struct _evtIML_PMC_FW_ERR_COM_FW_10_809
{
  char bmc[1];
} EVT_IML_PMC_FW_ERR_COM_FW_10_809, *PEVT_IML_PMC_FW_ERR_COM_FW_10_809;
    
//
// %1 RESTful API Error - Unable to communicate with %2 FW. BIOS configuration resources may not be up-to-date.
//
typedef struct _evtIML_RESTFUL_API_ERR_COM_ILO_FAIL_RESET_ILO_10_819
{
  char oem[1];
  //char bmc[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_RESTFUL_API_ERR_COM_ILO_FAIL_RESET_ILO_10_819, *PEVT_IML_RESTFUL_API_ERR_COM_ILO_FAIL_RESET_ILO_10_819;
    
//
// %1 RESTful API Error - RESTful API GET request failed (HTTP Status Code : %2). BIOS configuration resources were not consumed.
//
typedef struct _evtIML_RESTFUL_API_ERR_GET_REQ_FAIL_10_820
{
  WORD statusCode;
  char oem[1];
  //char bmc[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_RESTFUL_API_ERR_GET_REQ_FAIL_10_820, *PEVT_IML_RESTFUL_API_ERR_GET_REQ_FAIL_10_820;
    
//
// %1 RESTful API Error - RESTful API PUT request failed (HTTP Status Code : %2). BIOS configuration resources may not be up-to-date.
//
typedef struct _evtIML_RESTFUL_API_ERR_PUT_REG_FAIL_10_821
{
  WORD statusCode;
  char oem[1];
  //char bmc[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_RESTFUL_API_ERR_PUT_REG_FAIL_10_821, *PEVT_IML_RESTFUL_API_ERR_PUT_REG_FAIL_10_821;
    
//
// %1 RESTful API Error - Unable to communicate with %2 FW. BIOS configuration resources may not be up-to-date.
//
typedef struct _evtIML_RESTFUL_API_ERR_COM_ILO_FAIL_10_824
{
  char oem[1];
  //char bmc[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_RESTFUL_API_ERR_COM_ILO_FAIL_10_824, *PEVT_IML_RESTFUL_API_ERR_COM_ILO_FAIL_10_824;
    
//
// NVDIMM Error - Backup Error - Processor %1, DIMM %2 (SN:%3-%4-%5-%6). Persistent data backup failed and data is irrecoverably lost.
//
typedef struct _evtIML_NVDIMM_BACKUP_ERR_10_832
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_BACKUP_ERR_10_832, *PEVT_IML_NVDIMM_BACKUP_ERR_10_832;
    
//
// NVDIMM Error - Restore Error - Processor %1, DIMM %2 (SN:%3-%4-%5-%6). Persistent data restore failed and data is not available.  Data is not lost unless the issue persists.
//
typedef struct _evtIML_NVDIMM_RESTORE_ERR_10_833
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_RESTORE_ERR_10_833, *PEVT_IML_NVDIMM_RESTORE_ERR_10_833;
    
//
// NVDIMM Error - Uncorrectable Memory Error - Processor %1, DIMM %2 (SN:%3-%4-%5-%6). This NVDIMM will not be available to the operating system and data may have been lost.
//
typedef struct _evtIML_NVDIMM_UNC_ERR_10_834
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_UNC_ERR_10_834, *PEVT_IML_NVDIMM_UNC_ERR_10_834;
    
//
// NVDIMM backup power has been lost and a future backup is not possible. Data from the last successful backup is intact, but data modified after the last successful backup will be lost if power cannot be restored.
//
typedef struct _evtIML_NVDIMM_BACKUP_PWR_ERR_10_835
{
  char oemBranding[1];
} EVT_IML_NVDIMM_BACKUP_PWR_ERR_10_835, *PEVT_IML_NVDIMM_BACKUP_PWR_ERR_10_835;
    
//
// NVDIMM Error - NVDIMM Controller Error - Processor %1, DIMM %2 (SN:%3-%4-%5-%6). An error was found with the NVDIMM controller. The OS will not use the NVDIMM. Data from last successful backup is still available, but will be lost if controller error persists.
//
typedef struct _evtIML_NVDIMM_CTRL_ERR_10_836
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_CTRL_ERR_10_836, *PEVT_IML_NVDIMM_CTRL_ERR_10_836;
    
//
// NVDIMM Error - Erase Error - Processor %1, DIMM %2 (SN:%3-%4-%5-%6). NVDIMM could not be erased by the NVDIMM controller FW and future backups are not possible.
//
typedef struct _evtIML_NVDIMM_ERASE_ERR_10_837
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_ERASE_ERR_10_837, *PEVT_IML_NVDIMM_ERASE_ERR_10_837;
    
//
// NVDIMM Error - Arming Error - Processor %1, DIMM %2 (SN:%3-%4-%5-%6). NVDIMM could not be armed and future backups are not possible.
//
typedef struct _evtIML_NVDIMM_ARMING_ERR_10_838
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_ARMING_ERR_10_838, *PEVT_IML_NVDIMM_ARMING_ERR_10_838;
    
//
// %1 is not charged sufficiently to support the energy-backed persistent memory installed in the system. The system will wait for the energy source to charge sufficiently before continuing boot.
//
typedef struct _evtIML_SM_STOR_BATT_NOT_CHARGED_WAIT_10_849
{
  char batteryBranding[1];
  //char bmcBranding[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SM_STOR_BATT_NOT_CHARGED_WAIT_10_849, *PEVT_IML_SM_STOR_BATT_NOT_CHARGED_WAIT_10_849;
    
//
// %1 is not charged sufficiently to support the energy-backed persistent memory installed in the system. System configured to not wait for energy source to charge. Persistent memory regions may not be available in the OS.
//
typedef struct _evtIML_SM_STOR_BATT_NOT_CHARGED_NO_WAIT_10_850
{
  char batteryBranding[1];
  //char bmcBranding[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SM_STOR_BATT_NOT_CHARGED_NO_WAIT_10_850, *PEVT_IML_SM_STOR_BATT_NOT_CHARGED_NO_WAIT_10_850;
    
//
// Processor %1, DIMM %2 (SN:%3-%4-%5-%6) - This NVDIMM-N was selected for Sanitizing/Erasing. All data saved in the NVDIMM has been erased.
//
typedef struct _evtIML_NVDIMM_SANI_OK_10_853
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_SANI_OK_10_853, *PEVT_IML_NVDIMM_SANI_OK_10_853;
    
//
// NVDIMM Error - Sanitization Error - Processor %1, DIMM %2 (SN:%3-%4-%5-%6) - This NVDIMM-N was selected for Sanitizing/Erasing, but this process was not successful.
//
typedef struct _evtIML_NVDIMM_SANI_FAIL_10_854
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_SANI_FAIL_10_854, *PEVT_IML_NVDIMM_SANI_FAIL_10_854;
    
//
// Processor %1, DIMM %2 - This NVDIMM is NOT a %3 NVDIMM. Only %4 NVDIMMs are supported. NVDIMM will be used as a standard DIMM.
//
typedef struct _evtIML_NVDIMM_NON_SMART_MEM_10_855
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char oemSmartMemory[1];
} EVT_IML_NVDIMM_NON_SMART_MEM_10_855, *PEVT_IML_NVDIMM_NON_SMART_MEM_10_855;
    
//
// The Processor RAPL wattage value is configured to an invalid value. User provided value was %1, but %2 has been assigned since it is closest to %3.
//
typedef struct _evtIML_INVALID_PROC_RAPL_WATT_10_865
{
  WORD userRaplValue;
  WORD systemRaplValue;
  BYTE minMax;
} EVT_IML_INVALID_PROC_RAPL_WATT_10_865, *PEVT_IML_INVALID_PROC_RAPL_WATT_10_865;
    
//
// The DRAM RAPL wattage value is configured to an invalid value. User provided value was %1, but %2 has been assigned since it is closest to %3.
//
typedef struct _evtIML_INVALID_DIMM_RAPL_WATT_10_866
{
  WORD userRaplValue;
  WORD systemRaplValue;
  BYTE minMax;
} EVT_IML_INVALID_DIMM_RAPL_WATT_10_866, *PEVT_IML_INVALID_DIMM_RAPL_WATT_10_866;
    
//
// New NVDIMM(s) detected on Processor %1. All NVDIMMs on Processor %2 have been disabled.
//
typedef struct _evtIML_NVDIMM_SET_GUID_MISMATCH_10_867
{
  BYTE processorNumber;
} EVT_IML_NVDIMM_SET_GUID_MISMATCH_10_867, *PEVT_IML_NVDIMM_SET_GUID_MISMATCH_10_867;
    
//
// NVDIMM Error - NVDIMM Controller Error - Processor %1, DIMM %2.  The controller firmware has been corrupted. The OS will not use the NVDIMM.
//
typedef struct _evtIML_NVDIMM_FW_ERROR_10_868
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_NVDIMM_FW_ERROR_10_868, *PEVT_IML_NVDIMM_FW_ERROR_10_868;
    
//
// Processor %1, DIMM %2. New NVDIMM detected and has been disabled.
//
typedef struct _evtIML_NEW_NVDIMM_INTERLEAVE_ON_10_881
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_NEW_NVDIMM_INTERLEAVE_ON_10_881, *PEVT_IML_NEW_NVDIMM_INTERLEAVE_ON_10_881;
    
//
// Processor %1, DIMM %2. New NVDIMM detected and has been disabled.
//
typedef struct _evtIML_NEW_NVDIMM_INTERLEAVE_OFF_10_882
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_NEW_NVDIMM_INTERLEAVE_OFF_10_882, *PEVT_IML_NEW_NVDIMM_INTERLEAVE_OFF_10_882;
    
//
// NVDIMM(s) have been removed from Processor %1. All NVDIMMs on Processor %2 have been disabled.
//
typedef struct _evtIML_NVDIMM_REMOVED_INTERLEAVE_ON_10_883
{
  BYTE processorNumber;
} EVT_IML_NVDIMM_REMOVED_INTERLEAVE_ON_10_883, *PEVT_IML_NVDIMM_REMOVED_INTERLEAVE_ON_10_883;
    
//
// NVDIMM Error - Processor %1, DIMM %2 (SN:%3-%4-%5-%6) received a memory initialization or uncorrectable error. All NVDIMMs on Proc %7 are disabled. Data on NVDIMM may have been lost
//
typedef struct _evtIML_MRC_ERR_INTERLEAVE_ON_10_884
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_MRC_ERR_INTERLEAVE_ON_10_884, *PEVT_IML_MRC_ERR_INTERLEAVE_ON_10_884;
    
//
// NVDIMM Error - Processor %1, DIMM %2 (SN:%3-%4-%5-%6) received a memory initialization or uncorrectable error. NVDIMM has been disabled. Data on NVDIMM may have been lost.
//
typedef struct _evtIML_MRC_ERR_INTERLEAVE_OFF_10_885
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_MRC_ERR_INTERLEAVE_OFF_10_885, *PEVT_IML_MRC_ERR_INTERLEAVE_OFF_10_885;
    
//
// NVDIMM Error - Processor %1, DIMM %2. NVDIMM set for interleaving disabled but system configured for interleaving enabled. All NVDIMMs on Processor %3 are disabled.
//
typedef struct _evtIML_NVDIMM_INTERLEAVE_ON_10_886
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_NVDIMM_INTERLEAVE_ON_10_886, *PEVT_IML_NVDIMM_INTERLEAVE_ON_10_886;
    
//
// NVDIMM Error - Processor %1, DIMM %2. NVDIMM set for interleaving enabled but system configured for interleaving disabled. NVDIMM has been disabled.
//
typedef struct _evtIML_NVDIMM_INTERLEAVE_OFF_10_887
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_NVDIMM_INTERLEAVE_OFF_10_887, *PEVT_IML_NVDIMM_INTERLEAVE_OFF_10_887;
    
//
// NVDIMM Error - Processor %1, DIMM %2. NVDIMM is configured for a different processor type. All NVDIMMs on Processor %3 are disabled.
//
typedef struct _evtIML_PROC_TYPE_INTERLEAVE_ON_10_888
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_PROC_TYPE_INTERLEAVE_ON_10_888, *PEVT_IML_PROC_TYPE_INTERLEAVE_ON_10_888;
    
//
// NVDIMM Error - Processor %1, DIMM %2. NVDIMM is configured for a different processor type. NVDIMM has been disabled.
//
typedef struct _evtIML_PROC_TYPE_INTERLEAVE_OFF_10_889
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_PROC_TYPE_INTERLEAVE_OFF_10_889, *PEVT_IML_PROC_TYPE_INTERLEAVE_OFF_10_889;
    
//
// NVDIMM Error - Proc %1, DIMM %2 is NOT configured for Sub-NUMA Clustering but system is configured for Sub-NUMA Clustering. All NVDIMMs on Proc %3 are disabled.
//
typedef struct _evtIML_NVDIMM_CFG_ERR_SNC_ON_10_898
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_NVDIMM_CFG_ERR_SNC_ON_10_898, *PEVT_IML_NVDIMM_CFG_ERR_SNC_ON_10_898;
    
//
// NVDIMM Error - Proc %1, DIMM %2 is configured for Sub-NUMA Clustering but system is NOT configured for Sub-NUMA Clustering. All NVDIMMs on Proc %3 are disabled.
//
typedef struct _evtIML_NVDIMM_CFG_ERR_SNC_OFF_10_899
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_NVDIMM_CFG_ERR_SNC_OFF_10_899, *PEVT_IML_NVDIMM_CFG_ERR_SNC_OFF_10_899;
    
//
// NVDIMM Error - Processor %1, DIMM %2. NVDIMM set for Channel Interleaving disabled but system configured for enabled. All NVDIMMs on Processor %3 are disabled.
//
typedef struct _evtIML_CHNL_INTERLEAVE_ON_10_900
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_CHNL_INTERLEAVE_ON_10_900, *PEVT_IML_CHNL_INTERLEAVE_ON_10_900;
    
//
// NVDIMM Error - Processor %1, DIMM %2. NVDIMM set for Channel Interleaving enabled but system configured for disabled. All NVDIMMs on Processor %3 are disabled.
//
typedef struct _evtIML_CHNL_INTERLEAVE_OFF_10_901
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_CHNL_INTERLEAVE_OFF_10_901, *PEVT_IML_CHNL_INTERLEAVE_OFF_10_901;
    
//
// NVDIMM Error - Processor %1, DIMM %2. NVDIMM Metadata is corrupted. All NVDIMMs on Processor %3 are disabled.
//
typedef struct _evtIML_METADATA_CORRUPTED_INTERLEAVE_ON_10_902
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_METADATA_CORRUPTED_INTERLEAVE_ON_10_902, *PEVT_IML_METADATA_CORRUPTED_INTERLEAVE_ON_10_902;
    
//
// NVDIMM Error - Processor %1, DIMM %2. NVDIMM Metadata is corrupted. NVDIMM is disabled.
//
typedef struct _evtIML_METADATA_CORRUPTED_INTERLEAVE_OFF_10_903
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_METADATA_CORRUPTED_INTERLEAVE_OFF_10_903, *PEVT_IML_METADATA_CORRUPTED_INTERLEAVE_OFF_10_903;
    
//
// NVDIMM Error - Processor %1, DIMM %2 (SN:%3-%4-%5-%6). Unable to set event notification for this NVDIMM to generate alerts for health changes, including a loss of data persistency.
//
typedef struct _evtIML_NVDIMM_EVT_NOTIFY_ERR_INFO_10_916
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_EVT_NOTIFY_ERR_INFO_10_916, *PEVT_IML_NVDIMM_EVT_NOTIFY_ERR_INFO_10_916;
    
//
// NVDIMM Error - Processor %1, DIMM %2  (SN:%3-%4-%5-%6). NVDIMM Persistency is lost and future data backup is not available.
//
typedef struct _evtIML_NVDIMM_PERSIS_LOST_ERR_INFO_10_917
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_PERSIS_LOST_ERR_INFO_10_917, *PEVT_IML_NVDIMM_PERSIS_LOST_ERR_INFO_10_917;
    
//
// Processor %1, DIMM %2 - NVDIMM Persistency is restored and future data backup is available.
//
typedef struct _evtIML_NVDIMM_PERSIS_RESTORE_INFO_10_918
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_NVDIMM_PERSIS_RESTORE_INFO_10_918, *PEVT_IML_NVDIMM_PERSIS_RESTORE_INFO_10_918;
    
//
// WARNING: Processor %1, DIMM %2 (SN:%3-%4-%5-%6). NVDIMM lifetime has been reached.
//
typedef struct _evtIML_NVDIMM_LIFECYCLE_WARN_10_919
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_LIFECYCLE_WARN_10_919, *PEVT_IML_NVDIMM_LIFECYCLE_WARN_10_919;
    
//
// NVDIMM Configuration Error - Processor %1, DIMM %2 (SN:%3-%4-%5-%6). Backup power is not available to this DIMM slot. NVDIMM is disabled.
//
typedef struct _evtIML_NVDIMM_SLOT_BACKUP_POWER_ERROR_10_920
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrId[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_SLOT_BACKUP_POWER_ERROR_10_920, *PEVT_IML_NVDIMM_SLOT_BACKUP_POWER_ERROR_10_920;
    
//
// INFORMATION: Processor %1, DIMM %2 (SN:%3-%4-%5-%6). Extended Diagnostic Information (Data1 : 0x%7, Data2 : 0x%8, Data3 : 0x%9, Data4 : 0x%10).
//
typedef struct _evtIML_NVDIMM_EXTENDED_DIAGS_INFO_10_921
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD data1;
  DWORD data2;
  DWORD data3;
  DWORD data4;
  char mfrId[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srnum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_EXTENDED_DIAGS_INFO_10_921, *PEVT_IML_NVDIMM_EXTENDED_DIAGS_INFO_10_921;
    
//
// Innovation Engine Error - The Innovation Engine is not operating properly.  (Error Code %1).
//
typedef struct _evtIML_IE_FW_ERR_10_1040
{
  BYTE errorCode;
} EVT_IML_IE_FW_ERR_10_1040, *PEVT_IML_IE_FW_ERR_10_1040;
    
//
// Server Platform Services Firmware Error - The SPS Firmware is not operating properly. (Error Code %1).
//
typedef struct _evtIML_SPS_FW_ERR_10_1044
{
  BYTE errorCode;
} EVT_IML_SPS_FW_ERR_10_1044, *PEVT_IML_SPS_FW_ERR_10_1044;
    
//
// TLS certificate verification error 0x%1 while downloading from %2:%3.
//
typedef struct _evtIML_TLS_CFG_VERIFY_FAILED_10_1056
{
  DWORD errorCode;
  WORD portNumber;
  char targetFqdn[1];
} EVT_IML_TLS_CFG_VERIFY_FAILED_10_1056, *PEVT_IML_TLS_CFG_VERIFY_FAILED_10_1056;
    
//
// Correctable Memory Error Threshold Exceeded (%1 %2, DIMM %3).
//
typedef struct _evtIML_DIMM_CORRECTED_ERROR_THRESHOLD_10_1120
{
  BYTE boardProcessor;
  BYTE deviceNumber;
  BYTE dimmNumber;
  BYTE processorNumber;
} EVT_IML_DIMM_CORRECTED_ERROR_THRESHOLD_10_1120, *PEVT_IML_DIMM_CORRECTED_ERROR_THRESHOLD_10_1120;
    
//
// High rate of corrected memory errors, performance may be degraded (%1 %2, DIMM %3).
//
typedef struct _evtIML_DIMM_CORRECTED_ERROR_RATE_10_1121
{
  BYTE boardProcessor;
  BYTE deviceNumber;
  BYTE dimmNumber;
} EVT_IML_DIMM_CORRECTED_ERROR_RATE_10_1121, *PEVT_IML_DIMM_CORRECTED_ERROR_RATE_10_1121;
    
//
// Mirrored Memory Engaged due to an Uncorrectable Memory Error (%1 %2, DIMM %3).
//
typedef struct _evtIML_DIMM_UNC_MIRROR_ENGAGED_10_1123
{
  BYTE boardProcessor;
  BYTE deviceNumber;
  BYTE dimmNumber;
} EVT_IML_DIMM_UNC_MIRROR_ENGAGED_10_1123, *PEVT_IML_DIMM_UNC_MIRROR_ENGAGED_10_1123;
    
//
// Online Spare Memory Copy Process Started for Faulty Module (%1 %2, DIMM %3).
//
typedef struct _evtIML_DIMM_ONLINE_SPARE_COPY_STARTED_10_1124
{
  BYTE boardProcessor;
  BYTE deviceNumber;
  BYTE dimmNumber;
} EVT_IML_DIMM_ONLINE_SPARE_COPY_STARTED_10_1124, *PEVT_IML_DIMM_ONLINE_SPARE_COPY_STARTED_10_1124;
    
//
// Memory Channel Error - Correctable Memory Error Threshold Exceeded on Processor %1 %2.
//
typedef struct _evtIML_CHANNEL_CORRECTED_ERROR_THRESHOLD_10_1126
{
  BYTE processorNumber;
  char dimmList[1];
} EVT_IML_CHANNEL_CORRECTED_ERROR_THRESHOLD_10_1126, *PEVT_IML_CHANNEL_CORRECTED_ERROR_THRESHOLD_10_1126;
    
//
// Uncorrectable Error was detected on Processor %1.
//
typedef struct _evtIML_PROC_UNC_ERROR_10_1127
{
  BYTE processorNumber;
} EVT_IML_PROC_UNC_ERROR_10_1127, *PEVT_IML_PROC_UNC_ERROR_10_1127;
    
//
// Processor %1, DIMM %2 - NVDIMM-N firmware updated. Current version is %3.
//
typedef struct _evtIML_NVDIMM_FW_UPDATE_SUCCESS_10_1152
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char versionString[1];
} EVT_IML_NVDIMM_FW_UPDATE_SUCCESS_10_1152, *PEVT_IML_NVDIMM_FW_UPDATE_SUCCESS_10_1152;
    
//
// NVDIMM Error - Firmware Update Error - Processor %1, DIMM %2 (SN:%3-%4-%5-%6). NVDIMM-N firmware was not updated. Current version is %7.
//
typedef struct _evtIML_NVDIMM_FW_UPDATE_ERROR_10_1153
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrId[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char versionString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_FW_UPDATE_ERROR_10_1153, *PEVT_IML_NVDIMM_FW_UPDATE_ERROR_10_1153;
    
//
// NVDIMM Error - Invalid Firmware Image Detected - Processor %1, DIMM %2 (SN:%3-%4-%5-%6). NVDIMM-N switching to backup image. Current version is %7.
//
typedef struct _evtIML_NVDIMM_FW_IMAGE_INVALID_10_1154
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrId[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char versionString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_FW_IMAGE_INVALID_10_1154, *PEVT_IML_NVDIMM_FW_IMAGE_INVALID_10_1154;
    
//
// Core Boost Technology missing required %1 license.
//
typedef struct _evtIML_IPT_CORE_BOOST_MISSING_ILO_LICENSE_10_1329
{
  char bmcBranding[1];
} EVT_IML_IPT_CORE_BOOST_MISSING_ILO_LICENSE_10_1329, *PEVT_IML_IPT_CORE_BOOST_MISSING_ILO_LICENSE_10_1329;
    
//
// Box %1, Bay %2 - NVMe firmware updated successfully.
//
typedef struct _evtIML_NVME_FW_UPDATE_SUCCESS_10_1360
{
  BYTE boxNumber;
  BYTE bayNumber;
} EVT_IML_NVME_FW_UPDATE_SUCCESS_10_1360, *PEVT_IML_NVME_FW_UPDATE_SUCCESS_10_1360;
    
//
// Firmware Update Error - Box %1, Bay %2 - NVMe firmware was not updated. Current version is %3.
//
typedef struct _evtIML_NVME_FW_UPDATE_ERROR_10_1361
{
  BYTE boxNumber;
  BYTE bayNumber;
  char versionString[1];
} EVT_IML_NVME_FW_UPDATE_ERROR_10_1361, *PEVT_IML_NVME_FW_UPDATE_ERROR_10_1361;
    
//
// Processor %1, DIMM %2 (SN: %3) - Intel Optane PMem for HPE Module firmware updated from version %4 to version %5.
//
typedef struct _evtIML_AEP_FW_UPDATE_SUCCESS_10_1362
{
  BYTE processNumber;
  BYTE dimmNumber;
  char oldVersion[1];
  //char newVersion[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char serialNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_AEP_FW_UPDATE_SUCCESS_10_1362, *PEVT_IML_AEP_FW_UPDATE_SUCCESS_10_1362;
    
//
// Firmware Update Error - Processor %1, DIMM %2 (SN: %3) - Intel Optane PMem for HPE Module firmware was not updated. Current version is %4.
//
typedef struct _evtIML_AEP_FW_UPDATE_ERROR_10_1363
{
  BYTE processNumber;
  BYTE dimmNumber;
  char versionString[1];
  //char serialNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_AEP_FW_UPDATE_ERROR_10_1363, *PEVT_IML_AEP_FW_UPDATE_ERROR_10_1363;
    
//
// %1 firmware updated from version %2 to version %3.
//
typedef struct _evtIML_DEVICE_FW_UPDATE_SUCCESS_10_1364
{
  BYTE deviceType;
  char oldVersion[1];
  //char newVersion[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_DEVICE_FW_UPDATE_SUCCESS_10_1364, *PEVT_IML_DEVICE_FW_UPDATE_SUCCESS_10_1364;
    
//
// Firmware Update Error - Trusted Platform Module firmware not updated. Current version is %1.
//
typedef struct _evtIML_TPM_FW_UPDATE_ERROR_10_1365
{
  char versionString[1];
} EVT_IML_TPM_FW_UPDATE_ERROR_10_1365, *PEVT_IML_TPM_FW_UPDATE_ERROR_10_1365;
    
//
// %1 %2 - PCIe device firmware updated successfully.
//
typedef struct _evtIML_PCIE_FW_UPDATE_SUCCESS_10_1368
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_PCIE_FW_UPDATE_SUCCESS_10_1368, *PEVT_IML_PCIE_FW_UPDATE_SUCCESS_10_1368;
    
//
// Firmware Update Error - %1 %2 - PCIe device firmware was not updated. Current version is %3.
//
typedef struct _evtIML_PCIE_FW_UPDATE_ERROR_10_1369
{
  BYTE deviceType;
  BYTE slotNumber;
  char versionString[1];
} EVT_IML_PCIE_FW_UPDATE_ERROR_10_1369, *PEVT_IML_PCIE_FW_UPDATE_ERROR_10_1369;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1 DIMM %2 (SN: %3) failed to apply the goal configuration due to Firmware Error Code 0x%4
//
typedef struct _evtIML_AEP_GOAL_CONFIG_FIRMWARE_ERRORS_10_1397
{
  BYTE procNum;
  BYTE dimmNum;
  WORD firmwareErrorCode;
  char serialNum[1];
} EVT_IML_AEP_GOAL_CONFIG_FIRMWARE_ERRORS_10_1397, *PEVT_IML_AEP_GOAL_CONFIG_FIRMWARE_ERRORS_10_1397;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1 DIMM %2 (SN: %3) failed to apply the goal configuration due to missing DIMM(s) or DIMM Configuration Errors.
//
typedef struct _evtIML_AEP_GOAL_CONFIG_DIMM_NOT_FOUND_ERRORS_10_1398
{
  BYTE procNum;
  BYTE dimmNum;
  char serialNum[1];
} EVT_IML_AEP_GOAL_CONFIG_DIMM_NOT_FOUND_ERRORS_10_1398, *PEVT_IML_AEP_GOAL_CONFIG_DIMM_NOT_FOUND_ERRORS_10_1398;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1 DIMM %2 (SN: %3) failed to apply the goal configuration due to insufficient Memory Resources.
//
typedef struct _evtIML_AEP_GOAL_CONFIG_MEMORY_REQUEST_ERRORS_10_1399
{
  BYTE procNum;
  BYTE dimmNum;
  char serialNum[1];
} EVT_IML_AEP_GOAL_CONFIG_MEMORY_REQUEST_ERRORS_10_1399, *PEVT_IML_AEP_GOAL_CONFIG_MEMORY_REQUEST_ERRORS_10_1399;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1 DIMM %2 (SN: %3) failed to apply the goal configuration due to Memory Interleaving Errors.
//
typedef struct _evtIML_AEP_GOAL_CONFIG_INTERLEAVE_ERRORS_10_1400
{
  BYTE procNum;
  BYTE dimmNum;
  char serialNum[1];
} EVT_IML_AEP_GOAL_CONFIG_INTERLEAVE_ERRORS_10_1400, *PEVT_IML_AEP_GOAL_CONFIG_INTERLEAVE_ERRORS_10_1400;
    
//
// Intel Optane PMem for HPE Error - Processor %1 DIMM %2 (SN: %3) - The HPE Memory Module reported a failure on the previous boot (Boot Status Register: 0x%4).
//
typedef struct _evtIML_AEP_BOOT_STATUS_REGISTER_WARNING_10_1401
{
  BYTE processorNumber;
  BYTE dimmNumber;
  QWORD statusDetails;
  char serialNum[1];
} EVT_IML_AEP_BOOT_STATUS_REGISTER_WARNING_10_1401, *PEVT_IML_AEP_BOOT_STATUS_REGISTER_WARNING_10_1401;
    
//
// Persistent Memory Integrity Check initiated on system. This operation can take several minutes.  Status code: 0x%1.
//
typedef struct _evtIML_PMEM_READ_SCAN_10_1409
{
  BYTE statusCode;
} EVT_IML_PMEM_READ_SCAN_10_1409, *PEVT_IML_PMEM_READ_SCAN_10_1409;
    
//
// Firmware Update Error - The system failed a recovery RESTful Firmware Update due to a communication or internal error. The Firmware Update will be aborted.
//
typedef struct _evtIML_ILO_DISCOVERY_FAILED_10_1414
{
  char bmc[1];
} EVT_IML_ILO_DISCOVERY_FAILED_10_1414, *PEVT_IML_ILO_DISCOVERY_FAILED_10_1414;
    
//
// %1 Trusted Platform Module Error.
//
typedef struct _evtIML_TPM_MODULE_ERR_10_5686
{
  char oem[1];
} EVT_IML_TPM_MODULE_ERR_10_5686, *PEVT_IML_TPM_MODULE_ERR_10_5686;
    
//
// %1
//
typedef struct _evtIML_SA_HII_NORMAL_STRING_10_5888
{
  char hiiString[1];
} EVT_IML_SA_HII_NORMAL_STRING_10_5888, *PEVT_IML_SA_HII_NORMAL_STRING_10_5888;
    
//
// %1
//
typedef struct _evtIML_SA_MEM_SELFTEST_ERROR_10_5891
{
  char hiiString[1];
} EVT_IML_SA_MEM_SELFTEST_ERROR_10_5891, *PEVT_IML_SA_MEM_SELFTEST_ERROR_10_5891;
    
//
// %1
//
typedef struct _evtIML_SA_CACHE_BATTERY_REPLACE_10_5893
{
  char hiiString[1];
} EVT_IML_SA_CACHE_BATTERY_REPLACE_10_5893, *PEVT_IML_SA_CACHE_BATTERY_REPLACE_10_5893;
    
//
// %1
//
typedef struct _evtIML_SA_BOOTSTRAP_NV_CHECKSUM_FAIL_10_5895
{
  char hiiString[1];
} EVT_IML_SA_BOOTSTRAP_NV_CHECKSUM_FAIL_10_5895, *PEVT_IML_SA_BOOTSTRAP_NV_CHECKSUM_FAIL_10_5895;
    
//
// %1
//
typedef struct _evtIML_SA_BOOTSTRAP_NV_RESTORED_10_5896
{
  char hiiString[1];
} EVT_IML_SA_BOOTSTRAP_NV_RESTORED_10_5896, *PEVT_IML_SA_BOOTSTRAP_NV_RESTORED_10_5896;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_NOT_HP_DRIVE_10_5897
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_NOT_HP_DRIVE_10_5897, *PEVT_IML_SA_DRIVE_NOT_HP_DRIVE_10_5897;
    
//
// %1
//
typedef struct _evtIML_SA_STRIPE_SIZE_TOO_LARGE_RAID56_10_5905
{
  char hiiString[1];
} EVT_IML_SA_STRIPE_SIZE_TOO_LARGE_RAID56_10_5905, *PEVT_IML_SA_STRIPE_SIZE_TOO_LARGE_RAID56_10_5905;
    
//
// %1
//
typedef struct _evtIML_SA_RED_REPROG_FAIL_10_5907
{
  char hiiString[1];
} EVT_IML_SA_RED_REPROG_FAIL_10_5907, *PEVT_IML_SA_RED_REPROG_FAIL_10_5907;
    
//
// %1
//
typedef struct _evtIML_SA_RED_CHECKSUM_ERROR_10_5908
{
  char hiiString[1];
} EVT_IML_SA_RED_CHECKSUM_ERROR_10_5908, *PEVT_IML_SA_RED_CHECKSUM_ERROR_10_5908;
    
//
// %1
//
typedef struct _evtIML_SA_MEM_ERROR_10_5909
{
  char hiiString[1];
} EVT_IML_SA_MEM_ERROR_10_5909, *PEVT_IML_SA_MEM_ERROR_10_5909;
    
//
// %1
//
typedef struct _evtIML_SA_UC_MEDIA_ERROR_10_5910
{
  char hiiString[1];
} EVT_IML_SA_UC_MEDIA_ERROR_10_5910, *PEVT_IML_SA_UC_MEDIA_ERROR_10_5910;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_OVERHEAT_10_5911
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_OVERHEAT_10_5911, *PEVT_IML_SA_DRIVE_OVERHEAT_10_5911;
    
//
// %1
//
typedef struct _evtIML_SA_SOME_DRIVE_IGNORED_10_5912
{
  char hiiString[1];
} EVT_IML_SA_SOME_DRIVE_IGNORED_10_5912, *PEVT_IML_SA_SOME_DRIVE_IGNORED_10_5912;
    
//
// %1
//
typedef struct _evtIML_SA_CONTROLLER_FAIL_10_5913
{
  char hiiString[1];
} EVT_IML_SA_CONTROLLER_FAIL_10_5913, *PEVT_IML_SA_CONTROLLER_FAIL_10_5913;
    
//
// %1
//
typedef struct _evtIML_SA_SMART_DETECT_FAILURE_10_5920
{
  char hiiString[1];
} EVT_IML_SA_SMART_DETECT_FAILURE_10_5920, *PEVT_IML_SA_SMART_DETECT_FAILURE_10_5920;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_POS_CHANGE_10_5924
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_POS_CHANGE_10_5924, *PEVT_IML_SA_DRIVE_POS_CHANGE_10_5924;
    
//
// %1
//
typedef struct _evtIML_SA_CACHE_SIZE_OR_BATT_CHANGE_10_5926
{
  char hiiString[1];
} EVT_IML_SA_CACHE_SIZE_OR_BATT_CHANGE_10_5926, *PEVT_IML_SA_CACHE_SIZE_OR_BATT_CHANGE_10_5926;
    
//
// %1
//
typedef struct _evtIML_SA_NEW_DRIVE_10_5927
{
  char hiiString[1];
} EVT_IML_SA_NEW_DRIVE_10_5927, *PEVT_IML_SA_NEW_DRIVE_10_5927;
    
//
// %1
//
typedef struct _evtIML_SA_SHUTDOWN_WB_CACHE_ENABLED_10_5928
{
  char hiiString[1];
} EVT_IML_SA_SHUTDOWN_WB_CACHE_ENABLED_10_5928, *PEVT_IML_SA_SHUTDOWN_WB_CACHE_ENABLED_10_5928;
    
//
// %1
//
typedef struct _evtIML_SA_OPTIMAL_SCAN_10_5929
{
  char hiiString[1];
} EVT_IML_SA_OPTIMAL_SCAN_10_5929, *PEVT_IML_SA_OPTIMAL_SCAN_10_5929;
    
//
// %1
//
typedef struct _evtIML_SA_ENC_FW_UPGRADE_ERROR_10_5939
{
  char hiiString[1];
} EVT_IML_SA_ENC_FW_UPGRADE_ERROR_10_5939, *PEVT_IML_SA_ENC_FW_UPGRADE_ERROR_10_5939;
    
//
// %1
//
typedef struct _evtIML_SA_ENC_PATH_CONFIG_ERROR_10_5941
{
  char hiiString[1];
} EVT_IML_SA_ENC_PATH_CONFIG_ERROR_10_5941, *PEVT_IML_SA_ENC_PATH_CONFIG_ERROR_10_5941;
    
//
// %1
//
typedef struct _evtIML_SA_RED_CABLE_EXCEED_10_5943
{
  char hiiString[1];
} EVT_IML_SA_RED_CABLE_EXCEED_10_5943, *PEVT_IML_SA_RED_CABLE_EXCEED_10_5943;
    
//
// %1
//
typedef struct _evtIML_SA_ENCL_RED_CABLE_EXCEED_10_5944
{
  char hiiString[1];
} EVT_IML_SA_ENCL_RED_CABLE_EXCEED_10_5944, *PEVT_IML_SA_ENCL_RED_CABLE_EXCEED_10_5944;
    
//
// %1
//
typedef struct _evtIML_SA_RED_CABLE_NOT_RECOMMENDED_10_5945
{
  char hiiString[1];
} EVT_IML_SA_RED_CABLE_NOT_RECOMMENDED_10_5945, *PEVT_IML_SA_RED_CABLE_NOT_RECOMMENDED_10_5945;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ERASE_IN_PROGRESS_10_5956
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ERASE_IN_PROGRESS_10_5956, *PEVT_IML_SA_DRIVE_ERASE_IN_PROGRESS_10_5956;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ERASE_COMPLETED_10_5957
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ERASE_COMPLETED_10_5957, *PEVT_IML_SA_DRIVE_ERASE_COMPLETED_10_5957;
    
//
// %1
//
typedef struct _evtIML_SA_CACHE_FLASH_ERASED_10_5961
{
  char hiiString[1];
} EVT_IML_SA_CACHE_FLASH_ERASED_10_5961, *PEVT_IML_SA_CACHE_FLASH_ERASED_10_5961;
    
//
// %1
//
typedef struct _evtIML_SA_RAID_LV_CONFIG_INVALID_10_5972
{
  char hiiString[1];
} EVT_IML_SA_RAID_LV_CONFIG_INVALID_10_5972, *PEVT_IML_SA_RAID_LV_CONFIG_INVALID_10_5972;
    
//
// %1
//
typedef struct _evtIML_SA_CAPACITY_EXP_TEMP_DIS_10_5988
{
  char hiiString[1];
} EVT_IML_SA_CAPACITY_EXP_TEMP_DIS_10_5988, *PEVT_IML_SA_CAPACITY_EXP_TEMP_DIS_10_5988;
    
//
// %1
//
typedef struct _evtIML_SA_RESUMEING_LD_CAPACITY_10_5992
{
  char hiiString[1];
} EVT_IML_SA_RESUMEING_LD_CAPACITY_10_5992, *PEVT_IML_SA_RESUMEING_LD_CAPACITY_10_5992;
    
//
// %1
//
typedef struct _evtIML_SA_DRVE_DIS_FAIL_EXPAN_10_5993
{
  char hiiString[1];
} EVT_IML_SA_DRVE_DIS_FAIL_EXPAN_10_5993, *PEVT_IML_SA_DRVE_DIS_FAIL_EXPAN_10_5993;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_FW_UPGRADE_RECOMMENDED_10_6000
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_FW_UPGRADE_RECOMMENDED_10_6000, *PEVT_IML_SA_DRIVE_FW_UPGRADE_RECOMMENDED_10_6000;
    
//
// %1
//
typedef struct _evtIML_SA_OBSOLETE_DATA_IN_CACHE_10_6004
{
  char hiiString[1];
} EVT_IML_SA_OBSOLETE_DATA_IN_CACHE_10_6004, *PEVT_IML_SA_OBSOLETE_DATA_IN_CACHE_10_6004;
    
//
// %1
//
typedef struct _evtIML_SA_STOR_ENC_ERROR_10_6007
{
  char hiiString[1];
} EVT_IML_SA_STOR_ENC_ERROR_10_6007, *PEVT_IML_SA_STOR_ENC_ERROR_10_6007;
    
//
// %1
//
typedef struct _evtIML_SA_RESUMING_AUTO_DATA_10_6008
{
  char hiiString[1];
} EVT_IML_SA_RESUMING_AUTO_DATA_10_6008, *PEVT_IML_SA_RESUMING_AUTO_DATA_10_6008;
    
//
// %1
//
typedef struct _evtIML_SA_RP_DRIVE_DETECTED_10_6009
{
  char hiiString[1];
} EVT_IML_SA_RP_DRIVE_DETECTED_10_6009, *PEVT_IML_SA_RP_DRIVE_DETECTED_10_6009;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_CONTROLLER_FAIL_10_6019
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_CONTROLLER_FAIL_10_6019, *PEVT_IML_SA_DRIVE_ARRAY_CONTROLLER_FAIL_10_6019;
    
//
// %1
//
typedef struct _evtIML_SA_LD_FAIL_10_6020
{
  char hiiString[1];
} EVT_IML_SA_LD_FAIL_10_6020, *PEVT_IML_SA_LD_FAIL_10_6020;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_NOT_CONFIG_10_6021
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_NOT_CONFIG_10_6021, *PEVT_IML_SA_DRIVE_ARRAY_NOT_CONFIG_10_6021;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_RECOV_NEEDED_10_6022
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_RECOV_NEEDED_10_6022, *PEVT_IML_SA_DRIVE_ARRAY_RECOV_NEEDED_10_6022;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_DEGRADED_MODE_10_6023
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_DEGRADED_MODE_10_6023, *PEVT_IML_SA_DRIVE_ARRAY_DEGRADED_MODE_10_6023;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_INCORRECT_DRIVE_REPLACEMENT_10_6024
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_INCORRECT_DRIVE_REPLACEMENT_10_6024, *PEVT_IML_SA_DRIVE_ARRAY_INCORRECT_DRIVE_REPLACEMENT_10_6024;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_NOT_RESPONDING_10_6025
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_NOT_RESPONDING_10_6025, *PEVT_IML_SA_DRIVE_ARRAY_NOT_RESPONDING_10_6025;
    
//
// %1
//
typedef struct _evtIML_SA_VALID_DATA_IN_WB_CACHE_10_6034
{
  char hiiString[1];
} EVT_IML_SA_VALID_DATA_IN_WB_CACHE_10_6034, *PEVT_IML_SA_VALID_DATA_IN_WB_CACHE_10_6034;
    
//
// %1
//
typedef struct _evtIML_SA_DATA_IN_WB_CACHE_LOST_10_6035
{
  char hiiString[1];
} EVT_IML_SA_DATA_IN_WB_CACHE_LOST_10_6035, *PEVT_IML_SA_DATA_IN_WB_CACHE_LOST_10_6035;
    
//
// %1
//
typedef struct _evtIML_SA_CACHE_BATT_CHARGING_10_6036
{
  char hiiString[1];
} EVT_IML_SA_CACHE_BATT_CHARGING_10_6036, *PEVT_IML_SA_CACHE_BATT_CHARGING_10_6036;
    
//
// %1
//
typedef struct _evtIML_SA_WB_CACHE_CONFIG_ERROR_10_6037
{
  char hiiString[1];
} EVT_IML_SA_WB_CACHE_CONFIG_ERROR_10_6037, *PEVT_IML_SA_WB_CACHE_CONFIG_ERROR_10_6037;
    
//
// %1
//
typedef struct _evtIML_SA_CACHE_NOT_RESPONDING_10_6038
{
  char hiiString[1];
} EVT_IML_SA_CACHE_NOT_RESPONDING_10_6038, *PEVT_IML_SA_CACHE_NOT_RESPONDING_10_6038;
    
//
// %1
//
typedef struct _evtIML_SA_WB_CACHE_BACKUP_FAIL_10_6039
{
  char hiiString[1];
} EVT_IML_SA_WB_CACHE_BACKUP_FAIL_10_6039, *PEVT_IML_SA_WB_CACHE_BACKUP_FAIL_10_6039;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_CACHE_SELFTEST_FAIL_10_6040
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_CACHE_SELFTEST_FAIL_10_6040, *PEVT_IML_SA_DRIVE_ARRAY_CACHE_SELFTEST_FAIL_10_6040;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_DRIVE_DIS_WB_CACHE_LOSS_10_6041
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_DRIVE_DIS_WB_CACHE_LOSS_10_6041, *PEVT_IML_SA_DRIVE_ARRAY_DRIVE_DIS_WB_CACHE_LOSS_10_6041;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_DIS_CONTROLLER_10_6148
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_DIS_CONTROLLER_10_6148, *PEVT_IML_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_DIS_CONTROLLER_10_6148;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_SUPER_CAP_NOT_INST_10_6149
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_SUPER_CAP_NOT_INST_10_6149, *PEVT_IML_SA_DRIVE_ARRAY_SUPER_CAP_NOT_INST_10_6149;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_DIS_ACCESS_10_6152
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_DIS_ACCESS_10_6152, *PEVT_IML_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_DIS_ACCESS_10_6152;
    
//
// Slot %1 Encryption Failure - Communication issue prevents drive keys from being retrieved. Encrypted logical drives are offline. System may not boot.
//
typedef struct _evtIML_CRYPTO_COMM_FAIL_10_6153
{
  BYTE slotNumber;
  char bmc[1];
} EVT_IML_CRYPTO_COMM_FAIL_10_6153, *PEVT_IML_CRYPTO_COMM_FAIL_10_6153;
    
//
// Slot %1 Encryption Failure - Master Key is incorrect on or not retrieved from Remote Key Manager. Encrypted logical drives may be offline. System may not boot.
//
typedef struct _evtIML_CRYPTO_MASTER_KEY_FAIL_10_6160
{
  BYTE slotNumber;
} EVT_IML_CRYPTO_MASTER_KEY_FAIL_10_6160, *PEVT_IML_CRYPTO_MASTER_KEY_FAIL_10_6160;
    
//
// Slot %1 Encryption Failure - Drive Keys not retrieved from the Remote Key Manager. Dependent encrypted logical drives are offline. System may not boot.
//
typedef struct _evtIML_CRYPTO_DRIVE_KEY_GET_FAIL_10_6161
{
  BYTE slotNumber;
} EVT_IML_CRYPTO_DRIVE_KEY_GET_FAIL_10_6161, *PEVT_IML_CRYPTO_DRIVE_KEY_GET_FAIL_10_6161;
    
//
// Slot %1 Encryption Failure - Invalid Drive Keys on Remote Key Manager. Encrypted logical drives may be offline. System may not boot.
//
typedef struct _evtIML_CRYPTO_DRIVE_KEY_INVALID_10_6162
{
  BYTE slotNumber;
} EVT_IML_CRYPTO_DRIVE_KEY_INVALID_10_6162, *PEVT_IML_CRYPTO_DRIVE_KEY_INVALID_10_6162;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_CHARGING_FAIL_10_6163
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_CHARGING_FAIL_10_6163, *PEVT_IML_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_CHARGING_FAIL_10_6163;
    
//
// Slot %1 Encryption Failure - Communication issue prevents keys from being retrieved. Dependent encrypted logical drives are offline. System may not boot.
//
typedef struct _evtIML_CYRPTO_COMM_SLOT_FAIL_10_6164
{
  BYTE slotNumber;
} EVT_IML_CYRPTO_COMM_SLOT_FAIL_10_6164, *PEVT_IML_CYRPTO_COMM_SLOT_FAIL_10_6164;
    
//
// %1
//
typedef struct _evtIML_SA_ENCRY_FAIL_LD_OFFLINE_PW_FAIL_10_6165
{
  char hiiString[1];
} EVT_IML_SA_ENCRY_FAIL_LD_OFFLINE_PW_FAIL_10_6165, *PEVT_IML_SA_ENCRY_FAIL_LD_OFFLINE_PW_FAIL_10_6165;
    
//
// %1
//
typedef struct _evtIML_SA_ENCRY_FAIL_LD_NOT_ENCRYPTED_10_6166
{
  char hiiString[1];
} EVT_IML_SA_ENCRY_FAIL_LD_NOT_ENCRYPTED_10_6166, *PEVT_IML_SA_ENCRY_FAIL_LD_NOT_ENCRYPTED_10_6166;
    
//
// %1
//
typedef struct _evtIML_SA_ENCRY_EN_CONTROLLER_MASTER_KEY_NOT_SET_10_6167
{
  char hiiString[1];
} EVT_IML_SA_ENCRY_EN_CONTROLLER_MASTER_KEY_NOT_SET_10_6167, *PEVT_IML_SA_ENCRY_EN_CONTROLLER_MASTER_KEY_NOT_SET_10_6167;
    
//
// %1
//
typedef struct _evtIML_SA_ENCRY_FAIL_KM_MODE_MISMATCH_10_6168
{
  char hiiString[1];
} EVT_IML_SA_ENCRY_FAIL_KM_MODE_MISMATCH_10_6168, *PEVT_IML_SA_ENCRY_FAIL_KM_MODE_MISMATCH_10_6168;
    
//
// %1
//
typedef struct _evtIML_SA_ENCRY_FAIL_UNSUPP_ROM_10_6169
{
  char hiiString[1];
} EVT_IML_SA_ENCRY_FAIL_UNSUPP_ROM_10_6169, *PEVT_IML_SA_ENCRY_FAIL_UNSUPP_ROM_10_6169;
    
//
// %1
//
typedef struct _evtIML_SA_ENCRY_FAIL_ENCRY_LD_OFFLINE_10_6176
{
  char hiiString[1];
} EVT_IML_SA_ENCRY_FAIL_ENCRY_LD_OFFLINE_10_6176, *PEVT_IML_SA_ENCRY_FAIL_ENCRY_LD_OFFLINE_10_6176;
    
//
// %1
//
typedef struct _evtIML_SA_ENCRY_FAIL_FW_VER_NOT_SUPPORT_ENCRY_10_6177
{
  char hiiString[1];
} EVT_IML_SA_ENCRY_FAIL_FW_VER_NOT_SUPPORT_ENCRY_10_6177, *PEVT_IML_SA_ENCRY_FAIL_FW_VER_NOT_SUPPORT_ENCRY_10_6177;
    
//
// Slot %1 Encryption Failure - Imported encrypted logical drives are offline. Matching Local Master Key required. System may not boot.
//
typedef struct _evtIML_CRYPTO_MASTER_KEY_IMPORT_10_6178
{
  BYTE slotNumber;
  char oemStorageBranding[1];
} EVT_IML_CRYPTO_MASTER_KEY_IMPORT_10_6178, *PEVT_IML_CRYPTO_MASTER_KEY_IMPORT_10_6178;
    
//
// %1
//
typedef struct _evtIML_SA_ENCRY_FAIL_UNSUPPOR_ILO_FW_10_6179
{
  char hiiString[1];
} EVT_IML_SA_ENCRY_FAIL_UNSUPPOR_ILO_FW_10_6179, *PEVT_IML_SA_ENCRY_FAIL_UNSUPPOR_ILO_FW_10_6179;
    
//
// %1
//
typedef struct _evtIML_SA_STOR_CABLE_FAIL_DISCOV_10_6180
{
  char hiiString[1];
} EVT_IML_SA_STOR_CABLE_FAIL_DISCOV_10_6180, *PEVT_IML_SA_STOR_CABLE_FAIL_DISCOV_10_6180;
    
//
// %1
//
typedef struct _evtIML_SA_ENCRY_FAIL_NV_CORRUPT_10_6181
{
  char hiiString[1];
} EVT_IML_SA_ENCRY_FAIL_NV_CORRUPT_10_6181, *PEVT_IML_SA_ENCRY_FAIL_NV_CORRUPT_10_6181;
    
//
// %1
//
typedef struct _evtIML_SA_ENCRY_FAIL_ENCRY_ENG_FAIL_10_6182
{
  char hiiString[1];
} EVT_IML_SA_ENCRY_FAIL_ENCRY_ENG_FAIL_10_6182, *PEVT_IML_SA_ENCRY_FAIL_ENCRY_ENG_FAIL_10_6182;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_ARRAY_DATA_IN_WB_LOST_10_6193
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_ARRAY_DATA_IN_WB_LOST_10_6193, *PEVT_IML_SA_DRIVE_ARRAY_DATA_IN_WB_LOST_10_6193;
    
//
// %1
//
typedef struct _evtIML_SA_DRIVE_NOT_EXPOSED_10_6194
{
  char hiiString[1];
} EVT_IML_SA_DRIVE_NOT_EXPOSED_10_6194, *PEVT_IML_SA_DRIVE_NOT_EXPOSED_10_6194;
    
//
// %1
//
typedef struct _evtIML_SA_UNSUPPOR_ARRAY_CONFIG_10_6195
{
  char hiiString[1];
} EVT_IML_SA_UNSUPPOR_ARRAY_CONFIG_10_6195, *PEVT_IML_SA_UNSUPPOR_ARRAY_CONFIG_10_6195;
    
//
// %1
//
typedef struct _evtIML_SA_CTRL_FW_UPDATE_PENDING_10_6196
{
  char hiiString[1];
} EVT_IML_SA_CTRL_FW_UPDATE_PENDING_10_6196, *PEVT_IML_SA_CTRL_FW_UPDATE_PENDING_10_6196;
    
//
// Slot %1 Storage - Controller status changed to Failed. %2
//
typedef struct _evtIML_SA2_DRIVE_ARRAY_CONTROLLER_FAIL_10_6400
{
  char slotNumber[1];
  //char errorString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_DRIVE_ARRAY_CONTROLLER_FAIL_10_6400, *PEVT_IML_SA2_DRIVE_ARRAY_CONTROLLER_FAIL_10_6400;
    
//
// Slot %1 Storage - Controller failed on previous power-up (Error Code 0x%2)
//
typedef struct _evtIML_SA2_CONTROLLER_FAIL_10_6401
{
  char slotNumber[1];
  //char lockCode[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_CONTROLLER_FAIL_10_6401, *PEVT_IML_SA2_CONTROLLER_FAIL_10_6401;
    
//
// Slot %1 Storage - Controller not configured.
//
typedef struct _evtIML_SA2_DRIVE_ARRAY_NOT_CONFIG_10_6402
{
  char slotNumber[1];
} EVT_IML_SA2_DRIVE_ARRAY_NOT_CONFIG_10_6402, *PEVT_IML_SA2_DRIVE_ARRAY_NOT_CONFIG_10_6402;
    
//
// Slot %1 Storage - Controller status changed to Failed. Memory error occurred during self-test.
//
typedef struct _evtIML_SA2_MEM_ERROR_10_6403
{
  char slotNumber[1];
} EVT_IML_SA2_MEM_ERROR_10_6403, *PEVT_IML_SA2_MEM_ERROR_10_6403;
    
//
// Slot %1 Storage - Controller status changed to Degraded. Redundant ROM programming failure.
//
typedef struct _evtIML_SA2_RED_REPROG_FAIL_10_6404
{
  char slotNumber[1];
} EVT_IML_SA2_RED_REPROG_FAIL_10_6404, *PEVT_IML_SA2_RED_REPROG_FAIL_10_6404;
    
//
// Slot %1 Storage - Controller status changed to Degraded. Redundant ROM backup image activated.
//
typedef struct _evtIML_SA2_RED_CHECKSUM_ERROR_10_6405
{
  char slotNumber[1];
} EVT_IML_SA2_RED_CHECKSUM_ERROR_10_6405, *PEVT_IML_SA2_RED_CHECKSUM_ERROR_10_6405;
    
//
// Slot %1 Storage - Last configuration not committed. %2
//
typedef struct _evtIML_SA2_DRIVE_ARRAY_CONFIG_NOT_COMMIT_10_6406
{
  char slotNumber[1];
  //char errorString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_DRIVE_ARRAY_CONFIG_NOT_COMMIT_10_6406, *PEVT_IML_SA2_DRIVE_ARRAY_CONFIG_NOT_COMMIT_10_6406;
    
//
// Slot %1 Storage - Controller status changed to Degraded. %2
//
typedef struct _evtIML_SA2_CONTROLLER_DEGRADED_10_6407
{
  char slotNumber[1];
  //char errorString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_CONTROLLER_DEGRADED_10_6407, *PEVT_IML_SA2_CONTROLLER_DEGRADED_10_6407;
    
//
// Slot %1 Storage - Controller boot password required
//
typedef struct _evtIML_SA2_CONTROLLER_BOOT_PASSWORD_10_6408
{
  char slotNumber[1];
} EVT_IML_SA2_CONTROLLER_BOOT_PASSWORD_10_6408, *PEVT_IML_SA2_CONTROLLER_BOOT_PASSWORD_10_6408;
    
//
// Slot %1 Storage - Drive(s) could not be authenticated as genuine.
//
typedef struct _evtIML_SA2_DRIVE_NOT_HP_DRIVE_10_6416
{
  char slotNumber[1];
} EVT_IML_SA2_DRIVE_NOT_HP_DRIVE_10_6416, *PEVT_IML_SA2_DRIVE_NOT_HP_DRIVE_10_6416;
    
//
// Slot %1 Storage - Drive(s) at %2 status changed to Failed
//
typedef struct _evtIML_SA2_DRIVE_FAIL_10_6417
{
  char slotNumber[1];
  //char driveList[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_DRIVE_FAIL_10_6417, *PEVT_IML_SA2_DRIVE_FAIL_10_6417;
    
//
// Slot %1 Storage - Drive(s) at %2 overheated
//
typedef struct _evtIML_SA2_DRIVE_OVERHEAT_10_6418
{
  char slotNumber[1];
  //char driveList[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_DRIVE_OVERHEAT_10_6418, *PEVT_IML_SA2_DRIVE_OVERHEAT_10_6418;
    
//
// Slot %1 Storage - Drive(s) at %2 status changed to Erasing
//
typedef struct _evtIML_SA2_DRIVE_ERASE_IN_PROGRESS_10_6419
{
  char slotNumber[1];
  //char driveList[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_DRIVE_ERASE_IN_PROGRESS_10_6419, *PEVT_IML_SA2_DRIVE_ERASE_IN_PROGRESS_10_6419;
    
//
// Slot %1 Storage - Drive(s) at %2 status changed to predictive failure
//
typedef struct _evtIML_SA2_SMART_DETECT_FAILURE_10_6420
{
  char slotNumber[1];
  //char driveList[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_SMART_DETECT_FAILURE_10_6420, *PEVT_IML_SA2_SMART_DETECT_FAILURE_10_6420;
    
//
// Slot %1 Storage - Drive media errors could not be recovered by RAID protection
//
typedef struct _evtIML_SA2_DRIVE_MEDIA_ERROR_10_6421
{
  char slotNumber[1];
} EVT_IML_SA2_DRIVE_MEDIA_ERROR_10_6421, *PEVT_IML_SA2_DRIVE_MEDIA_ERROR_10_6421;
    
//
// Slot %1 Storage - Enclosure at %2 status changed to Degraded. %3
//
typedef struct _evtIML_SA2_STOR_ENC_ERROR_10_6432
{
  char slotNumber[1];
  //char encList[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char errorString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_STOR_ENC_ERROR_10_6432, *PEVT_IML_SA2_STOR_ENC_ERROR_10_6432;
    
//
// Slot %1 Storage - Enclosure at %2 status changed to Degraded. %3
//
typedef struct _evtIML_SA2_ENC_FW_UPGRADE_ERROR_10_6433
{
  char slotNumber[1];
  //char encList[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char errorString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_ENC_FW_UPGRADE_ERROR_10_6433, *PEVT_IML_SA2_ENC_FW_UPGRADE_ERROR_10_6433;
    
//
// Slot %1 Storage - More devices attached than this controller supports.
//
typedef struct _evtIML_SA2_SOME_DRIVE_IGNORED_10_6434
{
  char slotNumber[1];
} EVT_IML_SA2_SOME_DRIVE_IGNORED_10_6434, *PEVT_IML_SA2_SOME_DRIVE_IGNORED_10_6434;
    
//
// Slot %1 Storage - Link errors at %2 detected
//
typedef struct _evtIML_SA2_CONTROLLER_LINK_ERROR_10_6435
{
  char slotNumber[1];
  //char devicePath[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_CONTROLLER_LINK_ERROR_10_6435, *PEVT_IML_SA2_CONTROLLER_LINK_ERROR_10_6435;
    
//
// Slot %1 Storage - Controller write cache data is valid and will automatically be written to the volume(s).
//
typedef struct _evtIML_SA2_VALID_DATA_IN_WB_CACHE_10_6448
{
  char slotNumber[1];
} EVT_IML_SA2_VALID_DATA_IN_WB_CACHE_10_6448, *PEVT_IML_SA2_VALID_DATA_IN_WB_CACHE_10_6448;
    
//
// Slot %1 Storage - Controller write cache data has been lost
//
typedef struct _evtIML_SA2_DATA_IN_WB_CACHE_LOST_10_6449
{
  char slotNumber[1];
} EVT_IML_SA2_DATA_IN_WB_CACHE_LOST_10_6449, *PEVT_IML_SA2_DATA_IN_WB_CACHE_LOST_10_6449;
    
//
// Slot %1 Storage - Controller write cache status changed to Degraded (Error Code: %2)
//
typedef struct _evtIML_SA2_WB_CACHE_CONFIG_ERROR_10_6450
{
  char slotNumber[1];
  //char errorString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_WB_CACHE_CONFIG_ERROR_10_6450, *PEVT_IML_SA2_WB_CACHE_CONFIG_ERROR_10_6450;
    
//
// Slot %1 Storage - Controller write cache status changed to Degraded (Error Code: Missing Energy Pack)
//
typedef struct _evtIML_SA2_CACHE_BATT_NOT_PRESENT_10_6452
{
  char slotNumber[1];
} EVT_IML_SA2_CACHE_BATT_NOT_PRESENT_10_6452, *PEVT_IML_SA2_CACHE_BATT_NOT_PRESENT_10_6452;
    
//
// Slot %1 Storage - Controller write cache status changed to Temporarily Degraded (Error Code: Energy Pack Charging)
//
typedef struct _evtIML_SA2_CACHE_BATT_CHARGING_10_6453
{
  char slotNumber[1];
} EVT_IML_SA2_CACHE_BATT_CHARGING_10_6453, *PEVT_IML_SA2_CACHE_BATT_CHARGING_10_6453;
    
//
// Slot %1 Storage - Controller status changed to Failed. %2
//
typedef struct _evtIML_SA2_DRIVE_ARRAY_CACHE_SELFTEST_FAIL_10_6454
{
  char slotNumber[1];
  //char errorString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_DRIVE_ARRAY_CACHE_SELFTEST_FAIL_10_6454, *PEVT_IML_SA2_DRIVE_ARRAY_CACHE_SELFTEST_FAIL_10_6454;
    
//
// Slot %1 Storage - Controller write cache status changed to Degraded (Error Code: Missing Controller Backup Power Cable)
//
typedef struct _evtIML_SA2_CACHE_BATT_CABLE_MISSING_10_6455
{
  char slotNumber[1];
} EVT_IML_SA2_CACHE_BATT_CABLE_MISSING_10_6455, *PEVT_IML_SA2_CACHE_BATT_CABLE_MISSING_10_6455;
    
//
// Slot %1 Storage - Volume %2 status changed to failed
//
typedef struct _evtIML_SA2_LD_FAIL_10_6464
{
  char slotNumber[1];
  //char lDList[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_LD_FAIL_10_6464, *PEVT_IML_SA2_LD_FAIL_10_6464;
    
//
// Slot %1 Storage - Volume %2 status changed to missing
//
typedef struct _evtIML_SA2_MISSING_LOGICAL_DRIVE_10_6465
{
  char slotNumber[1];
  //char lDList[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_MISSING_LOGICAL_DRIVE_10_6465, *PEVT_IML_SA2_MISSING_LOGICAL_DRIVE_10_6465;
    
//
// Slot %1 Storage - Drive(s) at %2 are missing from volume
//
typedef struct _evtIML_SA2_DRIVE_ARRAY_NOT_RESPONDING_10_6466
{
  char slotNumber[1];
  //char driveList[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_DRIVE_ARRAY_NOT_RESPONDING_10_6466, *PEVT_IML_SA2_DRIVE_ARRAY_NOT_RESPONDING_10_6466;
    
//
// Slot %1 Storage - Foreign configuration found on drive. Not able to import configuration to the controller.
//
typedef struct _evtIML_SA2_RAID_LV_CONFIG_INVALID_10_6467
{
  char slotNumber[1];
} EVT_IML_SA2_RAID_LV_CONFIG_INVALID_10_6467, *PEVT_IML_SA2_RAID_LV_CONFIG_INVALID_10_6467;
    
//
// Slot %1 Storage - Foreign configuration found on drive. Configuration mis-match between controller and drives.
//
typedef struct _evtIML_SA2_IMPORT_FOREIGN_CONFIG_10_6468
{
  char slotNumber[1];
} EVT_IML_SA2_IMPORT_FOREIGN_CONFIG_10_6468, *PEVT_IML_SA2_IMPORT_FOREIGN_CONFIG_10_6468;
    
//
// Slot %1 Storage - Volume %2 status changed to degraded
//
typedef struct _evtIML_SA2_DEGRADED_LOGICAL_DRIVE_10_6469
{
  char slotNumber[1];
  //char lDList[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_DEGRADED_LOGICAL_DRIVE_10_6469, *PEVT_IML_SA2_DEGRADED_LOGICAL_DRIVE_10_6469;
    
//
// Slot %1 Storage - Volume %2 status changed to disabled. %3
//
typedef struct _evtIML_SA2_DISABLED_LOGICAL_DRIVE_10_6470
{
  char slotNumber[1];
  //char lDList[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char errorString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SA2_DISABLED_LOGICAL_DRIVE_10_6470, *PEVT_IML_SA2_DISABLED_LOGICAL_DRIVE_10_6470;
    
//
// %1
//
typedef struct _evtIML_SLTX_SAN_ERR_LNK_DN_2_10_8448
{
  char hiiString[1];
} EVT_IML_SLTX_SAN_ERR_LNK_DN_2_10_8448, *PEVT_IML_SLTX_SAN_ERR_LNK_DN_2_10_8448;
    
//
// %1
//
typedef struct _evtIML_SLTX_SAN_ERR_FABRIC_LOGIN_FAIL_2_10_8449
{
  char hiiString[1];
} EVT_IML_SLTX_SAN_ERR_FABRIC_LOGIN_FAIL_2_10_8449, *PEVT_IML_SLTX_SAN_ERR_FABRIC_LOGIN_FAIL_2_10_8449;
    
//
// %1
//
typedef struct _evtIML_SLTX_SAN_ERR_NAME_SERVER_LOGIN_FAIL_2_10_8450
{
  char hiiString[1];
} EVT_IML_SLTX_SAN_ERR_NAME_SERVER_LOGIN_FAIL_2_10_8450, *PEVT_IML_SLTX_SAN_ERR_NAME_SERVER_LOGIN_FAIL_2_10_8450;
    
//
// %1
//
typedef struct _evtIML_SLTX_SAN_ERR_NO_TARGET_2_10_8451
{
  char hiiString[1];
} EVT_IML_SLTX_SAN_ERR_NO_TARGET_2_10_8451, *PEVT_IML_SLTX_SAN_ERR_NO_TARGET_2_10_8451;
    
//
// %1
//
typedef struct _evtIML_SLTX_SAN_ERR_ADP_RST_2_10_8452
{
  char hiiString[1];
} EVT_IML_SLTX_SAN_ERR_ADP_RST_2_10_8452, *PEVT_IML_SLTX_SAN_ERR_ADP_RST_2_10_8452;
    
//
// %1
//
typedef struct _evtIML_SLTX_ERR_VPD_NA_2_10_8453
{
  char hiiString[1];
} EVT_IML_SLTX_ERR_VPD_NA_2_10_8453, *PEVT_IML_SLTX_ERR_VPD_NA_2_10_8453;
    
//
// %1
//
typedef struct _evtIML_SLTX_NIC_ERR_2_10_8454
{
  char hiiString[1];
} EVT_IML_SLTX_NIC_ERR_2_10_8454, *PEVT_IML_SLTX_NIC_ERR_2_10_8454;
    
//
// %1
//
typedef struct _evtIML_SLTX_ERR_FW_UPDATE_FAIL_2_10_8455
{
  char hiiString[1];
} EVT_IML_SLTX_ERR_FW_UPDATE_FAIL_2_10_8455, *PEVT_IML_SLTX_ERR_FW_UPDATE_FAIL_2_10_8455;
    
//
// %1
//
typedef struct _evtIML_SLTX_ERR_FW_RECOVERY_FAIL_2_10_8456
{
  char hiiString[1];
} EVT_IML_SLTX_ERR_FW_RECOVERY_FAIL_2_10_8456, *PEVT_IML_SLTX_ERR_FW_RECOVERY_FAIL_2_10_8456;
    
//
// %1
//
typedef struct _evtIML_SLTX_ERR_APPLY_VC_FAIL_2_10_8457
{
  char hiiString[1];
} EVT_IML_SLTX_ERR_APPLY_VC_FAIL_2_10_8457, *PEVT_IML_SLTX_ERR_APPLY_VC_FAIL_2_10_8457;
    
//
// %1
//
typedef struct _evtIML_SLTX_ERR_CONTROLLER_IO_TO_2_10_8464
{
  char hiiString[1];
} EVT_IML_SLTX_ERR_CONTROLLER_IO_TO_2_10_8464, *PEVT_IML_SLTX_ERR_CONTROLLER_IO_TO_2_10_8464;
    
//
// %1
//
typedef struct _evtIML_SLTX_SCSI_ERR_ACQ_DHCP_INIT_ADR_10_8465
{
  char hiiString[1];
} EVT_IML_SLTX_SCSI_ERR_ACQ_DHCP_INIT_ADR_10_8465, *PEVT_IML_SLTX_SCSI_ERR_ACQ_DHCP_INIT_ADR_10_8465;
    
//
// %1
//
typedef struct _evtIML_SLTX_SCSI_ERR_ACQ_DHCP_TARG_ADR_10_8466
{
  char hiiString[1];
} EVT_IML_SLTX_SCSI_ERR_ACQ_DHCP_TARG_ADR_10_8466, *PEVT_IML_SLTX_SCSI_ERR_ACQ_DHCP_TARG_ADR_10_8466;
    
//
// %1
//
typedef struct _evtIML_SLTX_SCSI_ERR_ACQ_DHCP_ISNS_ADR_2_10_8467
{
  char hiiString[1];
} EVT_IML_SLTX_SCSI_ERR_ACQ_DHCP_ISNS_ADR_2_10_8467, *PEVT_IML_SLTX_SCSI_ERR_ACQ_DHCP_ISNS_ADR_2_10_8467;
    
//
// %1
//
typedef struct _evtIML_ISCSI_ERR_LOGIN_2_10_8468
{
  char hiiString[1];
} EVT_IML_ISCSI_ERR_LOGIN_2_10_8468, *PEVT_IML_ISCSI_ERR_LOGIN_2_10_8468;
    
//
// %1
//
typedef struct _evtIML_ISCSI_ERR_BOOT_LUN_2_10_8469
{
  char hiiString[1];
} EVT_IML_ISCSI_ERR_BOOT_LUN_2_10_8469, *PEVT_IML_ISCSI_ERR_BOOT_LUN_2_10_8469;
    
//
// %1
//
typedef struct _evtIML_ISCSI_ERR_FW_NOT_RE_RDY_2_10_8470
{
  char hiiString[1];
} EVT_IML_ISCSI_ERR_FW_NOT_RE_RDY_2_10_8470, *PEVT_IML_ISCSI_ERR_FW_NOT_RE_RDY_2_10_8470;
    
//
// %1
//
typedef struct _evtIML_SLTX_MODULE_ERROR_2_10_8473
{
  char hiiString[1];
} EVT_IML_SLTX_MODULE_ERROR_2_10_8473, *PEVT_IML_SLTX_MODULE_ERROR_2_10_8473;
    
//
// %1
//
typedef struct _evtIML_SLTX_NVM_OLD_2_10_8480
{
  char hiiString[1];
} EVT_IML_SLTX_NVM_OLD_2_10_8480, *PEVT_IML_SLTX_NVM_OLD_2_10_8480;
    
//
// %1
//
typedef struct _evtIML_SLTX_NVM_NEW_2_10_8481
{
  char hiiString[1];
} EVT_IML_SLTX_NVM_NEW_2_10_8481, *PEVT_IML_SLTX_NVM_NEW_2_10_8481;
    
//
// %1
//
typedef struct _evtIML_SLTX_NVM_NEW_STOP_2_10_8482
{
  char hiiString[1];
} EVT_IML_SLTX_NVM_NEW_STOP_2_10_8482, *PEVT_IML_SLTX_NVM_NEW_STOP_2_10_8482;
    
//
// Corrected Memory Error (%1 %2, DIMM %3, Address 0x%4'%5, Count %6)
//
typedef struct _evtIML_DIMM_CORRECTED_ERROR_10_8528
{
  BYTE boardProcessor;
  BYTE deviceNumber;
  BYTE dimmNumber;
  DWORD address1;
  DWORD address2;
  BYTE errorCount;
} EVT_IML_DIMM_CORRECTED_ERROR_10_8528, *PEVT_IML_DIMM_CORRECTED_ERROR_10_8528;
    
//
// %1 Debug Certificate Detected
//
typedef struct _evtIML_ILO_TEST_CERT_FOUND_10_8992
{
  char bmcBranding[1];
} EVT_IML_ILO_TEST_CERT_FOUND_10_8992, *PEVT_IML_ILO_TEST_CERT_FOUND_10_8992;
    
//
// %1 %2 SAN Error - SAN link is down. SAN connection not possible.
//
typedef struct _evtIML_SLTX_SAN_ERR_LNK_DN_10_9216
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_SAN_ERR_LNK_DN_10_9216, *PEVT_IML_SLTX_SAN_ERR_LNK_DN_10_9216;
    
//
// %1 %2 SAN Error - Fabric Login (FLOGI) failed. SAN connection not possible.
//
typedef struct _evtIML_SLTX_SAN_ERR_FABRIC_LOGIN_FAIL_10_9217
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_SAN_ERR_FABRIC_LOGIN_FAIL_10_9217, *PEVT_IML_SLTX_SAN_ERR_FABRIC_LOGIN_FAIL_10_9217;
    
//
// %1 %2 SAN Error - Name Server login failed. Boot from SAN not possible.
//
typedef struct _evtIML_SLTX_SAN_ERR_NAME_SERVER_LOGIN_FAIL_10_9218
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_SAN_ERR_NAME_SERVER_LOGIN_FAIL_10_9218, *PEVT_IML_SLTX_SAN_ERR_NAME_SERVER_LOGIN_FAIL_10_9218;
    
//
// %1 %2 SAN Error - No targets found. Boot from SAN not possible.
//
typedef struct _evtIML_SLTX_SAN_ERR_NO_TARGET_10_9219
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_SAN_ERR_NO_TARGET_10_9219, *PEVT_IML_SLTX_SAN_ERR_NO_TARGET_10_9219;
    
//
// %1 %2 SAN Error - Adapter restart failed. Firmware not ready. Boot from SAN not possible.
//
typedef struct _evtIML_SLTX_SAN_ERR_ADP_RST_10_9220
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_SAN_ERR_ADP_RST_10_9220, *PEVT_IML_SLTX_SAN_ERR_ADP_RST_10_9220;
    
//
// %1 %2 Error - Vital Product Data (VPD) is not available.
//
typedef struct _evtIML_SLTX_ERR_VPD_NA_10_9221
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_ERR_VPD_NA_10_9221, *PEVT_IML_SLTX_ERR_VPD_NA_10_9221;
    
//
// %1 %2 NIC Error - NIC personality (Ethernet, iSCSI, or FCoE) could not be changed. FW may require update.
//
typedef struct _evtIML_SLTX_NIC_ERR_10_9222
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_NIC_ERR_10_9222, *PEVT_IML_SLTX_NIC_ERR_10_9222;
    
//
// %1 %2 Error - The firmware update did not complete successfully.
//
typedef struct _evtIML_SLTX_ERR_FW_UPDATE_FAIL_10_9223
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_ERR_FW_UPDATE_FAIL_10_9223, *PEVT_IML_SLTX_ERR_FW_UPDATE_FAIL_10_9223;
    
//
//  %1 %2 Error - Firmware image recovery not successful.
//
typedef struct _evtIML_SLTX_ERR_FW_RECOVERY_FAIL_10_9224
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_ERR_FW_RECOVERY_FAIL_10_9224, *PEVT_IML_SLTX_ERR_FW_RECOVERY_FAIL_10_9224;
    
//
// %1 %2 Error - Failure to apply Virtual Connect (VC) settings.
//
typedef struct _evtIML_SLTX_ERR_APPLY_VC_FAIL_10_9225
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_ERR_APPLY_VC_FAIL_10_9225, *PEVT_IML_SLTX_ERR_APPLY_VC_FAIL_10_9225;
    
//
// %1 %2 Error - Controller I/O timeout failure.
//
typedef struct _evtIML_SLTX_ERR_CONTROLLER_IO_TO_10_9232
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_ERR_CONTROLLER_IO_TO_10_9232, *PEVT_IML_SLTX_ERR_CONTROLLER_IO_TO_10_9232;
    
//
// %1 %2 iSCSI Error - Failed to acquire DHCP initiator network address.
//
typedef struct _evtIML_ISCSI_ERR_CLIENT_10_9233
{
  BYTE deviceType;
  BYTE deviceNumber;
} EVT_IML_ISCSI_ERR_CLIENT_10_9233, *PEVT_IML_ISCSI_ERR_CLIENT_10_9233;
    
//
// %1 %2 iSCSI Error - Failed to acquire DHCP target network address.
//
typedef struct _evtIML_ISCSI_ERR_TARGET_10_9234
{
  BYTE deviceType;
  BYTE deviceNumber;
} EVT_IML_ISCSI_ERR_TARGET_10_9234, *PEVT_IML_ISCSI_ERR_TARGET_10_9234;
    
//
// %1 %2 iSCSI Error - Failed to acquire DHCP iSNS Server IP address.
//
typedef struct _evtIML_SLTX_SCSI_ERR_ACQ_DHCP_ISNS_ADR_10_9235
{
  BYTE deviceType;
  BYTE deviceNumber;
} EVT_IML_SLTX_SCSI_ERR_ACQ_DHCP_ISNS_ADR_10_9235, *PEVT_IML_SLTX_SCSI_ERR_ACQ_DHCP_ISNS_ADR_10_9235;
    
//
// %1 %2 iSCSI Error - iSCSI login failed.
//
typedef struct _evtIML_ISCSI_ERR_LOGIN_10_9236
{
  BYTE deviceType;
  BYTE deviceNumber;
} EVT_IML_ISCSI_ERR_LOGIN_10_9236, *PEVT_IML_ISCSI_ERR_LOGIN_10_9236;
    
//
// %1 %2 iSCSI Error - Boot LUN not available.
//
typedef struct _evtIML_ISCSI_ERR_BOOT_LUN_10_9237
{
  BYTE deviceType;
  BYTE deviceNumber;
} EVT_IML_ISCSI_ERR_BOOT_LUN_10_9237, *PEVT_IML_ISCSI_ERR_BOOT_LUN_10_9237;
    
//
// %1 %2 Error - Controller firmware not ready.
//
typedef struct _evtIML_ISCSI_ERR_FW_NOT_RE_RDY_10_9238
{
  BYTE deviceType;
  BYTE deviceNumber;
} EVT_IML_ISCSI_ERR_FW_NOT_RE_RDY_10_9238, *PEVT_IML_ISCSI_ERR_FW_NOT_RE_RDY_10_9238;
    
//
// %1 %2 Error - Rx/Tx is disabled on this device because an unsupported SFP+ or QSFP module type was detected.
//
typedef struct _evtIML_SLTX_MODULE_ERROR_10_9241
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_MODULE_ERROR_10_9241, *PEVT_IML_SLTX_MODULE_ERROR_10_9241;
    
//
// %1 %2 Error - The UEFI driver for the device detected an older version of the NVM image than expected.
//
typedef struct _evtIML_SLTX_NVM_OLD_10_9248
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_NVM_OLD_10_9248, *PEVT_IML_SLTX_NVM_OLD_10_9248;
    
//
// %1 %2 Error - The UEFI driver for the device detected a newer version of the NVM image than expected.
//
typedef struct _evtIML_SLTX_NVM_NEW_10_9249
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_NVM_NEW_10_9249, *PEVT_IML_SLTX_NVM_NEW_10_9249;
    
//
// %1 %2 Error - The UEFI driver for the device stopped because the NVM image is newer than expected.
//
typedef struct _evtIML_SLTX_NVM_NEW_STOP_10_9250
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_NVM_NEW_STOP_10_9250, *PEVT_IML_SLTX_NVM_NEW_STOP_10_9250;
    
//
// %1 %2 Error - Firmware recovery mode detected. Initialization failed.
//
typedef struct _evtIML_SLTX_FW_RECOVERY_MODE_10_9251
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_FW_RECOVERY_MODE_10_9251, *PEVT_IML_SLTX_FW_RECOVERY_MODE_10_9251;
    
//
// %1 %2 Error - Critical firmware data has been corrupted.
//
typedef struct _evtIML_SLTX_CRITICAL_DATA_CORRUPTED_10_9252
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_CRITICAL_DATA_CORRUPTED_10_9252, *PEVT_IML_SLTX_CRITICAL_DATA_CORRUPTED_10_9252;
    
//
// %1 %2 Error - Topology Media conflict in Ethernet port configuration detected.
//
typedef struct _evtIML_SLTX_TOPOLOGY_MEDIA_CONFLICT_10_9253
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_SLTX_TOPOLOGY_MEDIA_CONFLICT_10_9253, *PEVT_IML_SLTX_TOPOLOGY_MEDIA_CONFLICT_10_9253;
    
//
// %1 %2 Error - Device firmware has been reverted to version %3. Device may exhibit limited functionality. Refer to Device User Guide for more information.
//
typedef struct _evtIML_SLTX_FW_ROLLBACK_MODE_10_9254
{
  BYTE deviceType;
  BYTE slotNumber;
  char fwVersion[1];
} EVT_IML_SLTX_FW_ROLLBACK_MODE_10_9254, *PEVT_IML_SLTX_FW_ROLLBACK_MODE_10_9254;
    
//
// Server Configuration Lock has detected a discrepancy with the NVMe Box %1 Bay %2 Digital Fingerprint.
//
typedef struct _evtIML_SERVER_CONFIG_LOCK_PCI_NVME_MISMATCH_10_12548
{
  BYTE boxNumber;
  BYTE bayNumber;
} EVT_IML_SERVER_CONFIG_LOCK_PCI_NVME_MISMATCH_10_12548, *PEVT_IML_SERVER_CONFIG_LOCK_PCI_NVME_MISMATCH_10_12548;
    
//
// Unsupported PCIe Card Configuration. The PCIe device installed in Slot %1 is not supported in the current location.
//
typedef struct _evtIML_TL_ON_UNSUPPORTED_SLOT_10_12549
{
  BYTE slotNumber;
} EVT_IML_TL_ON_UNSUPPORTED_SLOT_10_12549, *PEVT_IML_TL_ON_UNSUPPORTED_SLOT_10_12549;
    
//
// Server Configuration Lock has detected a discrepancy with the DIMM (%1 %2 DIMM %3) Digital Fingerprint.
//
typedef struct _evtIML_SERVER_CONFIG_LOCK_DIMM_MISMATCH_10_12550
{
  BYTE boardProcessor;
  BYTE deviceNumber;
  BYTE dimmNumber;
} EVT_IML_SERVER_CONFIG_LOCK_DIMM_MISMATCH_10_12550, *PEVT_IML_SERVER_CONFIG_LOCK_DIMM_MISMATCH_10_12550;
    
//
// Server Configuration Lock has detected a discrepancy with the Processor %1 Digital Fingerprint. 
//
typedef struct _evtIML_SERVER_CONFIG_LOCK_CPU_MISMATCH_10_12552
{
  BYTE processorNumber;
} EVT_IML_SERVER_CONFIG_LOCK_CPU_MISMATCH_10_12552, *PEVT_IML_SERVER_CONFIG_LOCK_CPU_MISMATCH_10_12552;
    
//
// Server Configuration Lock has detected a discrepancy with the PCI Device %1 %2 Digital Fingerprint.
//
typedef struct _evtIML_SERVER_CONFIG_LOCK_PCI_SLOT_MISMATCH_10_12553
{
  BYTE slotNumber;
  BYTE deviceType;
} EVT_IML_SERVER_CONFIG_LOCK_PCI_SLOT_MISMATCH_10_12553, *PEVT_IML_SERVER_CONFIG_LOCK_PCI_SLOT_MISMATCH_10_12553;
    
//
// Intel Optane PMem for HPE Health Error - Processor %1 DIMM %2 (SN: %3) - The Persistent Memory Module is approaching the end of its usable wear leveling.
//
typedef struct _evtIML_AEP_CAUTION_HEALTH_STATE_FAILURE_10_12563
{
  BYTE processorNumber;
  BYTE dimmLabel;
  char serialNum[1];
} EVT_IML_AEP_CAUTION_HEALTH_STATE_FAILURE_10_12563, *PEVT_IML_AEP_CAUTION_HEALTH_STATE_FAILURE_10_12563;
    
//
// Intel Optane PMem for HPE Health Error - Processor %1 DIMM %2 (SN: %3) - The Persistent Memory Module has experienced an issue and is no longer resilient.
//
typedef struct _evtIML_AEP_CRITICAL_HEALTH_STATE_FAILURE_10_12565
{
  BYTE processorNumber;
  BYTE dimmLabel;
  BYTE dimmNum;
  char serialNum[1];
} EVT_IML_AEP_CRITICAL_HEALTH_STATE_FAILURE_10_12565, *PEVT_IML_AEP_CRITICAL_HEALTH_STATE_FAILURE_10_12565;
    
//
// Intel Optane PMem for HPE Health Error - Processor %1 DIMM %2 (SN: %3) - The Persistent Memory Module has experienced a critical error and may no longer be operational.
//
typedef struct _evtIML_AEP_FATAL_HEALTH_STATE_FAILURE_10_12566
{
  BYTE processorNumber;
  BYTE dimmLabel;
  BYTE dimmNum;
  char serialNum[1];
} EVT_IML_AEP_FATAL_HEALTH_STATE_FAILURE_10_12566, *PEVT_IML_AEP_FATAL_HEALTH_STATE_FAILURE_10_12566;
    
//
// Intel Optane PMem for HPE Percentage Remaining Alert - Processor %1 DIMM %2 (SN: %3) - The Persistent Memory Module has %4 percent or less of its specified life remaining.
//
typedef struct _evtIML_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_CAUTION_10_12567
{
  BYTE processorNumber;
  BYTE dimmLabel;
  BYTE cautionThreshold;
  char serialNum[1];
} EVT_IML_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_CAUTION_10_12567, *PEVT_IML_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_CAUTION_10_12567;
    
//
// Intel Optane PMem for HPE Percentage Remaining Alert - Processor %1 DIMM %2 (SN: %3) - The Persistent Memory Module has %4 percent or less of its specified life remaining.
//
typedef struct _evtIML_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_WARNING_10_12568
{
  BYTE processorNumber;
  BYTE dimmLabel;
  BYTE warningThreshold;
  char serialNum[1];
} EVT_IML_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_WARNING_10_12568, *PEVT_IML_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_WARNING_10_12568;
    
//
// Intel Optane PMem for HPE Percentage Remaining Alert - Processor %1 DIMM %2 (SN: %3)  - The Persistent Memory Module has %4 percent or less specified life remaining.  Future errors on this PMEM may result in loss of data.
//
typedef struct _evtIML_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_CRITICAL_10_12569
{
  BYTE processorNumber;
  BYTE dimmLabel;
  BYTE criticalThreshold;
  BYTE dimmNum;
  char serialNum[1];
} EVT_IML_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_CRITICAL_10_12569, *PEVT_IML_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_CRITICAL_10_12569;
    
//
// Intel Optane PMem for HPE Health Warning - Processor %1 DIMM %2 (SN: %3) - The Persistent Memory Module reported an unsafe shutdown (Status: 0x%4, Count: %5). A potential loss of data may have occurred.
//
typedef struct _evtIML_AEP_LAST_SHUTDOWN_STATE_WARNING_10_12576
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD statusDetails;
  DWORD shutdownCount;
  char serialNum[1];
} EVT_IML_AEP_LAST_SHUTDOWN_STATE_WARNING_10_12576, *PEVT_IML_AEP_LAST_SHUTDOWN_STATE_WARNING_10_12576;
    
//
// Transaction Timeout Error Detected. %1 %2 (Segment 0x%3, Bus 0x%4, Device 0x%5, Function 0x%6).
//
typedef struct _evtIML_TOR_TIMEOUT_SLOT_ERROR_10_12577
{
  BYTE segmentNumber;
  BYTE busNumber;
  BYTE deviceNumber;
  BYTE functionNumber;
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_TOR_TIMEOUT_SLOT_ERROR_10_12577, *PEVT_IML_TOR_TIMEOUT_SLOT_ERROR_10_12577;
    
//
// Transaction Timeout Error Detected. NVMe Box %1 Bay %2 (Segment 0x%3, Bus 0x%4, Device 0x%5, Function 0x%6).
//
typedef struct _evtIML_TOR_TIMEOUT_NVME_ERROR_10_12583
{
  BYTE segmentNumber;
  BYTE busNumber;
  BYTE deviceNumber;
  BYTE functionNumber;
  BYTE boxNumber;
  BYTE bayNumber;
} EVT_IML_TOR_TIMEOUT_NVME_ERROR_10_12583, *PEVT_IML_TOR_TIMEOUT_NVME_ERROR_10_12583;
    
//
// Intel Optane PMem for HPE %1 Completed Successfully - Processor %2  DIMM %3 (SN : %4)
//
typedef struct _evtIML_AEP_SECURE_ERASE_PASS_10_12598
{
  BYTE processorNumber;
  BYTE dimmLabel;
  BYTE operation;
  char serialNumber[1];
} EVT_IML_AEP_SECURE_ERASE_PASS_10_12598, *PEVT_IML_AEP_SECURE_ERASE_PASS_10_12598;
    
//
// Intel Optane PMem for HPE %1 Failure - Processor %2, DIMM %3  (SN : %4)
//
typedef struct _evtIML_AEP_SECURE_ERASE_FAIL_10_12599
{
  BYTE processorNumber;
  BYTE dimmLabel;
  BYTE dimmNumber;
  BYTE operation;
  char serialNumber[1];
} EVT_IML_AEP_SECURE_ERASE_FAIL_10_12599, *PEVT_IML_AEP_SECURE_ERASE_FAIL_10_12599;
    
//
// Device Encryption Error - Enabling encryption for Processor %1 DIMM %2 (PMEM SN: %3) has failed.
//
typedef struct _evtIML_ENABLE_ENCRYPTION_FOR_DCPMM_FAILED_10_12611
{
  BYTE procNum;
  BYTE dimmLabel;
  BYTE dimmNum;
  char serialNum[1];
} EVT_IML_ENABLE_ENCRYPTION_FOR_DCPMM_FAILED_10_12611, *PEVT_IML_ENABLE_ENCRYPTION_FOR_DCPMM_FAILED_10_12611;
    
//
// Device Encryption Error - Disabling encryption for Processor %1 DIMM %2 (PMEM SN: %3) has failed.
//
typedef struct _evtIML_DISABLE_ENCRYPTION_FOR_DCPMM_FAILED_10_12613
{
  BYTE procNum;
  BYTE dimmLabel;
  BYTE dimmNum;
  char serialNum[1];
} EVT_IML_DISABLE_ENCRYPTION_FOR_DCPMM_FAILED_10_12613, *PEVT_IML_DISABLE_ENCRYPTION_FOR_DCPMM_FAILED_10_12613;
    
//
// Device Encryption Error - Modifying passphrase for Processor %1 DIMM %2 (PMEM SN: %3) failed.
//
typedef struct _evtIML_PASSPHRASE_MODIFICATION_FOR_DCPMM_FAILED_10_12614
{
  BYTE procNum;
  BYTE dimmLabel;
  BYTE dimmNum;
  char serialNum[1];
} EVT_IML_PASSPHRASE_MODIFICATION_FOR_DCPMM_FAILED_10_12614, *PEVT_IML_PASSPHRASE_MODIFICATION_FOR_DCPMM_FAILED_10_12614;
    
//
// Device Encryption Error - Three incorrect attempts were made to unlock Processor %1 DIMM %2 (PMEM SN: %3). The device will be locked until the next power cycle.
//
typedef struct _evtIML_DCPMM_LOCKED_UNTIL_NEXT_BOOT_10_12616
{
  BYTE procNum;
  BYTE dimmLabel;
  BYTE dimmNum;
  char serialNum[1];
} EVT_IML_DCPMM_LOCKED_UNTIL_NEXT_BOOT_10_12616, *PEVT_IML_DCPMM_LOCKED_UNTIL_NEXT_BOOT_10_12616;
    
//
// Encryption for Processor %1 DIMM %2 (PMEM SN: %3) is disabled.
//
typedef struct _evtIML_ENCRYPTION_FOR_DCPMM_DISABLED_10_12619
{
  BYTE procNum;
  BYTE dimmLabel;
  char serialNum[1];
} EVT_IML_ENCRYPTION_FOR_DCPMM_DISABLED_10_12619, *PEVT_IML_ENCRYPTION_FOR_DCPMM_DISABLED_10_12619;
    
//
// Encryption passphrase for Processor %1 DIMM %2 (PMEM SN: %3) was modified.
//
typedef struct _evtIML_ENCRYPTION_PASSPHRASE_MODIFIED_FOR_DCPMM_10_12620
{
  BYTE procNum;
  BYTE dimmLabel;
  char serialNum[1];
} EVT_IML_ENCRYPTION_PASSPHRASE_MODIFIED_FOR_DCPMM_10_12620, *PEVT_IML_ENCRYPTION_PASSPHRASE_MODIFIED_FOR_DCPMM_10_12620;
    
//
// Attempt to unlock Processor %1 DIMM %2 (PMEM SN: %3) was successful.
//
typedef struct _evtIML_ATTEMPTING_UNLOCK_DCPMM_SUCCESS_10_12622
{
  BYTE procNum;
  BYTE dimmLabel;
  char serialNum[1];
} EVT_IML_ATTEMPTING_UNLOCK_DCPMM_SUCCESS_10_12622, *PEVT_IML_ATTEMPTING_UNLOCK_DCPMM_SUCCESS_10_12622;
    
//
// One-button secure erase failure for drive %1 (SN: %2) - %3.
//
typedef struct _evtIML_SATA_ERASE_FAILURE_10_12624
{
  BYTE portIndex;
  BYTE controllerIndex;
  BYTE failureInformation;
  char serialNum[1];
  //char diskPath[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SATA_ERASE_FAILURE_10_12624, *PEVT_IML_SATA_ERASE_FAILURE_10_12624;
    
//
// One-button secure erase of drive at Port %1 Box %2 Bay %3  (SN: %4) has failed.
//
typedef struct _evtIML_SMART_ARRAY_DISK_SECURE_ERASE_FAIL_10_12625
{
  WORD boxNumber;
  BYTE controllerIndex;
  BYTE bayNumber;
  char serialNum[1];
} EVT_IML_SMART_ARRAY_DISK_SECURE_ERASE_FAIL_10_12625, *PEVT_IML_SMART_ARRAY_DISK_SECURE_ERASE_FAIL_10_12625;
    
//
// One-button secure erase failure for %1 (SN: %2) - %3.
//
typedef struct _evtIML_NVMe_ERASE_FAILURE_10_12626
{
  BYTE pCIBusIndex;
  BYTE pCIDeviceIndex;
  BYTE pCIFunctionIndex;
  BYTE failureInformation;
  char diskPath[1];
  //char serialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVMe_ERASE_FAILURE_10_12626, *PEVT_IML_NVMe_ERASE_FAILURE_10_12626;
    
//
// Encryption for Processor %1 DIMM %2 (PMEM SN: %3) is enabled.
//
typedef struct _evtIML_ENCRYPTION_FOR_DCPMM_ENABLED_10_12629
{
  BYTE procNum;
  BYTE dimmLabel;
  char serialNum[1];
} EVT_IML_ENCRYPTION_FOR_DCPMM_ENABLED_10_12629, *PEVT_IML_ENCRYPTION_FOR_DCPMM_ENABLED_10_12629;
    
//
// Intel Optane PMem for HPE Configuration Error - Intel Optane PMem for HPE in Processor %1, DIMM %2 (SN: %3) was configured in Interleaving mode. This PMEM has been disabled because one or more PMEMs in the interleaved set is populated in a different processor. This PMEM was populated in Processor %4, DIMM %5 when the interleaving configuration was successfully applied. 
//
typedef struct _evtIML_AEP_STATUS_SOCKET_INTERLEAVING_NOT_SUPPORTED_10_12630
{
  BYTE processornumber;
  BYTE dimmnumber;
  BYTE processornumberpcd;
  BYTE dimmnumberpcd;
  char serialNum[1];
} EVT_IML_AEP_STATUS_SOCKET_INTERLEAVING_NOT_SUPPORTED_10_12630, *PEVT_IML_AEP_STATUS_SOCKET_INTERLEAVING_NOT_SUPPORTED_10_12630;
    
//
// Intel Optane PMem for HPE Configuration Error - Intel Optane PMem for HPE in Processor %1, DIMM %2 (SN : %3) was configured in interleaving mode. This PMEM has been disabled because one or more PMEMs in the interleaved set is missing. This PMEM was populated in Processor %4, DIMM %5 when the interleaving configuration was successfully applied.
//
typedef struct _evtIML_AEP_STATUS_MISSING_DIMM_IN_INTERLEAVED_SET_10_12631
{
  BYTE processornumber;
  BYTE dimmnumber;
  BYTE processornumberpcd;
  BYTE dimmnumberpcd;
  char serialNum[1];
} EVT_IML_AEP_STATUS_MISSING_DIMM_IN_INTERLEAVED_SET_10_12631, *PEVT_IML_AEP_STATUS_MISSING_DIMM_IN_INTERLEAVED_SET_10_12631;
    
//
// Resetting the configuration for PCI controller :  %1 failed.
//
typedef struct _evtIML_PCICONFIG_RESET_ERASE_FAIL_10_12632
{
  BYTE pciSlotIndex;
  char deviceLocation[1];
} EVT_IML_PCICONFIG_RESET_ERASE_FAIL_10_12632, *PEVT_IML_PCICONFIG_RESET_ERASE_FAIL_10_12632;
    
//
// Intel Optane PMem for HPE Configuration Error - Intel Optane PMem for HPE Processor %1, DIMM %2 (SN: %3) was configured in interleaving mode. This PMEM has been disabled because the order of population of interleaved PMEMs is incorrect. This PMEM was populated in Processor %4, DIMM %5 when the interleaving configuration was successfully applied.
//
typedef struct _evtIML_AEP_STATUS_INTERLEAVED_DIMMS_POPULATED_IN_WRONG_ORDER_10_12633
{
  BYTE processornumber;
  BYTE dimmnumber;
  BYTE processornumberpcd;
  BYTE dimmnumberpcd;
  char serialNum[1];
} EVT_IML_AEP_STATUS_INTERLEAVED_DIMMS_POPULATED_IN_WRONG_ORDER_10_12633, *PEVT_IML_AEP_STATUS_INTERLEAVED_DIMMS_POPULATED_IN_WRONG_ORDER_10_12633;
    
//
// Intel Optane PMem for HPE Configuration Error - Intel Optane PMem for HPE Processor %1, DIMM %2 (SN: %3) was configured in Interleaving mode. This PMEM has been disabled because it has been populated in an incorrect slot which makes interleaving not possible. This PMEM was populated in Processor %4, DIMM %5 when the interleaving configuration was successfully applied.
//
typedef struct _evtIML_AEP_STATUS_CHANNEL_INTERLEAVING_NOT_SUPPORTED_10_12635
{
  BYTE processornumber;
  BYTE dimmnumber;
  BYTE processornumberpcd;
  BYTE dimmnumberpcd;
  char serialNum[1];
} EVT_IML_AEP_STATUS_CHANNEL_INTERLEAVING_NOT_SUPPORTED_10_12635, *PEVT_IML_AEP_STATUS_CHANNEL_INTERLEAVING_NOT_SUPPORTED_10_12635;
    
//
// New Intel Optane PMem for HPE Module is detected on Processor %1, DIMM %2 (SN: %3).
//
typedef struct _evtIML_AEP_STATUS_NEW_DIMM_POPULATED_IN_SYSTEM_10_12636
{
  BYTE processornumber;
  BYTE dimmnumber;
  char serialNum[1];
} EVT_IML_AEP_STATUS_NEW_DIMM_POPULATED_IN_SYSTEM_10_12636, *PEVT_IML_AEP_STATUS_NEW_DIMM_POPULATED_IN_SYSTEM_10_12636;
    
//
// Server Configuration Lock has encountered an unexpected error (code 0x%1). 
//
typedef struct _evtIML_SERVER_CONFIG_LOCK_UNEXPECTED_ERROR_10_12642
{
  BYTE errorCode;
} EVT_IML_SERVER_CONFIG_LOCK_UNEXPECTED_ERROR_10_12642, *PEVT_IML_SERVER_CONFIG_LOCK_UNEXPECTED_ERROR_10_12642;
    
//
// Remote Key Management System (RKMS) connection failed.
//
typedef struct _evtIML_ESKM_CONNECTION_FAILURE_10_12646
{
  char bmcBranding[1];
} EVT_IML_ESKM_CONNECTION_FAILURE_10_12646, *PEVT_IML_ESKM_CONNECTION_FAILURE_10_12646;
    
//
// X64 Exception Type 0x%1 (%2) occurred during the previous boot. Image name: %3
//
typedef struct _evtIML_CPU_X64_EXCEPTION_10_12647
{
  BYTE exceptionType;
  char exceptionTypeStr[1];
  //char imageName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_CPU_X64_EXCEPTION_10_12647, *PEVT_IML_CPU_X64_EXCEPTION_10_12647;
    
//
// Device Encryption Error: Enabling encryption for Self Encrypted Drive (SED) at location : [ %1 ] has failed.
//
typedef struct _evtIML_ENABLE_ENCRYPTION_FOR_OPAL_FAILED_10_12648
{
  char devicePath[1];
} EVT_IML_ENABLE_ENCRYPTION_FOR_OPAL_FAILED_10_12648, *PEVT_IML_ENABLE_ENCRYPTION_FOR_OPAL_FAILED_10_12648;
    
//
// Device Encryption Error: Disabling encryption for Self Encrypted Drive (SED) at location : [ %1 ] has failed.
//
typedef struct _evtIML_DISABLE_ENCRYPTION_FOR_OPAL_FAILED_10_12649
{
  char devicePath[1];
} EVT_IML_DISABLE_ENCRYPTION_FOR_OPAL_FAILED_10_12649, *PEVT_IML_DISABLE_ENCRYPTION_FOR_OPAL_FAILED_10_12649;
    
//
// Device Encryption Error: Modifying passphrase for Self Encrypted Drive (SED) at location : [ %1 ] failed.
//
typedef struct _evtIML_PASSPHRASE_MODIFICATION_FOR_OPAL_FAILED_10_12650
{
  char devicePath[1];
} EVT_IML_PASSPHRASE_MODIFICATION_FOR_OPAL_FAILED_10_12650, *PEVT_IML_PASSPHRASE_MODIFICATION_FOR_OPAL_FAILED_10_12650;
    
//
// Five incorrect attempts were made to unlock Self Encrypted Drive (SED) at location : [ %1 ] . The device will be locked until the next power cycle.
//
typedef struct _evtIML_OPAL_LOCKED_UNTIL_NEXT_BOOT_10_12651
{
  char devicePath[1];
} EVT_IML_OPAL_LOCKED_UNTIL_NEXT_BOOT_10_12651, *PEVT_IML_OPAL_LOCKED_UNTIL_NEXT_BOOT_10_12651;
    
//
// Encryption passphrase for Self Encrypted Drive (SED) at location : [ %1 ] was modified.
//
typedef struct _evtIML_ENCRYPTION_PASSPHRASE_MODIFIED_FOR_OPAL_10_12652
{
  char devicePath[1];
} EVT_IML_ENCRYPTION_PASSPHRASE_MODIFIED_FOR_OPAL_10_12652, *PEVT_IML_ENCRYPTION_PASSPHRASE_MODIFIED_FOR_OPAL_10_12652;
    
//
// Attempting  to unlock Self Encrypted Drive (SED) at location : [ %1 ] was Successful.
//
typedef struct _evtIML_ATTEMPTING_UNLOCK_OPAL_SUCCESS_10_12654
{
  char devicePath[1];
} EVT_IML_ATTEMPTING_UNLOCK_OPAL_SUCCESS_10_12654, *PEVT_IML_ATTEMPTING_UNLOCK_OPAL_SUCCESS_10_12654;
    
//
// Encryption for Self Encrypted Drive (SED) at location :  [ %1 ] is disabled.
//
typedef struct _evtIML_ENCRYPTION_FOR_OPAL_DISABLED_10_12655
{
  char devicePath[1];
} EVT_IML_ENCRYPTION_FOR_OPAL_DISABLED_10_12655, *PEVT_IML_ENCRYPTION_FOR_OPAL_DISABLED_10_12655;
    
//
// Encryption for Self Encrypted Drive (SED) at location :  [ %1 ] is enabled.
//
typedef struct _evtIML_ENCRYPTION_FOR_OPAL_ENABLED_10_12658
{
  char devicePath[1];
} EVT_IML_ENCRYPTION_FOR_OPAL_ENABLED_10_12658, *PEVT_IML_ENCRYPTION_FOR_OPAL_ENABLED_10_12658;
    
//
// Encryption passphrase for Self Encrypted Drive (SED) at location : [ %1 ] was modified.
//
typedef struct _evtSL_SED_PASSPHRASE_MODIFIED_10_12659
{
  char devicePath[1];
} EVT_SL_SED_PASSPHRASE_MODIFIED_10_12659, *PEVT_SL_SED_PASSPHRASE_MODIFIED_10_12659;
    
//
// Encryption for PMEM device : Processor %1 DIMM %2 (SN: %3) is enabled.
//
typedef struct _evtSL_DCPMM_DEVICE_ENCRYPTION_ENABLED_10_12662
{
  BYTE procNum;
  BYTE dimmLabel;
  char serialNum[1];
} EVT_SL_DCPMM_DEVICE_ENCRYPTION_ENABLED_10_12662, *PEVT_SL_DCPMM_DEVICE_ENCRYPTION_ENABLED_10_12662;
    
//
// Encryption for PMEM device : Processor %1 DIMM %2 (SN: %3) is disabled.
//
typedef struct _evtSL_DCPMM_DEVICE_ENCRYPTION_DISABLED_10_12663
{
  BYTE procNum;
  BYTE dimmLabel;
  char serialNum[1];
} EVT_SL_DCPMM_DEVICE_ENCRYPTION_DISABLED_10_12663, *PEVT_SL_DCPMM_DEVICE_ENCRYPTION_DISABLED_10_12663;
    
//
// Encryption passphrase for PMEM device : Processor %1 DIMM %2 (SN: %3) was modified.
//
typedef struct _evtSL_DCPMM_DEVICE_PASSPHRASE_MODIFIED_10_12664
{
  BYTE procNum;
  BYTE dimmLabel;
  char serialNum[1];
} EVT_SL_DCPMM_DEVICE_PASSPHRASE_MODIFIED_10_12664, *PEVT_SL_DCPMM_DEVICE_PASSPHRASE_MODIFIED_10_12664;
    
//
// Attempt to unlock PMEM device : Processor %1 DIMM %2 (SN: %3) was successful.
//
typedef struct _evtSL_DCPMM_DEVICE_UNLOCKED_10_12665
{
  BYTE procNum;
  BYTE dimmLabel;
  char serialNum[1];
} EVT_SL_DCPMM_DEVICE_UNLOCKED_10_12665, *PEVT_SL_DCPMM_DEVICE_UNLOCKED_10_12665;
    
//
// Three incorrect attempts were made to unlock PMEM device : Processor %1 DIMM %2 (SN: %3). The device will be locked until the next reboot.
//
typedef struct _evtSL_DCPMM_UNLOCK_EXCESSIVE_FAILURES_10_12666
{
  BYTE procNum;
  BYTE dimmLabel;
  BYTE dimmNum;
  char serialNum[1];
} EVT_SL_DCPMM_UNLOCK_EXCESSIVE_FAILURES_10_12666, *PEVT_SL_DCPMM_UNLOCK_EXCESSIVE_FAILURES_10_12666;
    
//
// %1 Debug Certificate Detected
//
typedef struct _evtSL_SL_ILO_TEST_CERT_DETECTED_10_12685
{
  char bmcBranding[1];
} EVT_SL_SL_ILO_TEST_CERT_DETECTED_10_12685, *PEVT_SL_SL_ILO_TEST_CERT_DETECTED_10_12685;
    
//
// PMM Error - Processor %1, DIMM %2.  PMM will experience or has already experienced an overflow of uncorrectable errors.  Loss of persistency imminent.  Error Count: %3, Error Status: 0x%4.
//
typedef struct _evtIML_DCPMM_PERSIS_LOST_ERR_INFO_10_12697
{
  BYTE processorNumber;
  BYTE dimmNumber;
  WORD errorCount;
  WORD errorStatus;
} EVT_IML_DCPMM_PERSIS_LOST_ERR_INFO_10_12697, *PEVT_IML_DCPMM_PERSIS_LOST_ERR_INFO_10_12697;
    
//
// TLS Version changed to %1.
//
typedef struct _evtSL_SECURITY_TLS_VERSION_CHANGED_10_12710
{
  char tLSVersionNum[1];
} EVT_SL_SECURITY_TLS_VERSION_CHANGED_10_12710, *PEVT_SL_SECURITY_TLS_VERSION_CHANGED_10_12710;
    
//
// PCIe Enhanced Downstream Port Containment (EDPC) Event detected on NVMe Box %1 Bay %2.  EDPC Status: 0x%3.
//
typedef struct _evtIML_PCIE_EDPC_DETECTION_NVME_10_12717
{
  BYTE boxNumber;
  BYTE bayNumber;
  WORD edpcStatus;
} EVT_IML_PCIE_EDPC_DETECTION_NVME_10_12717, *PEVT_IML_PCIE_EDPC_DETECTION_NVME_10_12717;
    
//
// Secure Boot Authentication Failure - The image on %1 was not authorized due to revoked certificate(s) and was not executed.
//
typedef struct _evtSL_SECURE_BOOT_AUTH_FAIL_CERT2_10_12718
{
  char location[1];
} EVT_SL_SECURE_BOOT_AUTH_FAIL_CERT2_10_12718, *PEVT_SL_SECURE_BOOT_AUTH_FAIL_CERT2_10_12718;
    
//
// Secure Boot Authentication Failure - The image on %1 failed authentication and was not executed
//
typedef struct _evtSL_SECURE_BOOT_AUTH_FAIL2_10_12719
{
  char location[1];
} EVT_SL_SECURE_BOOT_AUTH_FAIL2_10_12719, *PEVT_SL_SECURE_BOOT_AUTH_FAIL2_10_12719;
    
//
// Processor %1, DIMM %2 (SN:%3-%4-%5-%6) - Energy source is not charged sufficiently to support the energy-backed persistent memory installed in the system. The system will wait for the energy source to charge sufficiently before continuing boot.
//
typedef struct _evtIML_ENERGY_SOURCE_NOT_CHARGED_WAIT_10_12725
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_ENERGY_SOURCE_NOT_CHARGED_WAIT_10_12725, *PEVT_IML_ENERGY_SOURCE_NOT_CHARGED_WAIT_10_12725;
    
//
// Processor %1, DIMM %2 (SN:%3-%4-%5-%6) - Energy source is not charged sufficiently to support the energy-backed persistent memory installed in the system. System configured to not wait for energy source to charge. Persistent memory regions may not be available in the OS.
//
typedef struct _evtIML_ENERGY_SOURCE_NOT_CHARGED_NO_WAIT_10_12726
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_ENERGY_SOURCE_NOT_CHARGED_NO_WAIT_10_12726, *PEVT_IML_ENERGY_SOURCE_NOT_CHARGED_NO_WAIT_10_12726;
    
//
// Processor %1, DIMM %2 (SN:%3-%4-%5-%6) - Backup power has been lost for the indicated NVDIMM and future backup is not possible. Data from the last successful backup is intact, but data modified after the last successful backup will be lost if power cannot be restored.
//
typedef struct _evtIML_NVDIMM_BACKUP_PWR_ERROR_10_12727
{
  BYTE processorNumber;
  BYTE dimmNumber;
  char mfrID[1];
  //char mfgLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char mfgDate[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char srNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVDIMM_BACKUP_PWR_ERROR_10_12727, *PEVT_IML_NVDIMM_BACKUP_PWR_ERROR_10_12727;
    
//
// One-button secure erase failure for %1.
//
typedef struct _evtIML_SANITIZE_CONTROLLER_SECURE_ERASE_FAIL_10_12732
{
  char deviceInfoString[1];
} EVT_IML_SANITIZE_CONTROLLER_SECURE_ERASE_FAIL_10_12732, *PEVT_IML_SANITIZE_CONTROLLER_SECURE_ERASE_FAIL_10_12732;
    
//
// PCIe correctable error threshold exceeded. Bus 0x%1 Device 0x%2 Function 0x%3
//
typedef struct _evtIML_FACTORY_PCIE_ERROR_EXCEEDED_10_12733
{
  BYTE busNum;
  BYTE devNum;
  BYTE funcNum;
} EVT_IML_FACTORY_PCIE_ERROR_EXCEEDED_10_12733, *PEVT_IML_FACTORY_PCIE_ERROR_EXCEEDED_10_12733;
    
//
// Intel Optane PMem for HPE Error - Processor %1 DIMM %2 (SN: %3) - The HPE  Persistent Memory Module reported a failure on the current boot (Current Boot Status Register: 0x%4).
//
typedef struct _evtIML_PMEM_CURRENT_BSR_WARNING_10_12739
{
  BYTE processorNumber;
  BYTE dimmNumber;
  QWORD statusDetails;
  char serialNum[1];
} EVT_IML_PMEM_CURRENT_BSR_WARNING_10_12739, *PEVT_IML_PMEM_CURRENT_BSR_WARNING_10_12739;
    
//
// Power Fault Detected - OCP %1
//
typedef struct _evtIML_PWR_FAIL_OCP_10_12742
{
  BYTE oCPNumber;
} EVT_IML_PWR_FAIL_OCP_10_12742, *PEVT_IML_PWR_FAIL_OCP_10_12742;
    
//
// SmartIO Timeout Error (Slot %1, Error Code %2). Device did not report initialization completion in time. Some functionality may not be available.
//
typedef struct _evtIML_EVT_SMARTNIC_TIMEOUT_10_12743
{
  BYTE slotNumber;
  BYTE errorCode;
} EVT_IML_EVT_SMARTNIC_TIMEOUT_10_12743, *PEVT_IML_EVT_SMARTNIC_TIMEOUT_10_12743;
    
//
// SmartIO Initialization Error (Slot %1, Error Code %2). Device reports a fatal error during initialization. Some functionality may not be available.
//
typedef struct _evtIML_SMARTIO_INIT_ERROR_10_12744
{
  BYTE slotNum;
  BYTE errorCode;
} EVT_IML_SMARTIO_INIT_ERROR_10_12744, *PEVT_IML_SMARTIO_INIT_ERROR_10_12744;
    
//
// PCIe Enhanced Downstream Port Containment (EDPC) Event detected on Slot %1.  EDPC Status: 0x%2.
//
typedef struct _evtIML_PCIE_EDPC_DETECTION_EVENT_10_12747
{
  BYTE slotNumber;
  WORD edpcStatus;
} EVT_IML_PCIE_EDPC_DETECTION_EVENT_10_12747, *PEVT_IML_PCIE_EDPC_DETECTION_EVENT_10_12747;
    
//
// High Bandwidth Memory (HBM) Failure  - Uncorrectable Memory Error (Processor %1)
//
typedef struct _evtIML_HBM_UNC_MEM_ERR_10_12753
{
  BYTE procNumber;
} EVT_IML_HBM_UNC_MEM_ERR_10_12753, *PEVT_IML_HBM_UNC_MEM_ERR_10_12753;
    
//
// High Bandwidth Memory (HBM) Failure - Correctable Memory Error Exceeded Threshold (Processor %1).
//
typedef struct _evtIML_HBM_CORRECTED_ERROR_THRESHOLD_10_12754
{
  BYTE procNumber;
} EVT_IML_HBM_CORRECTED_ERROR_THRESHOLD_10_12754, *PEVT_IML_HBM_CORRECTED_ERROR_THRESHOLD_10_12754;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 violates DIMM population rules.
//
typedef struct _evtIML_DIMM_CFG_POP_ORDER_FIFTH_10_12755
{
  BYTE processorNumber;
} EVT_IML_DIMM_CFG_POP_ORDER_FIFTH_10_12755, *PEVT_IML_DIMM_CFG_POP_ORDER_FIFTH_10_12755;
    
//
// The SmartIO device was removed from Slot %1 due to a timeout error.
//
typedef struct _evtIML_SMARTIO_REMOVED_FROM_PCI_BUS_10_12756
{
  BYTE slotNumber;
} EVT_IML_SMARTIO_REMOVED_FROM_PCI_BUS_10_12756, *PEVT_IML_SMARTIO_REMOVED_FROM_PCI_BUS_10_12756;
    
//
// High Bandwidth Memory (HBM) Uncorrectable Memory Error Threshold Exceeded (Processor %1, Stack %2). Memory modules on the same HBM stack are mapped out and are currently not available. The HBM stack map out may result in non-optimal memory performance or other unexpected behavior.
//
typedef struct _evtIML_HBM_UCE_MAPOUT_10_12757
{
  BYTE procNumber;
  BYTE stackNumber;
} EVT_IML_HBM_UCE_MAPOUT_10_12757, *PEVT_IML_HBM_UCE_MAPOUT_10_12757;
    
//
// %1 %2 Port %3 NVMe-oF Error - Failed to acquire DHCP initiator network address.
//
typedef struct _evtIML_NVMEOF_ERR_CLIENT_10_12759
{
  BYTE deviceType;
  BYTE deviceNumber;
  BYTE portNumber;
} EVT_IML_NVMEOF_ERR_CLIENT_10_12759, *PEVT_IML_NVMEOF_ERR_CLIENT_10_12759;
    
//
// %1 %2 Port %3 NVMe-oF Error - Failed to acquire DHCP target network address.
//
typedef struct _evtIML_NVMEOF_ERR_TARGET_10_12760
{
  BYTE deviceType;
  BYTE deviceNumber;
  BYTE portNumber;
} EVT_IML_NVMEOF_ERR_TARGET_10_12760, *PEVT_IML_NVMEOF_ERR_TARGET_10_12760;
    
//
// %1 %2 Port %3 NVMe-oF Error - Boot Namespace ID is not available.
//
typedef struct _evtIML_NVMEOF_ERR_BOOT_NID_10_12761
{
  BYTE deviceType;
  BYTE deviceNumber;
  BYTE portNumber;
} EVT_IML_NVMEOF_ERR_BOOT_NID_10_12761, *PEVT_IML_NVMEOF_ERR_BOOT_NID_10_12761;
    
//
// Firmware Update Error - Server Platform Services firmware was not updated successfully. Current version is %1.
//
typedef struct _evtIML_SPS_FIRMWARE_UPDATE_ERROR_10_12762
{
  char versionString[1];
} EVT_IML_SPS_FIRMWARE_UPDATE_ERROR_10_12762, *PEVT_IML_SPS_FIRMWARE_UPDATE_ERROR_10_12762;
    
//
// %1 %2 Port %3 NVMe-oF Error - NVMe-oF login failed.
//
typedef struct _evtIML_NVMEOF_ERR_LOGIN_10_12764
{
  BYTE deviceType;
  BYTE deviceNumber;
  BYTE portNumber;
} EVT_IML_NVMEOF_ERR_LOGIN_10_12764, *PEVT_IML_NVMEOF_ERR_LOGIN_10_12764;
    
//
// BIOS has missed the sync event with iLO (%1). The hot-plug of NVMe drives shall not be detected.
//
typedef struct _evtIML_NVME_HOTPLUG_SYNC_ERROR_10_12766
{
  BYTE reason;
} EVT_IML_NVME_HOTPLUG_SYNC_ERROR_10_12766, *PEVT_IML_NVME_HOTPLUG_SYNC_ERROR_10_12766;
    
//
// OCP slot %1 port %2 NVMe of error - failed to acquire DHCP initiator network address.
//
typedef struct _evtIML_OCP_NVMEOF_ERR_CLIENT_10_12767
{
  BYTE portNumber;
  char slotString[1];
} EVT_IML_OCP_NVMEOF_ERR_CLIENT_10_12767, *PEVT_IML_OCP_NVMEOF_ERR_CLIENT_10_12767;
    
//
// OCP Slot %1 Port %2 NVMe-oF Error - Failed to acquire DHCP target network address.
//
typedef struct _evtIML_OCP_NVMEOF_ERR_TARGET_10_12768
{
  BYTE portNumber;
  char slotString[1];
} EVT_IML_OCP_NVMEOF_ERR_TARGET_10_12768, *PEVT_IML_OCP_NVMEOF_ERR_TARGET_10_12768;
    
//
// OCP Slot %1 Port %2 NVMe-oF Error - Boot Namespace ID is not available.
//
typedef struct _evtIML_OCP_NVMEOF_ERR_BOOT_NID_10_12769
{
  BYTE portNumber;
  char slotString[1];
} EVT_IML_OCP_NVMEOF_ERR_BOOT_NID_10_12769, *PEVT_IML_OCP_NVMEOF_ERR_BOOT_NID_10_12769;
    
//
// OCP Slot %1 Port %2 NVMe-oF Error - NVMe-oF login failed.
//
typedef struct _evtIML_OCP_NVMEOF_ERR_LOGIN_10_12770
{
  BYTE portNumber;
  char slotString[1];
} EVT_IML_OCP_NVMEOF_ERR_LOGIN_10_12770, *PEVT_IML_OCP_NVMEOF_ERR_LOGIN_10_12770;
    
//
// OCP Slot %1 iSCSI Error - Failed to acquire DHCP initiator network address.
//
typedef struct _evtIML_OCP_ISCSI_ERR_CLIENT_10_12771
{
  char slotString[1];
} EVT_IML_OCP_ISCSI_ERR_CLIENT_10_12771, *PEVT_IML_OCP_ISCSI_ERR_CLIENT_10_12771;
    
//
// OCP Slot %1 iSCSI Error - Failed to acquire DHCP target network address.
//
typedef struct _evtIML_OCP_ISCSI_ERR_TARGET_10_12772
{
  char slotString[1];
} EVT_IML_OCP_ISCSI_ERR_TARGET_10_12772, *PEVT_IML_OCP_ISCSI_ERR_TARGET_10_12772;
    
//
// OCP Slot %1 iSCSI Error - iSCSI login failed.
//
typedef struct _evtIML_OCP_ISCSI_ERR_LOGIN_10_12773
{
  char slotString[1];
} EVT_IML_OCP_ISCSI_ERR_LOGIN_10_12773, *PEVT_IML_OCP_ISCSI_ERR_LOGIN_10_12773;
    
//
// OCP slot %1 iSCSI error - Boot LUN not available.
//
typedef struct _evtIML_OCP_ISCSI_ERR_BOOT_LUN_10_12774
{
  char slotString[1];
} EVT_IML_OCP_ISCSI_ERR_BOOT_LUN_10_12774, *PEVT_IML_OCP_ISCSI_ERR_BOOT_LUN_10_12774;
    
//
// NVMe secure erase was failed for %1 (SN: %2) - %3.
//
typedef struct _evtIML_NVMe_SECURE_ERASE_FAILURE_10_12775
{
  BYTE pCIBusIndex;
  BYTE pCIDeviceIndex;
  BYTE pCIFunctionIndex;
  BYTE failureInformation;
  char diskPath[1];
  //char serialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVMe_SECURE_ERASE_FAILURE_10_12775, *PEVT_IML_NVMe_SECURE_ERASE_FAILURE_10_12775;
    
//
// NVMe secure erase has %1  for %2 (SN: %3). 
//
typedef struct _evtIML_NVMe_SECURE_ERASE_START_COMPLETE_10_12776
{
  BYTE statusInformation;
  char diskPath[1];
  //char serialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NVMe_SECURE_ERASE_START_COMPLETE_10_12776, *PEVT_IML_NVMe_SECURE_ERASE_START_COMPLETE_10_12776;
    
//
// Maximum Memory Bus Frequency in BIOS/Platform Configuration (RBSU) has been changed to 'Auto' due to the original user setting ( %1 MHz) is unsupported.
//
typedef struct _evtIML_MEM_SPEED_CHANGE_TO_AUTO_10_12777
{
  WORD originalMemorySpeed;
} EVT_IML_MEM_SPEED_CHANGE_TO_AUTO_10_12777, *PEVT_IML_MEM_SPEED_CHANGE_TO_AUTO_10_12777;
    
//
// PCIe Error Disconnect Recover (EDR) failed on Slot %1.
//
typedef struct _evtIML_PCIE_EDR_FAIL_EVENT_10_12778
{
  BYTE slotNumber;
} EVT_IML_PCIE_EDR_FAIL_EVENT_10_12778, *PEVT_IML_PCIE_EDR_FAIL_EVENT_10_12778;
    
//
// PCIe Error Disconnect Recover (EDR) failed on NVMe Box %1 Bay %2.
//
typedef struct _evtIML_PCIE_EDR_FAIL_NVME_10_12779
{
  BYTE boxNumber;
  BYTE bayNumber;
} EVT_IML_PCIE_EDR_FAIL_NVME_10_12779, *PEVT_IML_PCIE_EDR_FAIL_NVME_10_12779;
    
//
// Mismatched Power Supply Installed
//
typedef struct _evtIML_PS_MISMATCH_11_21
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  BYTE powerSupplyErrorId;
  BYTE powerSupplyState;
  char chassisName[1];
  //char powerSupplyMode[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyAutoRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSuppyFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyServerId[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_MISMATCH_11_21, *PEVT_IML_PS_MISMATCH_11_21;
    
//
// Smart Storage Energy Pack Removed (Energy Pack %1)
//
typedef struct _evtIML_PS_STORBAT_REMOVED_11_30
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE batteryId;
  char chassisName[1];
  //char ccpqHoGUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_STORBAT_REMOVED_11_30, *PEVT_IML_PS_STORBAT_REMOVED_11_30;
    
//
// Power On Denied (Service Information: %1)
//
typedef struct _evtIML_PS_POWER_ON_DENIED_11_36
{
  char text[1];
  //char fRUStatus[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char cpqHoGUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_POWER_ON_DENIED_11_36, *PEVT_IML_PS_POWER_ON_DENIED_11_36;
    
//
// System Power Supply: %1 (Power Supply %2)
//
typedef struct _evtIML_PS_FAILURE_11_40
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  BYTE powerSupplyErrorId;
  BYTE powerSupplyState;
  char chassisName[1];
  //char powerSupplyModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyAutoRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyServerId[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_FAILURE_11_40, *PEVT_IML_PS_FAILURE_11_40;
    
//
// External Chassis Power Supply: %1 (Chassis %2, Power Supply %3)
//
typedef struct _evtIML_PS_FAILURE_EXT_CHASSIS_11_41
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  BYTE powerSupplyErrorId;
  BYTE powerSupplyState;
  char chassisName[1];
  //char powerSupplyModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyAutoRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyServerId[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_FAILURE_EXT_CHASSIS_11_41, *PEVT_IML_PS_FAILURE_EXT_CHASSIS_11_41;
    
//
// %1 Storage System Power Supply: %2 (%3Slot %4, Power Supply %5)
//
typedef struct _evtIML_PS_FAILURE_STORAGE_11_42
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  BYTE powerSupplyErrorId;
  BYTE powerSupplyState;
  char chassisName[1];
  //char powerSupplyModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyAutoRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyServerId[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_FAILURE_STORAGE_11_42, *PEVT_IML_PS_FAILURE_STORAGE_11_42;
    
//
// %1 Power Supply: %2 (Power Supply %3, %4)
//
typedef struct _evtIML_PS_FAILURE_ENCLOSURE_11_43
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  BYTE powerSupplyErrorId;
  BYTE powerSupplyState;
  char chassisName[1];
  //char powerSupplyModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyAutoRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyServerId[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_FAILURE_ENCLOSURE_11_43, *PEVT_IML_PS_FAILURE_ENCLOSURE_11_43;
    
//
// System Power Supply Removed (Power Supply %1)
//
typedef struct _evtIML_PS_REMOVED_11_44
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_REMOVED_11_44, *PEVT_IML_PS_REMOVED_11_44;
    
//
// External Chassis Power Supply Removed (Chassis %1, Power Supply %2)
//
typedef struct _evtIML_PS_REMOVED_EXT_CHASSIS_11_45
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_REMOVED_EXT_CHASSIS_11_45, *PEVT_IML_PS_REMOVED_EXT_CHASSIS_11_45;
    
//
// %1 Storage System Power Supply Removed (Chassis %2 Slot %3, Power Supply %4)
//
typedef struct _evtIML_PS_REMOVED_STORAGE_11_46
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_REMOVED_STORAGE_11_46, *PEVT_IML_PS_REMOVED_STORAGE_11_46;
    
//
// %1 Power Supply Removed (Power Supply %2, Enclosure Address %3)
//
typedef struct _evtIML_PS_REMOVED_ENCLOSURE_ADDR_11_47
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_REMOVED_ENCLOSURE_ADDR_11_47, *PEVT_IML_PS_REMOVED_ENCLOSURE_ADDR_11_47;
    
//
// %1 Power Supply Removed (Power Supply %2, Enclosure Serial Number %3)
//
typedef struct _evtIML_PS_REMOVED_ENCLOSURE_SERIAL_11_48
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_REMOVED_ENCLOSURE_SERIAL_11_48, *PEVT_IML_PS_REMOVED_ENCLOSURE_SERIAL_11_48;
    
//
// System Power Supply Inserted (Power Supply %1)
//
typedef struct _evtIML_PS_INSERTED_11_49
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_INSERTED_11_49, *PEVT_IML_PS_INSERTED_11_49;
    
//
// External Chassis Power Supply Inserted (Chassis %1, Power Supply %2)
//
typedef struct _evtIML_PS_INSERTED_EXT_CHASSIS_11_50
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_INSERTED_EXT_CHASSIS_11_50, *PEVT_IML_PS_INSERTED_EXT_CHASSIS_11_50;
    
//
// %1 Storage System Power Supply Inserted (Chassis %2 Slot %3, Power Supply %4)
//
typedef struct _evtIML_PS_INSERTED_STORAGE_11_51
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_INSERTED_STORAGE_11_51, *PEVT_IML_PS_INSERTED_STORAGE_11_51;
    
//
// %1 Power Supply Inserted (Power Supply %2, Enclosure Address %3)
//
typedef struct _evtIML_PS_INSERTED_ENCLOSURE_ADDR_11_52
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_INSERTED_ENCLOSURE_ADDR_11_52, *PEVT_IML_PS_INSERTED_ENCLOSURE_ADDR_11_52;
    
//
// %1 Power Supply Inserted (Power Supply %2, Enclosure Serial Number %3)
//
typedef struct _evtIML_PS_INSERTED_ENCLOSURE_SERIAL_11_53
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_INSERTED_ENCLOSURE_SERIAL_11_53, *PEVT_IML_PS_INSERTED_ENCLOSURE_SERIAL_11_53;
    
//
// System Power Supplies Not Redundant
//
typedef struct _evtIML_PS_NOT_REDUNDANT_11_54
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_NOT_REDUNDANT_11_54, *PEVT_IML_PS_NOT_REDUNDANT_11_54;
    
//
// External Chassis Power Supplies Not Redundant (Chassis %1)
//
typedef struct _evtIML_PS_NOT_REDUNDANT_EXT_CHASSIS_11_55
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_NOT_REDUNDANT_EXT_CHASSIS_11_55, *PEVT_IML_PS_NOT_REDUNDANT_EXT_CHASSIS_11_55;
    
//
// %1 Storage System Power Supplies Not Redundant (Chassis %2 Slot %3)
//
typedef struct _evtIML_PS_NOT_REDUNDANT_STORAGE_11_56
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_NOT_REDUNDANT_STORAGE_11_56, *PEVT_IML_PS_NOT_REDUNDANT_STORAGE_11_56;
    
//
// %1 Power Supplies Not Redundant (Enclosure Serial Number %2)
//
typedef struct _evtIML_PS_NOT_REDUNDANT_ENCLOSURE_SERIAL_11_58
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  char chassisName[1];
} EVT_IML_PS_NOT_REDUNDANT_ENCLOSURE_SERIAL_11_58, *PEVT_IML_PS_NOT_REDUNDANT_ENCLOSURE_SERIAL_11_58;
    
//
// %1 Power Supplies Not Redundant (Enclosure Address %2)
//
typedef struct _evtIML_PS_NOT_REDUNDANT_ENCLOSURE_ADDR_11_59
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE psId;
  char chassisName[1];
} EVT_IML_PS_NOT_REDUNDANT_ENCLOSURE_ADDR_11_59, *PEVT_IML_PS_NOT_REDUNDANT_ENCLOSURE_ADDR_11_59;
    
//
// System Power Fault Detected (XR: %1 %2  MID:  %3)
//
typedef struct _evtIML_PS_SERVER_POWER_FAULT_11_60
{
  BYTE xRegisters1;
  BYTE xRegisters2;
  char mIDChain[1];
} EVT_IML_PS_SERVER_POWER_FAULT_11_60, *PEVT_IML_PS_SERVER_POWER_FAULT_11_60;
    
//
// System Power Fault Detected (XR: %1 %2  MID:  %3)
//
typedef struct _evtIML_PS_SERVER_POWER_FAULT_OVERLOAD_11_61
{
  BYTE xRegisters1;
  BYTE xRegisters2;
  char mIDChain[1];
} EVT_IML_PS_SERVER_POWER_FAULT_OVERLOAD_11_61, *PEVT_IML_PS_SERVER_POWER_FAULT_OVERLOAD_11_61;
    
//
// Smart Storage Energy Pack failure (Energy Pack %1, service information: %2).
//
typedef struct _evtIML_PS_STORBAT_FAILED_11_62
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE batteryId;
  DWORD errorCode;
  char chassisName[1];
  //char batteryModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char cpqHoGUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_STORBAT_FAILED_11_62, *PEVT_IML_PS_STORBAT_FAILED_11_62;
    
//
// Smart Storage Energy Pack did not charge at the expected rate, indicating a faulty energy pack (Energy Pack %1, service information: 0x03)
//
typedef struct _evtIML_PS_STORBAT_FAILED_INFO_3_11_63
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE batteryId;
  DWORD errorCode;
  char chassisName[1];
  //char batteryModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char cpqHoGUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_STORBAT_FAILED_INFO_3_11_63, *PEVT_IML_PS_STORBAT_FAILED_INFO_3_11_63;
    
//
// Smart Storage Energy Pack disabled due to high or low ambient temperature, will be re-enabled when temp is back to normal range (Energy Pack %1, service information: 0x04)
//
typedef struct _evtIML_PS_STORBAT_FAILED_INFO_4_11_64
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE batteryId;
  DWORD errorCode;
  char chassisName[1];
  //char batteryModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char cpqHoGUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_STORBAT_FAILED_INFO_4_11_64, *PEVT_IML_PS_STORBAT_FAILED_INFO_4_11_64;
    
//
// Smart Storage Energy Pack discharged to below minimum voltage, resulting in the inability of the energy pack to recharge properly (Energy Pack %1, service information: 0x05)
//
typedef struct _evtIML_PS_STORBAT_FAILED_INFO_5_11_65
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE batteryId;
  DWORD errorCode;
  char chassisName[1];
  //char batteryModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char cpqHoGUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_STORBAT_FAILED_INFO_5_11_65, *PEVT_IML_PS_STORBAT_FAILED_INFO_5_11_65;
    
//
// Smart Storage Energy Pack has exceeded the maximum amount of devices supported (Energy Pack %1, service information: 0x07)
//
typedef struct _evtIML_PS_STORBAT_FAILED_INFO_7_11_66
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE batteryId;
  DWORD errorCode;
  char chassisName[1];
  //char batteryModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char cpqHoGUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_STORBAT_FAILED_INFO_7_11_66, *PEVT_IML_PS_STORBAT_FAILED_INFO_7_11_66;
    
//
// Smart Storage Energy Pack failure (Energy Pack %1)
//
typedef struct _evtIML_PS_STORBAT_FAILED_INFO_11_11_67
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE batteryId;
  DWORD errorCode;
  char chassisName[1];
  //char batteryModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char cpqHoGUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_STORBAT_FAILED_INFO_11_11_67, *PEVT_IML_PS_STORBAT_FAILED_INFO_11_11_67;
    
//
// %1 Storage Enclosure Power Supply Failure (Power Supply %2, Box %3, %4)
//
typedef struct _evtIML_PS_FAILURE_SAS_11_68
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  BYTE box;
  char portId[1];
  //char chassisName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_FAILURE_SAS_11_68, *PEVT_IML_PS_FAILURE_SAS_11_68;
    
//
// System Power Supply: %1 (Power Supply %2)
//
typedef struct _evtIML_PS_AC_LOST_11_82
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE powerSupplyId;
  BYTE powerSupplyErrorId;
  BYTE powerSupplyState;
  char chassisName[1];
  //char powerSupplyModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyAutoRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char powerSupplyServerId[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_AC_LOST_11_82, *PEVT_IML_PS_AC_LOST_11_82;
    
//
// %1 power: %2W exceeded the redundant power capacity threshold: %3W
//
typedef struct _evtIML_PS_SERVER_PWR_EXCEEDED_REDUNDANT_WARN_LIMIT_11_83
{
  DWORD serverPowerConsumption;
  DWORD redundantPowerThreshold;
  BYTE domainName;
} EVT_IML_PS_SERVER_PWR_EXCEEDED_REDUNDANT_WARN_LIMIT_11_83, *PEVT_IML_PS_SERVER_PWR_EXCEEDED_REDUNDANT_WARN_LIMIT_11_83;
    
//
// System Power Supply: %1 (Power Supply %2)
//
typedef struct _evtIML_PS_RECOVERABLE_FAILURE_11_84
{
  BYTE powerSupplyId;
  BYTE powerSupplyErrorId;
  BYTE chassisId;
} EVT_IML_PS_RECOVERABLE_FAILURE_11_84, *PEVT_IML_PS_RECOVERABLE_FAILURE_11_84;
    
//
// Battery Backup Unit: %1 (Power Supply %2)
//
typedef struct _evtIML_PS_BBU_FAILURE_11_85
{
  BYTE powerSupplyId;
  BYTE batteryBackupUnitErrorId;
  BYTE chassisId;
} EVT_IML_PS_BBU_FAILURE_11_85, *PEVT_IML_PS_BBU_FAILURE_11_85;
    
//
// Smart Storage Energy Pack pre-failure (Energy Pack %1)
//
typedef struct _evtIML_PS_STORBAT_PREFAIL_INFO_12_11_86
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE batteryId;
  DWORD errorCode;
  char chassisName[1];
  //char batteryModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySerial[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char batterySpare[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char cpqHoGUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PS_STORBAT_PREFAIL_INFO_12_11_86, *PEVT_IML_PS_STORBAT_PREFAIL_INFO_12_11_86;
    
//
// The Battery Backup Unit in Power Supply bay %1 is discharging.
//
typedef struct _evtIML_PS_BBU_DISCHARGING_11_87
{
  BYTE powerSupplyId;
} EVT_IML_PS_BBU_DISCHARGING_11_87, *PEVT_IML_PS_BBU_DISCHARGING_11_87;
    
//
// %1 power: %2W exceeded the power capacity threshold: %3W
//
typedef struct _evtIML_PS_SERVER_PWR_EXCEEDED_LIMIT_11_89
{
  DWORD serverPowerConsumption;
  DWORD powerCapacityThreshold;
  BYTE domainName;
} EVT_IML_PS_SERVER_PWR_EXCEEDED_LIMIT_11_89, *PEVT_IML_PS_SERVER_PWR_EXCEEDED_LIMIT_11_89;
    
//
// Unsupported Power Supply Configuration - Unsupported Power Supply detected at bay location %1.
//
typedef struct _evtIML_PS_UNSUPPORTED_11_144
{
  BYTE chassisId;
  BYTE bay;
} EVT_IML_PS_UNSUPPORTED_11_144, *PEVT_IML_PS_UNSUPPORTED_11_144;
    
//
// Over Current Warning occurred for Power Supply %1
//
typedef struct _evtIML_MCRPS_OVER_CURRENT_WARNING_11_146
{
  BYTE bay;
} EVT_IML_MCRPS_OVER_CURRENT_WARNING_11_146, *PEVT_IML_MCRPS_OVER_CURRENT_WARNING_11_146;
    
//
// Over Current Fault occurred for Power Supply %1 
//
typedef struct _evtIML_MCRPS_OVER_CURRENT_FAULT_11_147
{
  BYTE bay;
} EVT_IML_MCRPS_OVER_CURRENT_FAULT_11_147, *PEVT_IML_MCRPS_OVER_CURRENT_FAULT_11_147;
    
//
// Over Temperature Warning occurred for Power Supply %1
//
typedef struct _evtIML_MCRPS_OVER_TEMPERATURE_WARNING_11_148
{
  BYTE bay;
} EVT_IML_MCRPS_OVER_TEMPERATURE_WARNING_11_148, *PEVT_IML_MCRPS_OVER_TEMPERATURE_WARNING_11_148;
    
//
// Over Temperature Fault occurred for Power Supply %1
//
typedef struct _evtIML_MCRPS_OVER_TEMPERATURE_FAULT_11_149
{
  BYTE bay;
} EVT_IML_MCRPS_OVER_TEMPERATURE_FAULT_11_149, *PEVT_IML_MCRPS_OVER_TEMPERATURE_FAULT_11_149;
    
//
// Unsupported %1 detected
//
typedef struct _evtIML_PDB_UNSUPPORTED_11_150
{
  char nAME[1];
} EVT_IML_PDB_UNSUPPORTED_11_150, *PEVT_IML_PDB_UNSUPPORTED_11_150;
    
//
// Automatic Operating System Shutdown %1
//
typedef struct _evtIML_OS_AUTO_SHUTDOWN_14_2
{
  BYTE cause;
} EVT_IML_OS_AUTO_SHUTDOWN_14_2, *PEVT_IML_OS_AUTO_SHUTDOWN_14_2;
    
//
// Network Adapter Link Down (Slot %1, Port %2)
//
typedef struct _evtIML_NIC_LINK_DOWN_1_17_8
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE slot;
  char chassisName[1];
} EVT_IML_NIC_LINK_DOWN_1_17_8, *PEVT_IML_NIC_LINK_DOWN_1_17_8;
    
//
// Network Adapter Link Down (Chassis %1, Slot %2, Port %3)
//
typedef struct _evtIML_NIC_LINK_DOWN_2_17_9
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE slot;
  char chassisName[1];
} EVT_IML_NIC_LINK_DOWN_2_17_9, *PEVT_IML_NIC_LINK_DOWN_2_17_9;
    
//
// %1 Connectivity status changed to %2 for adapter in slot %3, port %4
//
typedef struct _evtIML_NIC_LINK_CONNECTIVITY_LOST_17_10
{
  BYTE phyAdapterId;
  BYTE slot;
  BYTE hostTrapFlag;
  BYTE port;
  BYTE status;
  BYTE nicIfLogMapIndex;
  BYTE busNum;
  BYTE devNum;
  BYTE address1;
  BYTE address2;
  BYTE address3;
  BYTE address4;
  char serverSystemId[1];
  //char pciSlotBoardName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char pysAdapterPartNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ipAdEntAddr[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char logMapIPV6Address[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char slot_name[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NIC_LINK_CONNECTIVITY_LOST_17_10, *PEVT_IML_NIC_LINK_CONNECTIVITY_LOST_17_10;
    
//
// Fibre Channel Host Controller has a new  Status %1
//
typedef struct _evtIML_FCA_HOST_CNTRL_STATUS_CHANGE_17_11
{
  BYTE hostTrapFlags;
  BYTE fcaHostCntlrIndex;
  BYTE fcaHostCntlrStatus;
  char fcaHostCntlrLocation[1];
  //char fcaHostCntlrModelNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char fcaHostCntlrSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char fcaHostCntlrWorldWideName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char fcaHostCntlrWorldWidePortName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_FCA_HOST_CNTRL_STATUS_CHANGE_17_11, *PEVT_IML_FCA_HOST_CNTRL_STATUS_CHANGE_17_11;
    
//
// Redundancy status changed to %1 by adapter in slot %2, port %3
//
typedef struct _evtIML_NIC_LINK_REDUNDANCY_LOST_17_12
{
  BYTE phyAdapterId;
  BYTE slot;
  BYTE hostTrapFlag;
  BYTE port;
  BYTE status;
  BYTE blogMapAdokCount;
  BYTE nicIfLogMapIndex;
  BYTE busNum;
  BYTE devNum;
  BYTE address1;
  BYTE address2;
  BYTE address3;
  BYTE address4;
  char serverSystemId[1];
  //char pciSlotBoardName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char pysAdapterPartNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ipAdEntAddr[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char logMapIPV6Address[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NIC_LINK_REDUNDANCY_LOST_17_12, *PEVT_IML_NIC_LINK_REDUNDANCY_LOST_17_12;
    
//
//  All links are down in adapter %1 in slot %2
//
typedef struct _evtIML_NIC_ALL_LINK_CONNECTIVITY_LOST_17_13
{
  BYTE hostTrapFlag;
  BYTE phyAdapterId;
  BYTE busNum;
  BYTE devNum;
  BYTE slot;
  char serverSystemId[1];
  //char pciSlotBoardName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char pysAdapterPartNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char slot_name[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NIC_ALL_LINK_CONNECTIVITY_LOST_17_13, *PEVT_IML_NIC_ALL_LINK_CONNECTIVITY_LOST_17_13;
    
//
// At least one of the links is up in adapter %1 in slot %2
//
typedef struct _evtIML_NIC_SOME_LINK_CONNECTIVITY_UP_17_14
{
  BYTE hostTrapFlag;
  BYTE phyAdapterId;
  BYTE busNum;
  BYTE devNum;
  BYTE slot;
  char serverSystemId[1];
  //char pciSlotBoardName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char pysAdapterPartNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char slot_name[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NIC_SOME_LINK_CONNECTIVITY_UP_17_14, *PEVT_IML_NIC_SOME_LINK_CONNECTIVITY_UP_17_14;
    
//
// %1
//
typedef struct _evtIML_DPU_SMARTNIC_17_15
{
  char message[1];
} EVT_IML_DPU_SMARTNIC_17_15, *PEVT_IML_DPU_SMARTNIC_17_15;
    
//
// One of the NIC connectivity status changed to %1
//
typedef struct _evtIML_NIC_LINK_CONNECTIVITY_UP_DOWN_17_16
{
  BYTE phyAdapterId;
  BYTE slot;
  BYTE hostTrapFlag;
  BYTE port;
  BYTE status;
  BYTE nicIfLogMapIndex;
  BYTE busNum;
  BYTE devNum;
  BYTE address1;
  BYTE address2;
  BYTE address3;
  BYTE address4;
  char serverSystemId[1];
  //char pciSlotBoardName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char pysAdapterPartNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ipAdEntAddr[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char logMapIPV6Address[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_NIC_LINK_CONNECTIVITY_UP_DOWN_17_16, *PEVT_IML_NIC_LINK_CONNECTIVITY_UP_DOWN_17_16;
    
//
// %1 in Slot  %2 %3 operation is %4
//
typedef struct _evtIML_NIC_CONFIG_CHANGE_17_17
{
  BYTE slotNo;
  BYTE operation;
  BYTE status;
  char productName[1];
} EVT_IML_NIC_CONFIG_CHANGE_17_17, *PEVT_IML_NIC_CONFIG_CHANGE_17_17;
    
//
// iSCSI link/session is up
//
typedef struct _evtIML_iSCSI_LINK_UP_18_1
{
  BYTE hostTrapFlags;
  DWORD iScsiInstIndex;
  char iScsiInstDescr[1];
} EVT_IML_iSCSI_LINK_UP_18_1, *PEVT_IML_iSCSI_LINK_UP_18_1;
    
//
// iSCSI link/session is down
//
typedef struct _evtIML_iSCSI_LINK_DOWN_18_2
{
  BYTE hostTrapFlags;
  DWORD iScsiInstIndex;
  char iScsiInstDescr[1];
} EVT_IML_iSCSI_LINK_DOWN_18_2, *PEVT_IML_iSCSI_LINK_DOWN_18_2;
    
//
// %1 Storage - Controller status changed to %2
//
typedef struct _evtIML_ARRAY_CTRL_FAILED_1_19_18
{
  BYTE slot;
  BYTE accelControllerIndex;
  BYTE controllerBoardStatus;
  BYTE controllerModel;
  BYTE accelTotalMemory;
  BYTE hoTrapFlags;
  char controllerHwLocation[1];
  //char controllerSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char controllerFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_ARRAY_CTRL_FAILED_1_19_18, *PEVT_IML_ARRAY_CTRL_FAILED_1_19_18;
    
//
// Drive Array Controller Failure (Chassis %1, Slot %2)
//
typedef struct _evtIML_ARRAY_CTRL_FAILED_2_19_19
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE slot;
  BYTE accelControllerIndex;
  BYTE controllerBoardStatus;
  BYTE controllerModel;
  BYTE accelTotalMemory;
  BYTE hoTrapFlags;
  char controllerHwLocation[1];
  //char controllerSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char controllerFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_ARRAY_CTRL_FAILED_2_19_19, *PEVT_IML_ARRAY_CTRL_FAILED_2_19_19;
    
//
// %1 Storage - Drive at Port %2 Box %3 Bay %4 status changed to %5
//
typedef struct _evtIML_ARRAY_DEVICE_FAILED_SAS_1_19_20
{
  BYTE hoTrapFlags;
  BYTE daCtrIndex;
  BYTE daPhyDrvCntlrIndex;
  BYTE daPhyDrvIndex;
  BYTE bay;
  BYTE box;
  BYTE daPhyDrvType;
  BYTE daPhyDrvFailureCode;
  BYTE daPhyDrvStatus;
  BYTE daPhyDrvBusNumber;
  char dacntlrHwLocation[1];
  //char daPhyDrvLocationString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char daPhyDrvModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char daPhyDrvFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char daPhyDrvSerialNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char portID[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char slot[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_ARRAY_DEVICE_FAILED_SAS_1_19_20, *PEVT_IML_ARRAY_DEVICE_FAILED_SAS_1_19_20;
    
//
// %1 Smart Array - SSD Wear Status Level %2: Port %3 Box %4 Bay %5
//
typedef struct _evtIML_ARRAY_SAS_SMART_WEAR_ERROR_1_19_21
{
  BYTE bay;
  BYTE box;
  BYTE phyContorllerIndex;
  BYTE phyDriveIndex;
  BYTE phyDriveType;
  BYTE phySSDWearStatus;
  BYTE controllerIndex;
  BYTE phyCondition;
  char portId[1];
  //char controllerHwLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char phyLocationString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char phyDriveModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char phyDriveFw[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char phyDriveSerialNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_ARRAY_SAS_SMART_WEAR_ERROR_1_19_21, *PEVT_IML_ARRAY_SAS_SMART_WEAR_ERROR_1_19_21;
    
//
// %1 Storage - Drive at Port %2 Box %3 Bay %4 status changed to predictive failure
//
typedef struct _evtIML_ARRAY_DEVICE_PREDICT_FAIL_SAS_1_19_22
{
  BYTE hoTrapFlags;
  BYTE daCtrIndex;
  BYTE daPhyDrvCntlrIndex;
  BYTE daPhyDrvIndex;
  BYTE bay;
  BYTE box;
  BYTE daPhyDrvType;
  BYTE daPhyDrvFailureCode;
  BYTE daPhyDrvStatus;
  BYTE daPhyDrvBusNumber;
  char dacntlrHwLocation[1];
  //char daPhyDrvLocationString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char daPhyDrvModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char daPhyDrvFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char daPhyDrvSerialNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char portID[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char slot[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_ARRAY_DEVICE_PREDICT_FAIL_SAS_1_19_22, *PEVT_IML_ARRAY_DEVICE_PREDICT_FAIL_SAS_1_19_22;
    
//
// %1 Storage - Controller Write cache status changed to %2
//
typedef struct _evtIML_IDA_ACCEL_STAT_CHG_19_23
{
  BYTE hoTrapFlags;
  BYTE daCtrIndex;
  BYTE daAccelCntrlIndex;
  BYTE daCntlrModel;
  DWORD daAccelTotalMemory;
  BYTE daAccelStatus;
  BYTE daAccelErrCode;
  char dacntlrHwLocation[1];
  //char daAccelSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IDA_ACCEL_STAT_CHG_19_23, *PEVT_IML_IDA_ACCEL_STAT_CHG_19_23;
    
//
// %1 Smart Array - Drive could not be authenticated as genuine drive. Smart Array will not control the LEDs: Port %2 Box %3 Bay %4
//
typedef struct _evtIML_CARRIER_AUTH_FAILURE_19_24
{
  BYTE hoTrapFlags;
  BYTE daCtrIndex;
  BYTE daPhyDrvCntlrIndex;
  BYTE daPhyDrvIndex;
  BYTE bay;
  BYTE box;
  BYTE daPhyDrvType;
  BYTE daPhyDrvFailureCode;
  BYTE daPhyDrvStatus;
  BYTE daPhyDrvBusNumber;
  char dacntlrHwLocation[1];
  //char daPhyDrvLocationString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char daPhyDrvModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char daPhyDrvFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char daPhyDrvSerialNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char portID[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char slot[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_CARRIER_AUTH_FAILURE_19_24, *PEVT_IML_CARRIER_AUTH_FAILURE_19_24;
    
//
// %1 Storage - Drive at %2 status changed to %3 (AMS)
//
typedef struct _evtIML_PHY_DRIVE_STATUS_19_30
{
  BYTE hoTrapFlags;
  BYTE sasHbaIndex;
  BYTE phyDriveHbaIndex;
  BYTE phyDriveIndex;
  BYTE phyDriveStatus;
  BYTE phyDriveType;
  char hbaHwLocation[1];
  //char phyDriveLocationString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char phyDriveModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char phyDriveFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char phyDriveSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char phyDriveSasAddress[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PHY_DRIVE_STATUS_19_30, *PEVT_IML_PHY_DRIVE_STATUS_19_30;
    
//
// Solid state disk wear status is now %1 for drive at location %2 connected to controller in %3.
//
typedef struct _evtIML_SAS_PHY_DRIVE_WEAR_STATUS_CHANGE_19_31
{
  BYTE hoTrapFlags;
  BYTE sasHbaIndex;
  BYTE phyDriveHbaIndex;
  BYTE phyDriveIndex;
  BYTE phyDriveType;
  BYTE phyDriveSSDWearStatus;
  char hbaHwLocation[1];
  //char phyDriveLocationString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char phyDriveModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char phyDriveFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char phyDriveSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char phyDriveSasAddress[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_SAS_PHY_DRIVE_WEAR_STATUS_CHANGE_19_31, *PEVT_IML_SAS_PHY_DRIVE_WEAR_STATUS_CHANGE_19_31;
    
//
// Embedded SATA Storage - Drive at %1 status changed to %2
//
typedef struct _evtIML_IDE_ATA_DISK_STATUS_CHANGE_19_32
{
  BYTE hostTrapFlag;
  BYTE diskControllerIndex;
  BYTE diskIndex;
  BYTE status;
  BYTE diskChannel;
  BYTE diskNumber;
  char modelNumber[1];
  //char firmwareRevision[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char serialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IDE_ATA_DISK_STATUS_CHANGE_19_32, *PEVT_IML_IDE_ATA_DISK_STATUS_CHANGE_19_32;
    
//
// %1 Storage - Volume %2 status changed to %3
//
typedef struct _evtIML_IDA_LOG_DRV_STATUS_CHANGE_19_33
{
  BYTE hoTrapFlags;
  BYTE daCtrIndex;
  BYTE daLogDrvCntrlIndex;
  BYTE daLogDrvIndex;
  BYTE daLogDrvStatus;
  char daCtrlHwLoc[1];
  //char daLogDrvIndexImlMapping[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IDA_LOG_DRV_STATUS_CHANGE_19_33, *PEVT_IML_IDA_LOG_DRV_STATUS_CHANGE_19_33;
    
//
// %1 Storage - Controller write cache data has been lost
//
typedef struct _evtIML_IDA_ACCEL_BADDATA_19_35
{
  BYTE daCtrIndex;
  BYTE daAccelCntlrIndex;
  BYTE daCntlrModel;
  DWORD daAccelTotalMemory;
  char daCntlrHwLocation[1];
  //char daAccelSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IDA_ACCEL_BADDATA_19_35, *PEVT_IML_IDA_ACCEL_BADDATA_19_35;
    
//
// %1 Smart Array - Cache module board backup power source status is failed
//
typedef struct _evtIML_IDA_ACCEL_BATT_FAILED_19_36
{
  BYTE daCtrIndex;
  BYTE daAccelCntlrIndex;
  BYTE daCntlrModel;
  DWORD daAccelTotalMemory;
  char daCntlrHwLocation[1];
  //char daAccelSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IDA_ACCEL_BATT_FAILED_19_36, *PEVT_IML_IDA_ACCEL_BATT_FAILED_19_36;
    
//
// Storage system fan status changed to %1 for location %2 connected to controller %3
//
typedef struct _evtIML_STSYS_FAN_STAT_CHG_19_40
{
  BYTE hoTrapFlags;
  BYTE ssBoxCntlrIndex;
  BYTE ssBoxBusIndex;
  BYTE ssBoxFanStatus;
  char ssBoxCntlrHwLocation[1];
  //char ssBoxVendor[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxLocationString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_STSYS_FAN_STAT_CHG_19_40, *PEVT_IML_STSYS_FAN_STAT_CHG_19_40;
    
//
// Storage system temperature status changed to %1 for location %2 connected to controller %3.
//
typedef struct _evtIML_STSYS_TEMP_STAT_CHG_19_41
{
  BYTE hoTrapFlags;
  BYTE ssBoxCntlrIndex;
  BYTE ssBoxBusIndex;
  BYTE ssBoxTempStatus;
  char ssBoxCntlrHwLocation[1];
  //char ssBoxVendor[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxLocationString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_STSYS_TEMP_STAT_CHG_19_41, *PEVT_IML_STSYS_TEMP_STAT_CHG_19_41;
    
//
// Storage system power supply status changed to %1 for location %2 connected to controller %3
//
typedef struct _evtIML_STSYS_PWR_STAT_CHG_19_42
{
  BYTE hoTrapFlags;
  BYTE ssBoxCntlrIndex;
  BYTE ssBoxBusIndex;
  BYTE ssBoxFltTolPwrSupplyStatus;
  char ssBoxCntlrHwLocation[1];
  //char ssBoxVendor[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxLocationString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_STSYS_PWR_STAT_CHG_19_42, *PEVT_IML_STSYS_PWR_STAT_CHG_19_42;
    
//
// Storage system connection status changed to %1 for location %2 connected to controller %3
//
typedef struct _evtIML_STSYS_CONN_STAT_CHG_19_43
{
  BYTE hoTrapFlags;
  BYTE ssBoxCntlrIndex;
  BYTE ssBoxBusIndex;
  BYTE ssBoxConnectionStatus;
  char ssBoxCntlrHwLocation[1];
  //char ssBoxVendor[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxLocationString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxTargetSasAddress[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char ssBoxLocalManageIpAddress[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_STSYS_CONN_STAT_CHG_19_43, *PEVT_IML_STSYS_CONN_STAT_CHG_19_43;
    
//
// %1 Smart Array - Spare status is changed to %2
//
typedef struct _evtIML_IDA_SPR_STAT_CHG_19_44
{
  BYTE hoTrapFlags;
  BYTE daCtrIndex;
  BYTE daSpareCntlrIndex;
  BYTE daSparePhyDrvIndex;
  BYTE daSpareStatus;
  BYTE daSpareBusNumber;
  char daCntlrHwLocation[1];
  //char daSpareLocationString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IDA_SPR_STAT_CHG_19_44, *PEVT_IML_IDA_SPR_STAT_CHG_19_44;
    
//
// %1 Storage - Drive at Port %2 Box %3 Bay %4 is %5
//
typedef struct _evtIML_ARRAY_DEVICE_DRIVE_INSERTED_REMOVED_19_47
{
  BYTE hoTrapFlags;
  BYTE daCtrIndex;
  BYTE daPhyDrvCntlrIndex;
  BYTE daPhyDrvIndex;
  BYTE bay;
  BYTE box;
  BYTE daPhyDrvType;
  BYTE daPhyDrvFailureCode;
  BYTE daPhyDrvStatus;
  BYTE daPhyDrvBusNumber;
  char dacntlrHwLocation[1];
  //char daPhyDrvLocationString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char daPhyDrvModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char daPhyDrvFWRev[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char daPhyDrvSerialNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char portID[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char slot[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_ARRAY_DEVICE_DRIVE_INSERTED_REMOVED_19_47, *PEVT_IML_ARRAY_DEVICE_DRIVE_INSERTED_REMOVED_19_47;
    
//
// Embedded SATA Storage - Drive at %1 status changed to %2
//
typedef struct _evtIML_IDE_ATA_DISK_STATUS_CHANGE2_19_48
{
  BYTE hostTrapFlag;
  BYTE diskControllerIndex;
  BYTE diskIndex;
  BYTE status;
  BYTE diskChannel;
  char modelNumber[1];
  //char firmwareRevision[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char serialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char diskLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IDE_ATA_DISK_STATUS_CHANGE2_19_48, *PEVT_IML_IDE_ATA_DISK_STATUS_CHANGE2_19_48;
    
//
// Solid state disk wear status is now %1 for drive at location %2.
//
typedef struct _evtIML_IDE_ATA_DISK_DRIVE_WEAR_STATUS_CHANGE2_19_51
{
  BYTE hostTrapFlag;
  BYTE diskControllerIndex;
  BYTE diskIndex;
  BYTE wearStatus;
  BYTE diskChannel;
  char modelNumber[1];
  //char firmwareRevision[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char serialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char diskLocation[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IDE_ATA_DISK_DRIVE_WEAR_STATUS_CHANGE2_19_51, *PEVT_IML_IDE_ATA_DISK_DRIVE_WEAR_STATUS_CHANGE2_19_51;
    
//
// Solid State SATA Disk Wear Status changed to %1
//
typedef struct _evtIML_IDE_SATA_DISK_WEAR_STATUS_CHANGE_19_82
{
  BYTE hostTrapFlag;
  BYTE diskControllerIndex;
  BYTE diskIndex;
  BYTE wearstatus;
  BYTE diskChannel;
  BYTE diskNumber;
  char modelNumber[1];
  //char firmwareRevision[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char serialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IDE_SATA_DISK_WEAR_STATUS_CHANGE_19_82, *PEVT_IML_IDE_SATA_DISK_WEAR_STATUS_CHANGE_19_82;
    
//
// Server Critical Fault (Service Information: %1) %2
//
typedef struct _evtIML_UNCORR_CRITICAL_FAULT_20_7
{
  BYTE powerFailureIndex;
  BYTE powerFailureType;
  BYTE powerFailureArea;
  BYTE powerFailureDeviceBitMap;
  BYTE powerFailureRepairSteps;
  BYTE actionStr;
  char powerFailureGroupString[1];
  //char imlString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_UNCORR_CRITICAL_FAULT_20_7, *PEVT_IML_UNCORR_CRITICAL_FAULT_20_7;
    
//
// Enclosure Induced Event (Service Information: Enclosure Power Loss, %1)
//
typedef struct _evtIML_UNRECOV_INPUT_PWR_ERROR_20_8
{
  BYTE powerFailureIndex;
  BYTE powerFailureType;
  BYTE powerFailureArea;
  BYTE powerFailureDeviceBitMap;
  BYTE powerFailureRepairSteps;
  char powerFailureGroupString[1];
  //char imlString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_UNRECOV_INPUT_PWR_ERROR_20_8, *PEVT_IML_UNRECOV_INPUT_PWR_ERROR_20_8;
    
//
// Server Critical Fault (Service Information: %1) %2
//
typedef struct _evtIML_INPUT_POWER_LOSS_20_10
{
  BYTE powerFailureIndex;
  BYTE powerFailureType;
  BYTE powerFailureArea;
  BYTE powerFailureDeviceBitMap;
  BYTE powerFailureRepairSteps;
  BYTE actionStr;
  char powerFailureGroupString[1];
  //char imlString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_INPUT_POWER_LOSS_20_10, *PEVT_IML_INPUT_POWER_LOSS_20_10;
    
//
// Server Critical Fault (Service Information: %1) %2
//
typedef struct _evtIML_POWER_ON_FAULT_20_11
{
  BYTE powerFailureIndex;
  BYTE powerFailureType;
  BYTE powerFailureArea;
  BYTE powerFailureDeviceBitMap;
  BYTE powerFailureRepairSteps;
  BYTE actionStr;
  char powerFailureGroupString[1];
  //char imlString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_POWER_ON_FAULT_20_11, *PEVT_IML_POWER_ON_FAULT_20_11;
    
//
// Server Critical Fault (Service Information: %1) %2
//
typedef struct _evtIML_RUNTIME_FAULT_20_12
{
  BYTE powerFailureIndex;
  BYTE powerFailureType;
  BYTE powerFailureArea;
  BYTE powerFailureDeviceBitMap;
  BYTE powerFailureRepairSteps;
  BYTE actionStr;
  char powerFailureGroupString[1];
  //char imlString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_RUNTIME_FAULT_20_12, *PEVT_IML_RUNTIME_FAULT_20_12;
    
//
// An uncorrectable error was detected (Processor: %1, Error Component: %2, Error Status: %3, Error Address Low: %4, Error Address High: %5, Overflow: %6)
//
typedef struct _evtIML_UNCORR_ERROR_20_14
{
  BYTE processorNumber;
  BYTE errorComponent;
  DWORD errorStatus;
  DWORD errorAddressLow;
  DWORD errorAddressHigh;
  BYTE overflow;
} EVT_IML_UNCORR_ERROR_20_14, *PEVT_IML_UNCORR_ERROR_20_14;
    
//
// An uncorrectable error was detected (Processor: %1, Error Component: 2P ALI, Link: %2, Error Status: %3, Error Address Low: %4, Error Address High: %5, Overflow: %6)
//
typedef struct _evtIML_UNCORR_ERROR_2P_ALI_WITH_LINK_20_15
{
  BYTE processorNumber;
  WORD link;
  DWORD errorStatus;
  DWORD errorAddressLow;
  DWORD errorAddressHigh;
  BYTE overflow;
} EVT_IML_UNCORR_ERROR_2P_ALI_WITH_LINK_20_15, *PEVT_IML_UNCORR_ERROR_2P_ALI_WITH_LINK_20_15;
    
//
// An uncorrectable error was detected (Processor: %1, Error Component: %2, Root complex: %3, Error Status: %4, Error Address Low: %5, Error Address High: %6, Overflow: %7)
//
typedef struct _evtIML_UNCORR_ERROR_WITH_ROOT_COMPLEX_20_16
{
  BYTE processorNumber;
  BYTE errorComponent;
  WORD rootComplex;
  DWORD errorStatus;
  DWORD errorAddressLow;
  DWORD errorAddressHigh;
  BYTE overflow;
} EVT_IML_UNCORR_ERROR_WITH_ROOT_COMPLEX_20_16, *PEVT_IML_UNCORR_ERROR_WITH_ROOT_COMPLEX_20_16;
    
//
// An uncorrectable error was detected (Processor: %1, Error Component: 2P CCIX, Link: %2, Overflow: %3)
//
typedef struct _evtIML_UNCORR_ERROR_2P_CCIX_WITH_LINK_20_17
{
  BYTE processorNumber;
  WORD link;
  BYTE overflow;
} EVT_IML_UNCORR_ERROR_2P_CCIX_WITH_LINK_20_17, *PEVT_IML_UNCORR_ERROR_2P_CCIX_WITH_LINK_20_17;
    
//
// An uncorrectable error was detected (Processor: %1, Error Component: PCIe HB RASDP, Root complex: %2, UE Location Register: %3, UE Report Register: %4, UE Address: %5, Overflow: %6)
//
typedef struct _evtIML_UNCORR_ERROR_RASDP_WITH_ROOT_COMPLEX_20_18
{
  BYTE processorNumber;
  WORD rootComplex;
  DWORD uELocationRegister;
  DWORD uEReportRegister;
  DWORD uEAddress;
  BYTE overflow;
} EVT_IML_UNCORR_ERROR_RASDP_WITH_ROOT_COMPLEX_20_18, *PEVT_IML_UNCORR_ERROR_RASDP_WITH_ROOT_COMPLEX_20_18;
    
//
// An uncorrectable error was detected (Processor: %1, Error Component: %2, Error Sub-component: %3, Overflow: %4)
//
typedef struct _evtIML_UNCORR_ERROR_MISC_20_19
{
  BYTE processorNumber;
  BYTE errorComponent;
  BYTE errorSubComponent;
  BYTE overflow;
} EVT_IML_UNCORR_ERROR_MISC_20_19, *PEVT_IML_UNCORR_ERROR_MISC_20_19;
    
//
// Runtime mezzanine card fault occurred(Service information: %1) %2
//
typedef struct _evtIML_MEZZANINE_CARD_FAULT_20_22
{
  BYTE mezzanineCardFailureIndex;
  BYTE mezzanineCardFailureType;
  BYTE mezzanineCardFailureArea;
  BYTE mezzanineFailureDeviceBitMap;
  BYTE mezzanineFailureRepairSteps;
  BYTE actionStr;
  char mezzanineFailureGroupString[1];
  //char imlString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_MEZZANINE_CARD_FAULT_20_22, *PEVT_IML_MEZZANINE_CARD_FAULT_20_22;
    
//
// The server %1 error occurred with failure status %2 .
//
typedef struct _evtIML_CPU_ERROR_CODE_20_305
{
  BYTE failure_type;
  BYTE failure_code;
} EVT_IML_CPU_ERROR_CODE_20_305, *PEVT_IML_CPU_ERROR_CODE_20_305;
    
//
// Firmware flashed (%1)
//
typedef struct _evtIML_FIRMWARE_FLASHED_32_2
{
  char fWVersion[1];
} EVT_IML_FIRMWARE_FLASHED_32_2, *PEVT_IML_FIRMWARE_FLASHED_32_2;
    
//
// #ILO detected invalid %1 firmware.
//
typedef struct _evtIML_FI_32_3
{
  BYTE firmwareType;
} EVT_IML_FI_32_3, *PEVT_IML_FI_32_3;
    
//
// #ILO was unable to automatically repair the %1 firmware.
//
typedef struct _evtIML_FI_REP_FAIL_32_4
{
  BYTE firmwareName;
} EVT_IML_FI_REP_FAIL_32_4, *PEVT_IML_FI_REP_FAIL_32_4;
    
//
// Firmware recovery is requested by %1
//
typedef struct _evtIML_FW_RECOVERY_REQUEST_32_8
{
  char userName[1];
} EVT_IML_FW_RECOVERY_REQUEST_32_8, *PEVT_IML_FW_RECOVERY_REQUEST_32_8;
    
//
// BIOS Firmware update is not supported for Processor %1. Module does not support required PLDM protocol for update.
//
typedef struct _evtIML_BIOS_FIRMWARE_UPDATE_32_13
{
  BYTE procNum;
} EVT_IML_BIOS_FIRMWARE_UPDATE_32_13, *PEVT_IML_BIOS_FIRMWARE_UPDATE_32_13;
    
//
// BIOS version mismatch: %1
//
typedef struct _evtIML_BIOS_VERSION_MISMATCH_32_14
{
  char msgArgs[1];
} EVT_IML_BIOS_VERSION_MISMATCH_32_14, *PEVT_IML_BIOS_VERSION_MISMATCH_32_14;
    
//
// IML Cleared (%1 user: %2)
//
typedef struct _evtIML_MAINT_IML_CLEARED_33_1
{
  char bMC[1];
  //char userName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_MAINT_IML_CLEARED_33_1, *PEVT_IML_MAINT_IML_CLEARED_33_1;
    
//
// Maintenance note: %1
//
typedef struct _evtIML_MAINT_NOTE_33_2
{
  char text[1];
} EVT_IML_MAINT_NOTE_33_2, *PEVT_IML_MAINT_NOTE_33_2;
    
//
// One-button secure erase completed. User data erase status: %1.  System settings erase status: %2.
//
typedef struct _evtIML_SECURE_SYSTEM_ERASE_STATUS_33_3
{
  BYTE userdataStatus;
  BYTE systemStatus;
} EVT_IML_SECURE_SYSTEM_ERASE_STATUS_33_3, *PEVT_IML_SECURE_SYSTEM_ERASE_STATUS_33_3;
    
//
// %1 log cleared by: %2
//
typedef struct _evtSL_SECURITY_LOG_CLEARED_33_4
{
  BYTE logindex;
  char userName[1];
} EVT_SL_SECURITY_LOG_CLEARED_33_4, *PEVT_SL_SECURITY_LOG_CLEARED_33_4;
    
//
// Active Health System log cleared by: %1.
//
typedef struct _evtSL_AHS_CLEARED_33_6
{
  char userName[1];
} EVT_SL_AHS_CLEARED_33_6, *PEVT_SL_AHS_CLEARED_33_6;
    
//
// %1 Inadequate Power To Power On: %2 (Enclosure Serial Number %3, Bay %4)
//
typedef struct _evtIML_ENCL_INADEQUATE_POWER_ENC_SERIAL_34_27
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE blade;
  BYTE reason;
  char chassisName[1];
} EVT_IML_ENCL_INADEQUATE_POWER_ENC_SERIAL_34_27, *PEVT_IML_ENCL_INADEQUATE_POWER_ENC_SERIAL_34_27;
    
//
// %1 Inadequate Power To Power On: %2 (Enclosure Address %3, Slot %4)
//
typedef struct _evtIML_ENCL_INADEQUATE_POWER_ENC_ADDR_34_28
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE blade;
  BYTE reason;
  char chassisName[1];
} EVT_IML_ENCL_INADEQUATE_POWER_ENC_ADDR_34_28, *PEVT_IML_ENCL_INADEQUATE_POWER_ENC_ADDR_34_28;
    
//
// %1 Rack Name Changed (Enclosure Serial Number %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_RCK_NAME_CHG_1_34_29
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_RCK_NAME_CHG_1_34_29, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_RCK_NAME_CHG_1_34_29;
    
//
// %1 Rack Name Changed (Enclosure Address %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_RCK_NAME_CHG_2_34_30
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_RCK_NAME_CHG_2_34_30, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_RCK_NAME_CHG_2_34_30;
    
//
// %1 Name Changed (Enclosure Serial Number %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_NAME_CHG1_34_31
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_NAME_CHG1_34_31, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_NAME_CHG1_34_31;
    
//
// %1 Name Changed (Enclosure Address %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_NAME_CHG2_34_32
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_NAME_CHG2_34_32, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_NAME_CHG2_34_32;
    
//
// %1 Service Change (Enclosure Serial Number %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_SERVICE_CHG_1_34_33
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_SERVICE_CHG_1_34_33, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_SERVICE_CHG_1_34_33;
    
//
// %1 Service Change (Enclosure Address %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_SERVICE_CHG_2_34_34
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_SERVICE_CHG_2_34_34, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_SERVICE_CHG_2_34_34;
    
//
// %1 Rack Name Conflict (Enclosure Serial Number %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_NAME_CONFLICT_1_34_35
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_NAME_CONFLICT_1_34_35, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_NAME_CONFLICT_1_34_35;
    
//
// %1 Rack Name Conflict (Enclosure Address %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_NAME_CONFLICT_2_34_36
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_NAME_CONFLICT_2_34_36, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_NAME_CONFLICT_2_34_36;
    
//
// %1 Rack Unique ID Changed (Enclosure Serial Number %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_UID_CHG_1_34_37
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_UID_CHG_1_34_37, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_UID_CHG_1_34_37;
    
//
// %1 Rack Unique ID Changed (Enclosure Address %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_UID_CHG_2_34_38
{
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_UID_CHG_2_34_38, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_UID_CHG_2_34_38;
    
//
// %1 LAN Settings Changed (Enclosure Serial Number %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_LAN_CHG_1_34_39
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_LAN_CHG_1_34_39, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_LAN_CHG_1_34_39;
    
//
// %1 LAN Settings Changed (Enclosure Address %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_LAN_CHG_2_34_40
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_LAN_CHG_2_34_40, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_LAN_CHG_2_34_40;
    
//
// %1 UID LED State Changed (Enclosure Serial Number %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_UID_LED_CHG_1_34_41
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_UID_LED_CHG_1_34_41, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_UID_LED_CHG_1_34_41;
    
//
// %1 UID LED State Changed (Enclosure Address %2)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_UID_LED_CHG_2_34_42
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_UID_LED_CHG_2_34_42, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_UID_LED_CHG_2_34_42;
    
//
// %1 Rack Infrastructure Changed (Enclosure Serial Number %2, Type %3)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_CHG_1_34_43
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_CHG_1_34_43, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_CHG_1_34_43;
    
//
// %1 Rack Infrastructure Changed (Enclosure Address %2, Type %3)
//
typedef struct _evtIML_ENCL_RACK_INFRASTRUCTURE_CHG_2_34_44
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE type;
  char chassisName[1];
} EVT_IML_ENCL_RACK_INFRASTRUCTURE_CHG_2_34_44, *PEVT_IML_ENCL_RACK_INFRASTRUCTURE_CHG_2_34_44;
    
//
// Chassis Enclosure Serial Number %1 requires minimum firmware revision 0x%2.0x%3. It is currently 0x%4.0x%5.
//
typedef struct _evtIML_ENCL_INFRASTRUCTURE_FIRMWARE_MISMATCH_1_34_45
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE currentMajor;
  BYTE currentMinor;
  BYTE requiredMajor;
  BYTE requiredMinor;
  WORD iCMBNumber;
  char chassisName[1];
} EVT_IML_ENCL_INFRASTRUCTURE_FIRMWARE_MISMATCH_1_34_45, *PEVT_IML_ENCL_INFRASTRUCTURE_FIRMWARE_MISMATCH_1_34_45;
    
//
// Chassis Enclosure Address %1 requires minimum firmware revision 0x%2.0x%3. It is currently 0x%4.0x%5.
//
typedef struct _evtIML_ENCL_INFRASTRUCTURE_FIRMWARE_MISMATCH_2_34_46
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE currentMajor;
  BYTE currentMinor;
  BYTE requiredMajor;
  BYTE requiredMinor;
  WORD iCMBNumber;
  char chassisName[1];
} EVT_IML_ENCL_INFRASTRUCTURE_FIRMWARE_MISMATCH_2_34_46, *PEVT_IML_ENCL_INFRASTRUCTURE_FIRMWARE_MISMATCH_2_34_46;
    
//
// %1 Power Request Denied: %2 %3 (Enclosure Serial Number %4, Bay %5)
//
typedef struct _evtIML_ENCL_POWER_REQUEST_DENIED_1_34_47
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE blade;
  BYTE reason;
  char chassisName[1];
  //char enclosureErrorString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_ENCL_POWER_REQUEST_DENIED_1_34_47, *PEVT_IML_ENCL_POWER_REQUEST_DENIED_1_34_47;
    
//
// %1 Power Request Denied: %2 (Enclosure Address %3, Slot %4)
//
typedef struct _evtIML_ENCL_POWER_REQUEST_DENIED_2_34_48
{
  BYTE chassisType;
  BYTE chassisId;
  BYTE chassisPort;
  BYTE blade;
  BYTE reason;
  char chassisName[1];
} EVT_IML_ENCL_POWER_REQUEST_DENIED_2_34_48, *PEVT_IML_ENCL_POWER_REQUEST_DENIED_2_34_48;
    
//
// Mutual Authentication of iLO and secure element (%1)
//
typedef struct _evtIML_MUTUAL_AUTH_ILO_SECURE_ELM_35_17696
{
  DWORD status;
} EVT_IML_MUTUAL_AUTH_ILO_SECURE_ELM_35_17696, *PEVT_IML_MUTUAL_AUTH_ILO_SECURE_ELM_35_17696;
    
//
// #ILO %1 MAC address not programmed.
//
typedef struct _evtIML_MAC_MISSING_IN_EEPROM_35_17756
{
  char interface[1];
} EVT_IML_MAC_MISSING_IN_EEPROM_35_17756, *PEVT_IML_MAC_MISSING_IN_EEPROM_35_17756;
    
//
// HPM authentication failed. Reason: %1, component integrity policy set as %2.
//
typedef struct _evtIML_HPM_AUTH_BIND_FAIL_35_17758
{
  char reason[1];
  //char policy[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_HPM_AUTH_BIND_FAIL_35_17758, *PEVT_IML_HPM_AUTH_BIND_FAIL_35_17758;
    
//
// Temperature sensor fallback status has been reset to default. Reason: %1.
//
typedef struct _evtIML_FALLBACK_TEMP_SENSOR_STATUS_35_17771
{
  char reason[1];
} EVT_IML_FALLBACK_TEMP_SENSOR_STATUS_35_17771, *PEVT_IML_FALLBACK_TEMP_SENSOR_STATUS_35_17771;
    
//
// Processor(s) Operating at Reduced Performance Level Due to a Low Power Cap
//
typedef struct _evtIML_PCAP_REDUCED_PERF_39_1
{
  BYTE fw_ver;
} EVT_IML_PCAP_REDUCED_PERF_39_1, *PEVT_IML_PCAP_REDUCED_PERF_39_1;
    
//
// Power Cap Cannot Be Reached With Current System Configuration (Power Cap %1W)
//
typedef struct _evtIML_PCAP_UNREACHABLE_WITH_CAP_VALUE_39_3
{
  WORD currentPowerCap;
} EVT_IML_PCAP_UNREACHABLE_WITH_CAP_VALUE_39_3, *PEVT_IML_PCAP_UNREACHABLE_WITH_CAP_VALUE_39_3;
    
//
// Power allocation not optimized. Increased power allocation requested. Server performance is not degraded
//
typedef struct _evtIML_PCAP_FAST_CAP_SET_FAILURE_39_4
{
  char chassisName[1];
  //char cpqHoGUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PCAP_FAST_CAP_SET_FAILURE_39_4, *PEVT_IML_PCAP_FAST_CAP_SET_FAILURE_39_4;
    
//
// Drive at Box %1, Bay %2, does not support power state configurations.
//
typedef struct _evtIML_PS_NPSS_UNSUPPORTED_39_5
{
  BYTE box;
  BYTE bay;
} EVT_IML_PS_NPSS_UNSUPPORTED_39_5, *PEVT_IML_PS_NPSS_UNSUPPORTED_39_5;
    
//
// Power Cap for Drive on Box %1 Bay %2 set to power state %3.
//
typedef struct _evtIML_APOLLO_POWER_STATE_CHANGED_39_7
{
  BYTE box;
  BYTE bay;
  BYTE ps;
} EVT_IML_APOLLO_POWER_STATE_CHANGED_39_7, *PEVT_IML_APOLLO_POWER_STATE_CHANGED_39_7;
    
//
// Boot From Flash Error (%1)
//
typedef struct _evtIML_FM_BOOT_FROM_FLASH_ERROR_40_1
{
  char text[1];
} EVT_IML_FM_BOOT_FROM_FLASH_ERROR_40_1, *PEVT_IML_FM_BOOT_FROM_FLASH_ERROR_40_1;
    
//
// A read error occurred on the Flash Media in Slot %1 of a USB storage device attached to the system
//
typedef struct _evtIML_FM_BOOT_FROM_FLASH_READ_ERROR_40_2
{
  BYTE hostTrapFlag;
  BYTE usbPortIndex;
  BYTE usbPortDeviceLastSlotWithError;
  char usbPortDeviceName[1];
  //char usbPortDeviceModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceFWVersion[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDevicePartNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceReadErrorCount[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceReadThreshold[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_FM_BOOT_FROM_FLASH_READ_ERROR_40_2, *PEVT_IML_FM_BOOT_FROM_FLASH_READ_ERROR_40_2;
    
//
// A write error occurred on the Flash Media in Slot %1 of a USB storage device attached to the system
//
typedef struct _evtIML_FM_BOOT_FROM_FLASH_WRITE_ERROR_40_3
{
  BYTE hostTrapFlag;
  BYTE usbPortIndex;
  BYTE usbPortDeviceLastSlotWithError;
  char usbPortDeviceName[1];
  //char usbPortDeviceModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceFWVersion[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDevicePartNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceWriteErrorCount[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceWriteThreshold[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_FM_BOOT_FROM_FLASH_WRITE_ERROR_40_3, *PEVT_IML_FM_BOOT_FROM_FLASH_WRITE_ERROR_40_3;
    
//
// Redundancy is lost on a USB storage device attached to the system. Flash Media in Slot %1 has failed
//
typedef struct _evtIML_FM_BOOT_FROM_FLASH_REDUNDANCY_LOST_40_4
{
  BYTE hostTrapFlag;
  BYTE usbPortIndex;
  BYTE usbPortDeviceFailedSlot;
  char usbPortDeviceName[1];
  //char usbPortDeviceModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceFWVersion[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDevicePartNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_FM_BOOT_FROM_FLASH_REDUNDANCY_LOST_40_4, *PEVT_IML_FM_BOOT_FROM_FLASH_REDUNDANCY_LOST_40_4;
    
//
// Sync operation to restore redundancy failed on a USB storage device attached to the system
//
typedef struct _evtIML_FM_BOOT_FROM_FLASH_SYC_FAILED_40_5
{
  BYTE hostTrapFlag;
  BYTE usbPortIndex;
  char usbPortDeviceName[1];
  //char usbPortDeviceModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceFWVersion[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDevicePartNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_FM_BOOT_FROM_FLASH_SYC_FAILED_40_5, *PEVT_IML_FM_BOOT_FROM_FLASH_SYC_FAILED_40_5;
    
//
// Redundancy is restored on a USB storage device attached to the system.
//
typedef struct _evtIML_FM_BOOT_FROM_FLASH_REDUNDANCY_RESTORED_40_7
{
  BYTE hostTrapFlag;
  BYTE usbPortIndex;
  char usbPortDeviceName[1];
  //char usbPortDeviceModel[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceFWVersion[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDeviceSerialNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char usbPortDevicePartNumber[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_FM_BOOT_FROM_FLASH_REDUNDANCY_RESTORED_40_7, *PEVT_IML_FM_BOOT_FROM_FLASH_REDUNDANCY_RESTORED_40_7;
    
//
// Improperly seated or missing device (%1, %2)
//
typedef struct _evtIML_IL_DEV_NOT_SEATED_OR_MISSING_41_1
{
  BYTE interlockFailureIndex;
  BYTE interlockFaultType;
  BYTE interlockSNMPFailureType;
  char interlockFailureDeviceName[1];
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IL_DEV_NOT_SEATED_OR_MISSING_41_1, *PEVT_IML_IL_DEV_NOT_SEATED_OR_MISSING_41_1;
    
//
// Installed State  (%1)
//
typedef struct _evtIML_IL_DEV_INSTALLED_STATE_41_2
{
  BYTE interlockFailureIndex;
  BYTE interlockFaultType;
  BYTE interlockSNMPFailureType;
  char interlockFailureDeviceName[1];
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IL_DEV_INSTALLED_STATE_41_2, *PEVT_IML_IL_DEV_INSTALLED_STATE_41_2;
    
//
// Supported State  (%1)
//
typedef struct _evtIML_IL_DEV_SUPPORTED_STATE_41_3
{
  BYTE interlockFailureIndex;
  BYTE interlockFaultType;
  BYTE interlockSNMPFailureType;
  char interlockFailureDeviceName[1];
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IL_DEV_SUPPORTED_STATE_41_3, *PEVT_IML_IL_DEV_SUPPORTED_STATE_41_3;
    
//
// Backplane type  (%1)
//
typedef struct _evtIML_IL_DEV_BACKPLANE_TYPE_41_4
{
  BYTE interlockFailureIndex;
  BYTE interlockFaultType;
  BYTE interlockSNMPFailureType;
  char interlockFailureDeviceName[1];
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IL_DEV_BACKPLANE_TYPE_41_4, *PEVT_IML_IL_DEV_BACKPLANE_TYPE_41_4;
    
//
// Slot Number  (%1)
//
typedef struct _evtIML_IL_DEV_SLOT_NUMBER_41_5
{
  BYTE interlockFailureIndex;
  BYTE interlockFaultType;
  BYTE interlockSNMPFailureType;
  char interlockFailureDeviceName[1];
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_IL_DEV_SLOT_NUMBER_41_5, *PEVT_IML_IL_DEV_SLOT_NUMBER_41_5;
    
//
// Unsupported DIMM Configuration Detected - Installed DIMM configuration does NOT support configured AMP Mode. System will operate in Advanced ECC Mode. (Major Code:%1 Minor Code:%2).
//
typedef struct _evtIML_DIMM_CFG_ERR_NOT_SUPP_AMP_MODE_50_521
{
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_ERR_NOT_SUPP_AMP_MODE_50_521, *PEVT_IML_DIMM_CFG_ERR_NOT_SUPP_AMP_MODE_50_521;
    
//
// Unsupported DIMM Configuration Detected - Installed DIMMs could not support the currently configured interleave mode. (Major Code:%1, Minor Code:%2).
//
typedef struct _evtIML_DIMM_CFG_INTERLEAVE_MODE_50_528
{
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_INTERLEAVE_MODE_50_528, *PEVT_IML_DIMM_CFG_INTERLEAVE_MODE_50_528;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 DIMM %2. The DIMM does not support ECC.  (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_DIMM_CFG_NO_ECC_50_529
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_NO_ECC_50_529, *PEVT_IML_DIMM_CFG_NO_ECC_50_529;
    
//
// Processor UPI Initialization Error. A processor UPI initialization error was detected. %1 (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_CPU_UPI_INIT_ERROR_50_530
{
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_CPU_UPI_INIT_ERROR_50_530, *PEVT_IML_CPU_UPI_INIT_ERROR_50_530;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 DIMM %2. The DIMM has more ranks than is supported by this system. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_DIMM_CFG_MAX_SYSTEM_RANKS_50_531
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_MAX_SYSTEM_RANKS_50_531, *PEVT_IML_DIMM_CFG_MAX_SYSTEM_RANKS_50_531;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 DIMM %2. The DIMM requires a frequency not supported by the system. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_DIMM_CFG_INVALID_FREQ_50_532
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_INVALID_FREQ_50_532, *PEVT_IML_DIMM_CFG_INVALID_FREQ_50_532;
    
//
// DIMM Initialization Error - Processor %1 DIMM %2. The identified processor and memory failed to initialize properly. %3 (Major Code:%4, Minor Code:%5).
//
typedef struct _evtIML_DIMM_CPU_INIT_ERROR_50_533
{
  BYTE processorNumber;
  BYTE dimmNumber;
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CPU_INIT_ERROR_50_533, *PEVT_IML_DIMM_CPU_INIT_ERROR_50_533;
    
//
// DIMM Initialization Error.  A fatal error was detected while initializing memory. %1 (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_DIMM_INIT_FATAL_ERROR_50_534
{
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_INIT_FATAL_ERROR_50_534, *PEVT_IML_DIMM_INIT_FATAL_ERROR_50_534;
    
//
// DIMM Initialization Error - Processor %1 DIMM %2. The identified processor and memory are operating at an incorrect voltage. %3 (Major Code:%4, Minor Code:%5).
//
typedef struct _evtIML_DIMM_INIT_VOLTAGE_50_535
{
  BYTE processorNumber;
  BYTE dimmNumber;
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_INIT_VOLTAGE_50_535, *PEVT_IML_DIMM_INIT_VOLTAGE_50_535;
    
//
// Memory Configuration Error - One or more of the installed processors has a total amount of memory installed which exceeds the amount supported by that processor. %1 (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_DIMM_AMOUNT_EXCEEDS_CPU_SUPPORT_50_537
{
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_AMOUNT_EXCEEDS_CPU_SUPPORT_50_537, *PEVT_IML_DIMM_AMOUNT_EXCEEDS_CPU_SUPPORT_50_537;
    
//
// UPI Initialization Error - A fatal UPI initialization error has been detected. %1 (Major Code: %2, Minor Code: %3).
//
typedef struct _evtIML_KTI_INIT_ERROR_50_544
{
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_KTI_INIT_ERROR_50_544, *PEVT_IML_KTI_INIT_ERROR_50_544;
    
//
// Unknown Initialization Error. The system has experienced a fatal initialization error. %1 (Major Code: %2, Minor Code: %3).
//
typedef struct _evtIML_UNKNOWN_MRC_ERROR_50_545
{
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_UNKNOWN_MRC_ERROR_50_545, *PEVT_IML_UNKNOWN_MRC_ERROR_50_545;
    
//
// DIMM Initialization Error - Processor %1 %2. The identified memory channel could not be properly trained and has been mapped out. The indicated DIMMs will not be available. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_CHANNEL_TRAIN_ERROR_WITHOUT_CHANNEL_NUMBER_50_547
{
  BYTE processorNumber;
  DWORD majorCode;
  DWORD minorCode;
  char dimmList[1];
} EVT_IML_CHANNEL_TRAIN_ERROR_WITHOUT_CHANNEL_NUMBER_50_547, *PEVT_IML_CHANNEL_TRAIN_ERROR_WITHOUT_CHANNEL_NUMBER_50_547;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 %2. DIMM population rule violation. The memory channel has been mapped out. The indicated DIMMs will not be available. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_DIMM_CFG_POP_ORDER_50_552
{
  BYTE processorNumber;
  DWORD majorCode;
  DWORD minorCode;
  char dimmList[1];
} EVT_IML_DIMM_CFG_POP_ORDER_50_552, *PEVT_IML_DIMM_CFG_POP_ORDER_50_552;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 DIMM %2. The identified DIMM is not supported in the system.  (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_DIMM_CFG_UNSUPPORTED_DIMM_50_553
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_UNSUPPORTED_DIMM_50_553, *PEVT_IML_DIMM_CFG_UNSUPPORTED_DIMM_50_553;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 %2. The number of installed DIMM ranks exceeds the number supported by the channel. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_DIMM_CFG_MAX_CHANNEL_RANKS_50_560
{
  BYTE processorNumber;
  DWORD majorCode;
  DWORD minorCode;
  char dimmList[1];
} EVT_IML_DIMM_CFG_MAX_CHANNEL_RANKS_50_560, *PEVT_IML_DIMM_CFG_MAX_CHANNEL_RANKS_50_560;
    
//
// Memory Configuration Error - No memory is available. If DIMMs are installed, verify that the corresponding processor is installed. %1 (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_DIMM_CFG_NO_MEM_50_561
{
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_NO_MEM_50_561, *PEVT_IML_DIMM_CFG_NO_MEM_50_561;
    
//
// DIMM Initialization Error - A memory initialization error was detected. %1 (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_DIMM_INIT_ERROR_50_562
{
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_INIT_ERROR_50_562, *PEVT_IML_DIMM_INIT_ERROR_50_562;
    
//
// DIMM Initialization Error - Processor %1 Channel %2. The identified memory channel could not be properly trained and has been mapped out. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_CHANNEL_TRAIN_ERROR_50_563
{
  BYTE processorNumber;
  BYTE channelNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_CHANNEL_TRAIN_ERROR_50_563, *PEVT_IML_CHANNEL_TRAIN_ERROR_50_563;
    
//
// DIMM Initialization Error - Processor %1 DIMM %2. The identified DIMM could not be properly trained and has been mapped out. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_DIMM_TRAIN_ERROR_50_564
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_TRAIN_ERROR_50_564, *PEVT_IML_DIMM_TRAIN_ERROR_50_564;
    
//
// Unsupported DIMM Configuration Detected - Mixed DIMM configurations are not support on this system. %1 (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_DIMM_CFG_UDIMM_50_565
{
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_UDIMM_50_565, *PEVT_IML_DIMM_CFG_UDIMM_50_565;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 DIMM %2. The DIMM does not support the required voltage. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_DIMM_CFG_VOLTAGE_50_566
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_VOLTAGE_50_566, *PEVT_IML_DIMM_CFG_VOLTAGE_50_566;
    
//
// Unsupported DIMM Configuration Detected - Octal and Quad Rank DIMMs are not supported on the same memory channel . (Major Code:%1, Minor Code:%2).
//
typedef struct _evtIML_DIMM_CFG_OCTAL_QUAD_RANK_50_567
{
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_OCTAL_QUAD_RANK_50_567, *PEVT_IML_DIMM_CFG_OCTAL_QUAD_RANK_50_567;
    
//
// Unsupported DIMM Configuration Detected - Mixing 3DS LRDIMMs with non-3DS LRDIMMs is not supported. %1 (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_DIMM_CFG_LRDIMM_MIX_RANK_50_568
{
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_LRDIMM_MIX_RANK_50_568, *PEVT_IML_DIMM_CFG_LRDIMM_MIX_RANK_50_568;
    
//
// Unsupported DIMM Configuration Detected - Mixed DIMM configurations are not supported on this system.  The system can only have one DIMM type (such as RDIMM or LRDIMM) installed at a time. %1 (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_DIMM_CFG_MIXED_DIMM_TYPE_50_569
{
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_MIXED_DIMM_TYPE_50_569, *PEVT_IML_DIMM_CFG_MIXED_DIMM_TYPE_50_569;
    
//
// %1 FW Communication Issue - Unable to communicate with %2 FW. Certain management functionality is not available.
//
typedef struct _evtIML_ILO_FW_COM_FAIL_50_624
{
  char bmc[1];
  //char oem[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_ILO_FW_COM_FAIL_50_624, *PEVT_IML_ILO_FW_COM_FAIL_50_624;
    
//
// Unsupported Processor Detected - Processor stepping not supported.
//
typedef struct _evtIML_UNSUPP_PROC_CFG_STEP_50_629
{
  BYTE haltStatus;
} EVT_IML_UNSUPP_PROC_CFG_STEP_50_629, *PEVT_IML_UNSUPP_PROC_CFG_STEP_50_629;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 DIMM %2. Registered DIMMs are only supported when an Intel Optane PMem for HPE Module is present in the system. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_NVDIMM_POP_RDIMM_50_840
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_NVDIMM_POP_RDIMM_50_840, *PEVT_IML_NVDIMM_POP_RDIMM_50_840;
    
//
// NVDIMM Population Error - Processor %1, DIMM %2. NVDIMMs and RDIMMs are in the incorrect order on Channel %3. NVDIMMs on the channel should be closest to the CPU.
//
typedef struct _evtIML_NVDIMM_POP_ORDER_ERR_50_848
{
  BYTE processorNumber;
  BYTE dimmNumber;
  BYTE channelNumber;
} EVT_IML_NVDIMM_POP_ORDER_ERR_50_848, *PEVT_IML_NVDIMM_POP_ORDER_ERR_50_848;
    
//
// Processor %1, DIMM %2 - The installed NVDIMM has a Supercap attached. This is not supported.
//
typedef struct _evtIML_NVDIMM_SUPERCAP_50_856
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_NVDIMM_SUPERCAP_50_856, *PEVT_IML_NVDIMM_SUPERCAP_50_856;
    
//
// Unsupported NVDIMM-N Configuration Detected - The installed NVDIMM-Ns are not compatible with each other. (Major Code:%1, Minor Code:%2).
//
typedef struct _evtIML_NVDIMM_CFG_INCOMPATIBLE_50_869
{
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_NVDIMM_CFG_INCOMPATIBLE_50_869, *PEVT_IML_NVDIMM_CFG_INCOMPATIBLE_50_869;
    
//
// Unexpected Shutdown and Restart - An undetermined error type resulted in a reboot of the server. 
//
typedef struct _evtIML_EELOG_ERR_NO_SRC_50_905
{
  char oem[1];
} EVT_IML_EELOG_ERR_NO_SRC_50_905, *PEVT_IML_EELOG_ERR_NO_SRC_50_905;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 DIMM %2. Unsupported persistent memory module is present in the system.  This module is not supported by the installed processor(s) and has been disabled.
//
typedef struct _evtIML_UNSUPPORTED_AEP_DETECTED_50_1107
{
  BYTE processorNumber;
  BYTE dimmNumber;
} EVT_IML_UNSUPPORTED_AEP_DETECTED_50_1107, *PEVT_IML_UNSUPPORTED_AEP_DETECTED_50_1107;
    
//
// Uncorrectable Memory Error Threshold Exceeded (%1 %2, DIMM %3).  The DIMM is mapped out and is currently not available.
//
typedef struct _evtIML_DIMM_UNC_ERROR_THRESHOLD_50_1122
{
  BYTE boardProcessor;
  BYTE deviceNumber;
  BYTE dimmNumber;
} EVT_IML_DIMM_UNC_ERROR_THRESHOLD_50_1122, *PEVT_IML_DIMM_UNC_ERROR_THRESHOLD_50_1122;
    
//
// Intel Optane PMem for HPE - Processor %1 DIMM %2 (SN: %3).  Firmware version %4 is out of date.
//
typedef struct _evtIML_AEP_FW_UPDATE_NEEDED_50_1344
{
  BYTE cpuNumber;
  BYTE dimmNumber;
  char minimumFwVersion[1];
  //char currentFwVersion[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char serialNum[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_AEP_FW_UPDATE_NEEDED_50_1344, *PEVT_IML_AEP_FW_UPDATE_NEEDED_50_1344;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1 DIMM %2 (SN: %3). The indicated PMem is not supported. The affected channel has been mapped out. DIMM %4 and %5 are not available. (Major Code:%6, Minor Code:%7).
//
typedef struct _evtIML_AEP_NOT_SUPPORTED_50_1376
{
  BYTE procNumber;
  BYTE badDimmNumber;
  BYTE channelDimmNumber;
  DWORD majorCode;
  DWORD minorCode;
  char serialNum[1];
} EVT_IML_AEP_NOT_SUPPORTED_50_1376, *PEVT_IML_AEP_NOT_SUPPORTED_50_1376;
    
//
// Intel Optane PMem for HPE Configuration Error -  Processor %1 requires at least one RDIMM/LRDIMM installed when a PMEM is present. (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_AEP_SOCKET_MISSING_DIMM_50_1377
{
  BYTE procNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_AEP_SOCKET_MISSING_DIMM_50_1377, *PEVT_IML_AEP_SOCKET_MISSING_DIMM_50_1377;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor 1 DIMM %1 must be an RDIMM/LRDIMM when a PMEM is present. (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_AEP_S0C0D0_MISSING_DIMM_50_1378
{
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_AEP_S0C0D0_MISSING_DIMM_50_1378, *PEVT_IML_AEP_S0C0D0_MISSING_DIMM_50_1378;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1 DIMM %2. The indicated DIMM is not supported when a PMEM is present. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_DIMM_NOT_SUPPORTED_WITH_AEP_50_1379
{
  BYTE procNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_NOT_SUPPORTED_WITH_AEP_50_1379, *PEVT_IML_DIMM_NOT_SUPPORTED_WITH_AEP_50_1379;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1 DIMM %2 (SN: %3). Two PMEMs are installed on the same channel. (Major Code:%4, Minor Code:%5).
//
typedef struct _evtIML_AEPS_ON_SAME_CHANNEL_50_1380
{
  BYTE procNumber;
  BYTE badDimmNumber;
  BYTE channelDimmNumber;
  DWORD majorCode;
  DWORD minorCode;
  char serialNum[1];
} EVT_IML_AEPS_ON_SAME_CHANNEL_50_1380, *PEVT_IML_AEPS_ON_SAME_CHANNEL_50_1380;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1. A PMem (SN: %2) and an RDIMM/LRDIMM are installed on the same channel in the wrong order.  The affected channel has been mapped out. DIMM %3 and %4 are not available. (Major Code:%5, Minor Code:%6).
//
typedef struct _evtIML_AEP_CHANNEL_ORDER_ERROR_50_1381
{
  BYTE procNumber;
  BYTE badDimmNumber;
  BYTE channelDimmNumber;
  DWORD majorCode;
  DWORD minorCode;
  char serialNum[1];
} EVT_IML_AEP_CHANNEL_ORDER_ERROR_50_1381, *PEVT_IML_AEP_CHANNEL_ORDER_ERROR_50_1381;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 DIMM %2. Dual Die package LRDIMMs are only supported when an Intel Optane PMem for HPE Module is present in the system. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_DUAL_DIE_LRDIMM_NO_AEP_50_1382
{
  BYTE procNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DUAL_DIE_LRDIMM_NO_AEP_50_1382, *PEVT_IML_DUAL_DIE_LRDIMM_NO_AEP_50_1382;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1 DIMM %2 (SN: %3). PMEM not installed on the first memory controller of the socket. (Major Code:%4, Minor Code:%5).
//
typedef struct _evtIML_AEP_NOT_ON_IMC0_50_1383
{
  BYTE procNumber;
  BYTE badDimmNumber;
  DWORD majorCode;
  DWORD minorCode;
  char serialNum[1];
  //char imc0DimmList[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_AEP_NOT_ON_IMC0_50_1383, *PEVT_IML_AEP_NOT_ON_IMC0_50_1383;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1 DIMM %2 (SN: %3). PMEM is not installed on Processor 1. (Major Code:%4, Minor Code:%5).
//
typedef struct _evtIML_AEP_NOT_ON_CPU1_50_1384
{
  BYTE procNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
  char serialNum[1];
} EVT_IML_AEP_NOT_ON_CPU1_50_1384, *PEVT_IML_AEP_NOT_ON_CPU1_50_1384;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1. 3DS LRDIMMs are not supported with the current PMEM configuration. (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_AEP_2LM_3DS_LRDIMMS_50_1392
{
  BYTE procNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_AEP_2LM_3DS_LRDIMMS_50_1392, *PEVT_IML_AEP_2LM_3DS_LRDIMMS_50_1392;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1. The installed memory is not balanced between memory controllers and may result in non-optimal performance. (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_AEP_2LM_UNBALANCED_50_1393
{
  BYTE procNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_AEP_2LM_UNBALANCED_50_1393, *PEVT_IML_AEP_2LM_UNBALANCED_50_1393;
    
//
// Intel Optane PMem for HPE Configuration - Processor %1. System can only operate in Application Direct Mode.  At least one PMEM with volatile capacity and one RDIMM/LRDIMM should be installed on each memory controller to support Memory Mode.  (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_AEP_2LM_DIMM_IMC_MISMATCH_50_1395
{
  BYTE procNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_AEP_2LM_DIMM_IMC_MISMATCH_50_1395, *PEVT_IML_AEP_2LM_DIMM_IMC_MISMATCH_50_1395;
    
//
// Intel Optane PMem for HPE Configuration Error. PMEMs of different capacities on %1. (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_AEP_CAP_MISMATCH_50_1396
{
  BYTE scope;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_AEP_CAP_MISMATCH_50_1396, *PEVT_IML_AEP_CAP_MISMATCH_50_1396;
    
//
// Hardware Installation Error - Mezzanine %1 is not correctly installed.
//
typedef struct _evtIML_DOUBLE_WIDE_MEZZ_INSTALL_ERROR_50_1537
{
  BYTE mezzanineNumber;
} EVT_IML_DOUBLE_WIDE_MEZZ_INSTALL_ERROR_50_1537, *PEVT_IML_DOUBLE_WIDE_MEZZ_INSTALL_ERROR_50_1537;
    
//
// Hardware Installation Error - Cabling to riser %1 is not correctly installed.  Riser functionality may be impaired.
//
typedef struct _evtIML_RISER_CABLE_INSTALL_ERROR_50_1538
{
  BYTE riserNumber;
} EVT_IML_RISER_CABLE_INSTALL_ERROR_50_1538, *PEVT_IML_RISER_CABLE_INSTALL_ERROR_50_1538;
    
//
// Unsupported Hardware Detected - The system has components not qualified for deployment.  Error Code 0x%1.
//
typedef struct _evtIML_FACTORY_BUILD_ERROR_50_1539
{
  BYTE errorCode;
} EVT_IML_FACTORY_BUILD_ERROR_50_1539, *PEVT_IML_FACTORY_BUILD_ERROR_50_1539;
    
//
// Processor Built-In Self-Test (BIST) Failure.  Processor %1, Failed Cores Bitmap : 0x%2.
//
typedef struct _evtIML_HPE_CPU_BIST_50_12307
{
  BYTE cpuNumber;
  DWORD errorCode;
} EVT_IML_HPE_CPU_BIST_50_12307, *PEVT_IML_HPE_CPU_BIST_50_12307;
    
//
// PCIe Slot %1 failed to train at Gen %2 speed and x%3 width.
//
typedef struct _evtIML_PCIE_SLOT_FAILURE_50_12320
{
  BYTE slotNumber;
  BYTE linkSpeed;
  BYTE linkWidth;
} EVT_IML_PCIE_SLOT_FAILURE_50_12320, *PEVT_IML_PCIE_SLOT_FAILURE_50_12320;
    
//
// PCIe Slot %1 failed to train.
//
typedef struct _evtIML_PCIE_FULL_SLOT_FAILURE_50_12321
{
  BYTE slotNumber;
} EVT_IML_PCIE_FULL_SLOT_FAILURE_50_12321, *PEVT_IML_PCIE_FULL_SLOT_FAILURE_50_12321;
    
//
// PCIe %1 %2 failed to train or no device detected on a bifurcated slot.
//
typedef struct _evtIML_PCIE_BIFUR_SLOT_FAILURE_50_12322
{
  BYTE deviceType;
  BYTE slotNumber;
} EVT_IML_PCIE_BIFUR_SLOT_FAILURE_50_12322, *PEVT_IML_PCIE_BIFUR_SLOT_FAILURE_50_12322;
    
//
// FlexibleLOM %1 failed to train.
//
typedef struct _evtIML_FLEXLOM_LINK_FAILURE_50_12323
{
  BYTE flexlomNumber;
} EVT_IML_FLEXLOM_LINK_FAILURE_50_12323, *PEVT_IML_FLEXLOM_LINK_FAILURE_50_12323;
    
//
// FlexibleLOM %1 failed to train at Gen %2 speed and x%3 width.
//
typedef struct _evtIML_FLEXLOM_LINK_DEGRADED_50_12324
{
  BYTE flexlomNumber;
  BYTE flexlomSpeed;
  BYTE flexlomWidth;
} EVT_IML_FLEXLOM_LINK_DEGRADED_50_12324, *PEVT_IML_FLEXLOM_LINK_DEGRADED_50_12324;
    
//
// Intel Optane PMem for HPE Configuration Error - The system is populated with incompatible Persistent Memory Module types. %1 (Major Code:%2, Minor Code:%3).
//
typedef struct _evtIML_AEP_MIXED_SKU_50_12325
{
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
  BYTE dimmNum;
  BYTE procNum;
} EVT_IML_AEP_MIXED_SKU_50_12325, *PEVT_IML_AEP_MIXED_SKU_50_12325;
    
//
// Intel Optane PMem for HPE Initialization Error - Processor %1 DIMM %2 (SN: %3). There was a communication error with the identified Persistent Memory Module controller. The PMEM may have reduced functionality or may not be available. (Major Code:%4, Minor Code:%5).
//
typedef struct _evtIML_AEP_COMM_FAILURE_50_12326
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
  char serialNum[1];
} EVT_IML_AEP_COMM_FAILURE_50_12326, *PEVT_IML_AEP_COMM_FAILURE_50_12326;
    
//
// HPE Factory Memory Test Repair - The HPE Factory Memory test repaired a DIMM. Processor %1 DIMM %2.
//
typedef struct _evtIML_SMART_PPR_REPAIR_50_12329
{
  BYTE processorNumber;
  BYTE dimmLabel;
} EVT_IML_SMART_PPR_REPAIR_50_12329, *PEVT_IML_SMART_PPR_REPAIR_50_12329;
    
//
// Intel Optane PMem for HPE Configuration Error - (Major Code:%1, Minor Code:%2).
//
typedef struct _evtIML_AEP_POP_WARN_50_12336
{
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_AEP_POP_WARN_50_12336, *PEVT_IML_AEP_POP_WARN_50_12336;
    
//
// Intelligent Diagnostics has detected %1 device %2 is causing POST boot issues. The device will now be disabled.
//
typedef struct _evtIML_AUTO_HEAL_RESOLUTION_50_12340
{
  BYTE suspectDeviceType;
  BYTE suspectDeviceNumber;
} EVT_IML_AUTO_HEAL_RESOLUTION_50_12340, *PEVT_IML_AUTO_HEAL_RESOLUTION_50_12340;
    
//
// Intel Trusted Execution Error - Intel TXT BIOS ACM has reported an error (code:0x%1).
//
typedef struct _evtIML_LTSX_BIOS_ACM_ERROR_50_12346
{
  DWORD biosAcmErrorCode;
} EVT_IML_LTSX_BIOS_ACM_ERROR_50_12346, *PEVT_IML_LTSX_BIOS_ACM_ERROR_50_12346;
    
//
// Intel Trusted Execution Error - Intel TXT SINITACM has reported an error (code:0x%1).
//
typedef struct _evtIML_LTSX_SINIT_ACM_ERROR_50_12347
{
  DWORD sinitErrorCode;
} EVT_IML_LTSX_SINIT_ACM_ERROR_50_12347, *PEVT_IML_LTSX_SINIT_ACM_ERROR_50_12347;
    
//
// Extended Memory Test (Type %1) - Initiated
//
typedef struct _evtIML_STEP_BEGIN_50_12355
{
  BYTE testType;
} EVT_IML_STEP_BEGIN_50_12355, *PEVT_IML_STEP_BEGIN_50_12355;
    
//
// Extended Memory Test (Type %1) - Completed
//
typedef struct _evtIML_STEP_END_50_12356
{
  BYTE testType;
} EVT_IML_STEP_END_50_12356, *PEVT_IML_STEP_END_50_12356;
    
//
// Extended Memory Test (Type %1) Repair - The HPE Factory Memory test repaired a DIMM. Processor %2 DIMM %3.
//
typedef struct _evtIML_STEP_REPAIR_50_12357
{
  BYTE processorNumber;
  BYTE dimmLabel;
  BYTE testType;
} EVT_IML_STEP_REPAIR_50_12357, *PEVT_IML_STEP_REPAIR_50_12357;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 DIMM %2 violates DIMM population rules. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_DIMM_CFG_POP_ORDER_TERTIARY_50_12358
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_POP_ORDER_TERTIARY_50_12358, *PEVT_IML_DIMM_CFG_POP_ORDER_TERTIARY_50_12358;
    
//
// Unsupported DIMM Configuration Detected - Processor %1 DIMM %2 has population violation due to an event that has led to an unsupported configuration. (Major Code:%3, Minor Code:%4).
//
typedef struct _evtIML_DIMM_CFG_POP_ORDER_FOURTH_50_12359
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_CFG_POP_ORDER_FOURTH_50_12359, *PEVT_IML_DIMM_CFG_POP_ORDER_FOURTH_50_12359;
    
//
// Intel Optane PMem for HPE Initialization Error - Processor %1 DIMM %2 (SN: %3). The PMEM media is not available for use. The PMEM controller is still operational. (Major Code:%4, Minor Code:%5).
//
typedef struct _evtIML_AEP_INIT_ERROR_50_12360
{
  BYTE processorNumber;
  BYTE dimmNumber;
  DWORD majorCode;
  DWORD minorCode;
  char serialNum[1];
} EVT_IML_AEP_INIT_ERROR_50_12360, *PEVT_IML_AEP_INIT_ERROR_50_12360;
    
//
// %1 is in High Security Mode and there is no System ROM Admin Password set.
//
typedef struct _evtSL_ILO_HIGH_SEC_NO_ADMIN_PWD_50_12361
{
  char bmc[1];
} EVT_SL_ILO_HIGH_SEC_NO_ADMIN_PWD_50_12361, *PEVT_SL_ILO_HIGH_SEC_NO_ADMIN_PWD_50_12361;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1. The ratio of RDIMM/LRDIMM to PMEM capacity is 1:%2.%3 and is not in the optimal range of 1:%4 to 1:%5 for the current PMEM configuration. (Major Code:%6, Minor Code:%7).
//
typedef struct _evtIML_BPS_2LM_TOO_MUCH_NM_50_12362
{
  BYTE procNumber;
  DWORD majorCode;
  DWORD minorCode;
  BYTE farMemoryOnesPlace;
  BYTE farMemoryTenthsPlace;
  BYTE lowRatio;
  BYTE highRatio;
} EVT_IML_BPS_2LM_TOO_MUCH_NM_50_12362, *PEVT_IML_BPS_2LM_TOO_MUCH_NM_50_12362;
    
//
// Intel Optane PMem for HPE Configuration Error - Processor %1. The ratio of RDIMM/LRDIMM to PMEM capacity is 1:%2.%3 and is not in the optimal range of 1:%4 to 1:%5 for the current PMEM configuration. (Major Code:%6, Minor Code:%7).
//
typedef struct _evtIML_BPS_2LM_NM_FM_RATIO_50_12363
{
  BYTE procNumber;
  DWORD majorCode;
  DWORD minorCode;
  BYTE farMemoryOnesPlace;
  BYTE farMemoryTenthsPlace;
  BYTE lowRatio;
  BYTE highRatio;
} EVT_IML_BPS_2LM_NM_FM_RATIO_50_12363, *PEVT_IML_BPS_2LM_NM_FM_RATIO_50_12363;
    
//
// Extended Memory Test (Type %1) - Re-initiated
//
typedef struct _evtIML_STEP_RESTART_50_12365
{
  BYTE testType;
} EVT_IML_STEP_RESTART_50_12365, *PEVT_IML_STEP_RESTART_50_12365;
    
//
// Extended Memory Test (Type %1) Repair Failed - The HPE Factory Memory test failed to repair a DIMM. Processor %2 DIMM %3.
//
typedef struct _evtIML_STEP_REPAIR_FAIL_50_12366
{
  BYTE testType;
  BYTE processorNumber;
  BYTE dimmLabel;
} EVT_IML_STEP_REPAIR_FAIL_50_12366, *PEVT_IML_STEP_REPAIR_FAIL_50_12366;
    
//
// PCIe Retraining  Error (Slot %1). Device was not accessible. Some functionality may not be available.
//
typedef struct _evtIML_PCIE_RETRAIN_ERROR_50_12753
{
  BYTE slotNum;
} EVT_IML_PCIE_RETRAIN_ERROR_50_12753, *PEVT_IML_PCIE_RETRAIN_ERROR_50_12753;
    
//
// Hardware Installation Error - Cabling to cable riser slot %1 is not correctly installed. Riser functionality may be impaired.
//
typedef struct _evtIML_MPH_CABLE_RISER_INSTALL_ERROR_50_21568
{
  BYTE riserSlotNumber;
} EVT_IML_MPH_CABLE_RISER_INSTALL_ERROR_50_21568, *PEVT_IML_MPH_CABLE_RISER_INSTALL_ERROR_50_21568;
    
//
// High Bandwidth Memory Initialization Failure - Processor %1. The High Bandwidth Memory processor encountered a failure during initialization.
//
typedef struct _evtIML_HBM_TRAIN_FAILURE_50_21571
{
  BYTE processorNumber;
} EVT_IML_HBM_TRAIN_FAILURE_50_21571, *PEVT_IML_HBM_TRAIN_FAILURE_50_21571;
    
//
// High Bandwidth Memory Mode Degraded - Processor %1. The DIMM population does not support Cache Mode. System is operating in Flat Mode.
//
typedef struct _evtIML_HBM_2LM_UNSUPPORTED_50_21572
{
  BYTE processorNumber;
} EVT_IML_HBM_2LM_UNSUPPORTED_50_21572, *PEVT_IML_HBM_2LM_UNSUPPORTED_50_21572;
    
//
// Newer Firmware Version - Processor %1. The processor's %2 firmware (%3) version is newer than the images available in the current BIOS.
//
typedef struct _evtIML_NEWER_PROCESSOR_FW_VERSION_50_21573
{
  BYTE procNum;
  BYTE type;
  char version[1];
} EVT_IML_NEWER_PROCESSOR_FW_VERSION_50_21573, *PEVT_IML_NEWER_PROCESSOR_FW_VERSION_50_21573;
    
//
// Processor Firmware Update Failure - Processor %1. The processor's %2 image failed to update to version %3.
//
typedef struct _evtIML_CFR_PROVISION_FAIL_50_21574
{
  BYTE procNum;
  BYTE type;
  char version[1];
} EVT_IML_CFR_PROVISION_FAIL_50_21574, *PEVT_IML_CFR_PROVISION_FAIL_50_21574;
    
//
// High Bandwidth Memory (HBM) Configuration Error - Processor %1. The ratio of RDIMM/LRDIMM to HBM capacity is 1:%2.%3 and is not in the optimal range of 1:%4 to 1:%5 for the current HBM configuration. (Major Code:%6, Minor Code:%7).
//
typedef struct _evtIML_HBM_2LM_FM_NM_RATIO_INCORRECTED_50_21578
{
  BYTE procNumber;
  DWORD majorCode;
  DWORD minorCode;
  BYTE farMemoryOnesPlace;
  BYTE farMemoryTenthsPlace;
  BYTE lowRatio;
  BYTE highRatio;
} EVT_IML_HBM_2LM_FM_NM_RATIO_INCORRECTED_50_21578, *PEVT_IML_HBM_2LM_FM_NM_RATIO_INCORRECTED_50_21578;
    
//
// HPE Factory AMD Memory PPR Test Duration - The HPE Factory AMD Memory PPR test duration %1 ms.
//
typedef struct _evtIML_SMART_PPR_AMD_TEST_DURATION_50_21579
{
  DWORD testDuration;
} EVT_IML_SMART_PPR_AMD_TEST_DURATION_50_21579, *PEVT_IML_SMART_PPR_AMD_TEST_DURATION_50_21579;
    
//
// High Bandwidth Memory (HBM) Extended Memory Test (Type %1) - Initiated
//
typedef struct _evtIML_HBM_AMT_INIT_50_21580
{
  BYTE testType;
} EVT_IML_HBM_AMT_INIT_50_21580, *PEVT_IML_HBM_AMT_INIT_50_21580;
    
//
// High Bandwidth Memory (HBM) Extended Memory Test (Type %1) - Completed
//
typedef struct _evtIML_HBM_AMT_COMPLETE_50_21581
{
  BYTE testType;
} EVT_IML_HBM_AMT_COMPLETE_50_21581, *PEVT_IML_HBM_AMT_COMPLETE_50_21581;
    
//
// High Bandwidth Memory (HBM) Extended Memory Test (Type %1) Repair - The HPE Factory Memory test repaired a HBM (Processor %2).
//
typedef struct _evtIML_HBM_STEP_REPAIR_50_21582
{
  BYTE testType;
  BYTE processorNumber;
} EVT_IML_HBM_STEP_REPAIR_50_21582, *PEVT_IML_HBM_STEP_REPAIR_50_21582;
    
//
// Uncorrectable Memory Error Threshold Exceeded (%1 %2, DIMM %3). The DIMMs on the same memory channel are mapped out and are currently not available.
//
typedef struct _evtIML_DIMM_UNC_ERROR_THRESHOLD_MAPOUT_CHANNEL_50_21583
{
  BYTE boardProcessor;
  BYTE deviceNumber;
  BYTE dimmNumber;
} EVT_IML_DIMM_UNC_ERROR_THRESHOLD_MAPOUT_CHANNEL_50_21583, *PEVT_IML_DIMM_UNC_ERROR_THRESHOLD_MAPOUT_CHANNEL_50_21583;
    
//
// DIMM Power Fault Detected - Processor %1 DIMM %2.  %3 (Major Code:%4, Minor Code:%5).
//
typedef struct _evtIML_DIMM_PWR_FAIL_ERROR_50_21585
{
  BYTE processorNumber;
  BYTE dimmNumber;
  BYTE haltStatus;
  DWORD majorCode;
  DWORD minorCode;
} EVT_IML_DIMM_PWR_FAIL_ERROR_50_21585, *PEVT_IML_DIMM_PWR_FAIL_ERROR_50_21585;
    
//
// CPU Firmware Mismatch - Mixed %1 firmware versions between processor %2 (%3) and processor %4 (%5).
//
typedef struct _evtIML_PROCESSOR_FW_MISMATCH_50_21586
{
  BYTE type;
  BYTE procNum1;
  BYTE procNum2;
  char verNum1[1];
  //char verNum2[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_PROCESSOR_FW_MISMATCH_50_21586, *PEVT_IML_PROCESSOR_FW_MISMATCH_50_21586;
    
//
// CXL Configuration Error - CXL devices installed on Processor %1 exceed the lane limitation.
//
typedef struct _evtIML_CXL_NUM_LIMIT_EXCEEDED_50_21587
{
  BYTE procNumber;
} EVT_IML_CXL_NUM_LIMIT_EXCEEDED_50_21587, *PEVT_IML_CXL_NUM_LIMIT_EXCEEDED_50_21587;
    
//
// CXL Configuration Error - the CXL cache device installed on Processor %1 Slot %2 is disabled.
//
typedef struct _evtIML_CXL_CACHE_LIMIT_50_21588
{
  BYTE procNumber;
  BYTE slotNumber;
} EVT_IML_CXL_CACHE_LIMIT_50_21588, *PEVT_IML_CXL_CACHE_LIMIT_50_21588;
    
//
// CXL Configuration Error - the number of CXL devices installed on Processor %1 exceeds the limitation for the root port.
//
typedef struct _evtIML_CXL_1P1_LIMIT_EXCEED_50_21589
{
  BYTE procNumber;
} EVT_IML_CXL_1P1_LIMIT_EXCEED_50_21589, *PEVT_IML_CXL_1P1_LIMIT_EXCEED_50_21589;
    
//
// CXL Configuration Error - a CXL device is installed in the incorrect slot (Processor %1 Slot %2).
//
typedef struct _evtIML_CXL_1P1_CFG_ERROR_50_21590
{
  BYTE procNumber;
  BYTE slotNumber;
} EVT_IML_CXL_1P1_CFG_ERROR_50_21590, *PEVT_IML_CXL_1P1_CFG_ERROR_50_21590;
    
//
// Advanced Memory Test (Type %1) - Initiated
//
typedef struct _evtIML_STEP_BEGIN_G12_50_21591
{
  BYTE testType;
} EVT_IML_STEP_BEGIN_G12_50_21591, *PEVT_IML_STEP_BEGIN_G12_50_21591;
    
//
// Advanced Memory Test (Type %1) - Completed
//
typedef struct _evtIML_STEP_END_G12_50_21592
{
  BYTE testType;
} EVT_IML_STEP_END_G12_50_21592, *PEVT_IML_STEP_END_G12_50_21592;
    
//
// Advanced Memory Test (Type %1) Repair - The HPE Factory Memory test repaired a DIMM. Processor %2 DIMM %3.
//
typedef struct _evtIML_STEP_REPAIR_G12_50_21593
{
  BYTE processorNumber;
  BYTE dimmLabel;
  BYTE testType;
} EVT_IML_STEP_REPAIR_G12_50_21593, *PEVT_IML_STEP_REPAIR_G12_50_21593;
    
//
// Advanced Memory Test (Type %1) Repair Failed - The HPE Factory Memory test failed to repair a DIMM. Processor %2 DIMM %3.
//
typedef struct _evtIML_STEP_REPAIR_FAIL_G12_50_21594
{
  BYTE testType;
  BYTE processorNumber;
  BYTE dimmLabel;
} EVT_IML_STEP_REPAIR_FAIL_G12_50_21594, *PEVT_IML_STEP_REPAIR_FAIL_G12_50_21594;
    
//
// Advanced Memory Test (Type %1) - Re-initiated
//
typedef struct _evtIML_STEP_RESTART_G12_50_21595
{
  BYTE testType;
} EVT_IML_STEP_RESTART_G12_50_21595, *PEVT_IML_STEP_RESTART_G12_50_21595;
    
//
// NVMe Storage - Drive at %1 exceeded max temperature
//
typedef struct _evtIML_PCIe_DRIVE_TEMP_FAILED_51_1
{
  BYTE hoTrapFlags;
  BYTE sysPCIeDiskPCIBusIndex;
  BYTE pCIDeviceIndex;
  BYTE pCIFunctionIndex;
  BYTE currentTemperature;
  BYTE thresholdTemperature;
  char hwLocation[1];
} EVT_IML_PCIe_DRIVE_TEMP_FAILED_51_1, *PEVT_IML_PCIe_DRIVE_TEMP_FAILED_51_1;
    
//
// NVMe Storage - Drive at %1 status changed to %2
//
typedef struct _evtIML_PCIe_DRIVE_COND_CHANGE_51_2
{
  BYTE hoTrapFlags;
  BYTE pCIBusIndex;
  BYTE pCIDeviceIndex;
  BYTE pCIFunctionIndex;
  BYTE diskCondition;
  char hwLocation[1];
} EVT_IML_PCIe_DRIVE_COND_CHANGE_51_2, *PEVT_IML_PCIe_DRIVE_COND_CHANGE_51_2;
    
//
// NVMe Storage - Drive at %1 SSD wear status changed to %2
//
typedef struct _evtIML_PCIe_DRIVE_WEAR_STATUS_CHANGE_51_3
{
  BYTE hoTrapFlags;
  BYTE pCIBusIndex;
  BYTE pCIDeviceIndex;
  BYTE pCIFunctionIndex;
  BYTE wearStatus;
  char hwLocation[1];
} EVT_IML_PCIe_DRIVE_WEAR_STATUS_CHANGE_51_3, *PEVT_IML_PCIe_DRIVE_WEAR_STATUS_CHANGE_51_3;
    
//
// A PCI device at %1 Bus %2, Device %3, Function %4 has been added to the system or powered on.
//
typedef struct _evtIML_PCIe_DRIVE_ADDED_POWERON_51_4
{
  BYTE hoTrapFlags;
  BYTE sysPCIeDiskPCIBusIndex;
  BYTE sysPCIeDiskPCIDeviceIndex;
  BYTE sysPCIeDiskPCIFunctionIndex;
  char diskLocation[1];
} EVT_IML_PCIe_DRIVE_ADDED_POWERON_51_4, *PEVT_IML_PCIe_DRIVE_ADDED_POWERON_51_4;
    
//
// A PCI device at %1 Bus %2, Device %3, Function %4 has been removed from the system or powered off.
//
typedef struct _evtIML_PCIe_DRIVE_REMOVED_POWEROFF_51_5
{
  BYTE hoTrapFlags;
  BYTE sysPCIeDiskPCIBusIndex;
  BYTE sysPCIeDiskPCIDeviceIndex;
  BYTE sysPCIeDiskPCIFunctionIndex;
  char diskLocation[1];
} EVT_IML_PCIe_DRIVE_REMOVED_POWEROFF_51_5, *PEVT_IML_PCIe_DRIVE_REMOVED_POWEROFF_51_5;
    
//
// Drive Type %1 Signals %2 Bus %3 is Invalid %4.
//
typedef struct _evtIML_PCIe_DRIVE_INVALID_TYPE_51_6
{
  BYTE hoTrapFlags;
  BYTE sysPCIeDiskPCIBusIndex;
  BYTE driveSignals;
  BYTE driveType;
  char diskLocation[1];
} EVT_IML_PCIe_DRIVE_INVALID_TYPE_51_6, *PEVT_IML_PCIe_DRIVE_INVALID_TYPE_51_6;
    
//
// Storage backplane Box Number %1 management failure (Failure type - %2).
//
typedef struct _evtIML_BACKPLANE_FRU_INVALID_DATA_51_7
{
  BYTE boxNumber;
  BYTE failureType;
} EVT_IML_BACKPLANE_FRU_INVALID_DATA_51_7, *PEVT_IML_BACKPLANE_FRU_INVALID_DATA_51_7;
    
//
// Power supply %1 has exceeded the current limit. Power Supply output will be disabled.
//
typedef struct _evtIML_PS_OVERCURRENT_52_1
{
  BYTE powerSupplyID;
} EVT_IML_PS_OVERCURRENT_52_1, *PEVT_IML_PS_OVERCURRENT_52_1;
    
//
// Chassis operating at reduced performance level (> %1 Percentage) for past %2 %3
//
typedef struct _evtIML_CHASSIS_PEFORMANCE_52_2
{
  BYTE throttlePercentage;
  DWORD duration;
  BYTE period;
} EVT_IML_CHASSIS_PEFORMANCE_52_2, *PEVT_IML_CHASSIS_PEFORMANCE_52_2;
    
//
// Power Regulator: Zone %1 operating at reduced performance level (> %2 Percentage) for past %3 %4
//
typedef struct _evtIML_ZONE_PERFORMANCE_52_3
{
  BYTE zoneID;
  BYTE throttlePercentage;
  DWORD duration;
  BYTE period;
} EVT_IML_ZONE_PERFORMANCE_52_3, *PEVT_IML_ZONE_PERFORMANCE_52_3;
    
//
// Performance monitoring has detected that %1 crossed the user defined %2 threshold.
//
typedef struct _evtIML_IST_PERFORMANCE_THRESHOLD_53_1
{
  BYTE metric;
  BYTE level;
} EVT_IML_IST_PERFORMANCE_THRESHOLD_53_1, *PEVT_IML_IST_PERFORMANCE_THRESHOLD_53_1;
    
//
// %1 was reset because a FIPS Known Answer Test failed.
//
typedef struct _evtSL_FIPS_KAT_FAILED_54_1
{
  BYTE subsystem;
} EVT_SL_FIPS_KAT_FAILED_54_1, *PEVT_SL_FIPS_KAT_FAILED_54_1;
    
//
// Internal  software health test has failed with error code %1. #ILO was reset automatically to rectify this. 
//
typedef struct _evtSL_HEALTH_TEST_FAILURE_54_3
{
  BYTE healthTest;
} EVT_SL_HEALTH_TEST_FAILURE_54_3, *PEVT_SL_HEALTH_TEST_FAILURE_54_3;
    
//
// The security state of \"%1\" parameter on security dashboard is \"%2\". State is \"%3\" and ignore option is \"%4\".
//
typedef struct _evtSL_SECDB_IGNORED_BY_55_2
{
  DWORD configuration;
  DWORD status;
  DWORD state;
  DWORD ignore;
} EVT_SL_SECDB_IGNORED_BY_55_2, *PEVT_SL_SECDB_IGNORED_BY_55_2;
    
//
// %1 Security state changed to %2 by:  %3
//
typedef struct _evtSL_SECURITY_STATE_CHANGED_55_4
{
  BYTE subsystem;
  DWORD securityState;
  char username[1];
} EVT_SL_SECURITY_STATE_CHANGED_55_4, *PEVT_SL_SECURITY_STATE_CHANGED_55_4;
    
//
// %1 server certificate validation failed. Reason: %2
//
typedef struct _evtSL_CERT_VAL_FAILED_55_6
{
  BYTE subsystem;
  DWORD failedReason;
} EVT_SL_CERT_VAL_FAILED_55_6, *PEVT_SL_CERT_VAL_FAILED_55_6;
    
//
// %1 server certificate validation failed due to incompatible %2.
//
typedef struct _evtSL_CERT_VAL_INCOMPATIBLE_55_7
{
  BYTE subsystem;
  BYTE failedReason;
} EVT_SL_CERT_VAL_INCOMPATIBLE_55_7, *PEVT_SL_CERT_VAL_INCOMPATIBLE_55_7;
    
//
// SSO Trust Mode set to Trust %1 by user:%2.
//
typedef struct _evtSL_SSO_TRUST_CHANGE_55_9
{
  char sSOTrust[1];
  //char userName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_SL_SSO_TRUST_CHANGE_55_9, *PEVT_SL_SSO_TRUST_CHANGE_55_9;
    
//
// SSO %1 role privileges set by user:%2.
//
typedef struct _evtSL_SSO_ROLE_CHANGE_55_10
{
  char sSORole[1];
  //char userName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_SL_SSO_ROLE_CHANGE_55_10, *PEVT_SL_SSO_ROLE_CHANGE_55_10;
    
//
// SSO rejected: %1.
//
typedef struct _evtSL_SSO_LOGIN_REJECT_ERROR_55_11
{
  BYTE reason;
} EVT_SL_SSO_LOGIN_REJECT_ERROR_55_11, *PEVT_SL_SSO_LOGIN_REJECT_ERROR_55_11;
    
//
// SSL certificate installed by : %1.
//
typedef struct _evtSL_SSL_CERT_INSTALLED_55_12
{
  char userName[1];
} EVT_SL_SSL_CERT_INSTALLED_55_12, *PEVT_SL_SSL_CERT_INSTALLED_55_12;
    
//
// Host authentication %1 by: %2.
//
typedef struct _evtSL_HOST_AUTHENTICATION_55_13
{
  BYTE action;
  char userName[1];
} EVT_SL_HOST_AUTHENTICATION_55_13, *PEVT_SL_HOST_AUTHENTICATION_55_13;
    
//
// Login security banner %1 by: %2.
//
typedef struct _evtSL_LOGIN_BANNER_55_14
{
  BYTE action;
  char userName[1];
} EVT_SL_LOGIN_BANNER_55_14, *PEVT_SL_LOGIN_BANNER_55_14;
    
//
// SSH key %1 for %2 by: %3.
//
typedef struct _evtSL_SSH_KEY_55_16
{
  BYTE action;
  char serverName[1];
  //char userName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_SL_SSH_KEY_55_16, *PEVT_SL_SSH_KEY_55_16;
    
//
// Access options IPMI/DCMI modified by: %1.
//
typedef struct _evtSL_IPMI_ACCESS_MODIFIED_55_18
{
  char userName[1];
} EVT_SL_IPMI_ACCESS_MODIFIED_55_18, *PEVT_SL_IPMI_ACCESS_MODIFIED_55_18;
    
//
// #ILO Network configuration modified by: %1.
//
typedef struct _evtSL_NETWORK_CFG_MODIFIED_BY_55_19
{
  char userName[1];
} EVT_SL_NETWORK_CFG_MODIFIED_BY_55_19, *PEVT_SL_NETWORK_CFG_MODIFIED_BY_55_19;
    
//
// Certificate Warning: Subject (%1) does not match server name (%2).
//
typedef struct _evtSL_CERTIFICATE_WARNING_BAD_NAME_55_20
{
  char serverName[1];
  //char userName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_SL_CERTIFICATE_WARNING_BAD_NAME_55_20, *PEVT_SL_CERTIFICATE_WARNING_BAD_NAME_55_20;
    
//
// Server Signature changed. (0x%1)
//
typedef struct _evtSL_SERVER_SIGNATURE_CHANGED_55_21
{
  DWORD number;
} EVT_SL_SERVER_SIGNATURE_CHANGED_55_21, *PEVT_SL_SERVER_SIGNATURE_CHANGED_55_21;
    
//
// Access Settings modified by: %1.
//
typedef struct _evtSL_ACCESS_SETTINGS_MODIFIED_BY_55_22
{
  char userName[1];
} EVT_SL_ACCESS_SETTINGS_MODIFIED_BY_55_22, *PEVT_SL_ACCESS_SETTINGS_MODIFIED_BY_55_22;
    
//
// #ILO Service Port settings modified by: %1.
//
typedef struct _evtSL_SERVICE_PORT_SETTINGS_MODIFIED_BY_55_23
{
  char userName[1];
} EVT_SL_SERVICE_PORT_SETTINGS_MODIFIED_BY_55_23, *PEVT_SL_SERVICE_PORT_SETTINGS_MODIFIED_BY_55_23;
    
//
// CAC Smartcard Authentication settings modified by: %1.
//
typedef struct _evtSL_CAC_SETTINGS_MODIFIED_BY_55_24
{
  char userName[1];
} EVT_SL_CAC_SETTINGS_MODIFIED_BY_55_24, *PEVT_SL_CAC_SETTINGS_MODIFIED_BY_55_24;
    
//
// The Downgrade Policy was modified to %1 by: %2.
//
typedef struct _evtSL_DG_POL_MOD_55_28
{
  DWORD setting;
  char userName[1];
} EVT_SL_DG_POL_MOD_55_28, *PEVT_SL_DG_POL_MOD_55_28;
    
//
// The invalid image \"%1\" was added to the #ILO Repository.
//
typedef struct _evtSL_INVALID_FILE_ADDED_55_29
{
  char fileName[1];
} EVT_SL_INVALID_FILE_ADDED_55_29, *PEVT_SL_INVALID_FILE_ADDED_55_29;
    
//
// REST - Event subscriber CA certificate %1 to #ILO REST trusted CA store by: %2.
//
typedef struct _evtSL_REST_SUBSCRIBER_CA_CERTIFICATE_IMPORTED_BY_55_30
{
  BYTE action;
  char userName[1];
} EVT_SL_REST_SUBSCRIBER_CA_CERTIFICATE_IMPORTED_BY_55_30, *PEVT_SL_REST_SUBSCRIBER_CA_CERTIFICATE_IMPORTED_BY_55_30;
    
//
// CAC Smartcard certificate for %1 %2 by: %3.
//
typedef struct _evtSL_CAC_CERT_ADD_REMOVE_55_31
{
  BYTE action;
  char serverName[1];
  //char userName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_SL_CAC_CERT_ADD_REMOVE_55_31, *PEVT_SL_CAC_CERT_ADD_REMOVE_55_31;
    
//
// Key manager %1 modified by: %2.
//
typedef struct _evtSL_KEYMGR_ESKM_MODIFY_55_32
{
  BYTE action;
  char userName[1];
} EVT_SL_KEYMGR_ESKM_MODIFY_55_32, *PEVT_SL_KEYMGR_ESKM_MODIFY_55_32;
    
//
// SSO server %1 %2 by user:%3.
//
typedef struct _evtSL_SSO_SRV_55_34
{
  BYTE action;
  char serverName[1];
  //char userName[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_SL_SSO_SRV_55_34, *PEVT_SL_SSO_SRV_55_34;
    
//
// SSO server index %1 removed by user:%2.
//
typedef struct _evtSL_SSO_SRV_REC_DEL_55_35
{
  DWORD number;
  char userName[1];
} EVT_SL_SSO_SRV_REC_DEL_55_35, *PEVT_SL_SSO_SRV_REC_DEL_55_35;
    
//
// Firmware recovery is requested by %1
//
typedef struct _evtSL_FW_RECOVERY_REQUEST_55_36
{
  char userName[1];
} EVT_SL_FW_RECOVERY_REQUEST_55_36, *PEVT_SL_FW_RECOVERY_REQUEST_55_36;
    
//
// Firmware Integrity settings modified by: %1
//
typedef struct _evtSL_FI_SETTINGS_CHANGED_55_37
{
  char userName[1];
} EVT_SL_FI_SETTINGS_CHANGED_55_37, *PEVT_SL_FI_SETTINGS_CHANGED_55_37;
    
//
// Trusted CA certificate is imported for %1 by : %2
//
typedef struct _evtSL_IMPORT_CERT_LDAP_55_41
{
  BYTE certname;
  char username[1];
} EVT_SL_IMPORT_CERT_LDAP_55_41, *PEVT_SL_IMPORT_CERT_LDAP_55_41;
    
//
// DSA SSH keys import %1 by: %2
//
typedef struct _evtSL_DSA_SIGNED_SSH_KEYS_STATUS_55_67
{
  BYTE status;
  char username[1];
} EVT_SL_DSA_SIGNED_SSH_KEYS_STATUS_55_67, *PEVT_SL_DSA_SIGNED_SSH_KEYS_STATUS_55_67;
    
//
// Account service setting - %1 modified by : %2
//
typedef struct _evtSL_ACCOUNT_SERVICE_SETTINGS_MODIFIED_BY_55_609
{
  BYTE accountSettingProperty;
  char username[1];
} EVT_SL_ACCOUNT_SERVICE_SETTINGS_MODIFIED_BY_55_609, *PEVT_SL_ACCOUNT_SERVICE_SETTINGS_MODIFIED_BY_55_609;
    
//
// Trusted CA certificate is %1 for %2 by : %3
//
typedef struct _evtSL_IMPORT_REMOVE_CA_CERT_55_611
{
  BYTE action;
  BYTE certname;
  char username[1];
} EVT_SL_IMPORT_REMOVE_CA_CERT_55_611, *PEVT_SL_IMPORT_REMOVE_CA_CERT_55_611;
    
//
// Certificate Revocation List (CRL) file is %1 for %2 by : %3
//
typedef struct _evtSL_IMPORT_REMOVE_CRL_55_612
{
  BYTE action;
  BYTE modulename;
  char username[1];
} EVT_SL_IMPORT_REMOVE_CRL_55_612, *PEVT_SL_IMPORT_REMOVE_CRL_55_612;
    
//
// 802.1X Support setting %1 by: %2
//
typedef struct _evtSL_EAP_TLS_SETTINGS_MODIFIED_55_614
{
  DWORD status;
  char userName[1];
} EVT_SL_EAP_TLS_SETTINGS_MODIFIED_55_614, *PEVT_SL_EAP_TLS_SETTINGS_MODIFIED_55_614;
    
//
// SSL certificate %1 is successful. Reset #ILO to use the new certificate.
//
typedef struct _evtSL_ACE_CERT_STAT_SUCCESS_55_618
{
  BYTE action;
} EVT_SL_ACE_CERT_STAT_SUCCESS_55_618, *PEVT_SL_ACE_CERT_STAT_SUCCESS_55_618;
    
//
// Unable to complete SSL certificate %1. Reason: %2.
//
typedef struct _evtSL_ACE_CERT_STAT_FAILED_55_619
{
  BYTE action;
  BYTE failedReason;
} EVT_SL_ACE_CERT_STAT_FAILED_55_619, *PEVT_SL_ACE_CERT_STAT_FAILED_55_619;
    
//
//  Certificate enrollment service is %1.
//
typedef struct _evtSL_ACE_SCEP_STAT_CHANGED_55_621
{
  BYTE action;
} EVT_SL_ACE_SCEP_STAT_CHANGED_55_621, *PEVT_SL_ACE_SCEP_STAT_CHANGED_55_621;
    
//
// Unable to complete SSL certificate %1 since SCEP server denied to issue the certificate.
//
typedef struct _evtSL_ACE_CERT_ISSUE_FAILED_55_622
{
  BYTE action;
} EVT_SL_ACE_CERT_ISSUE_FAILED_55_622, *PEVT_SL_ACE_CERT_ISSUE_FAILED_55_622;
    
//
// Unable to complete SSL certificate %1 since validation of the issued certificate failed.
//
typedef struct _evtSL_ACE_CERT_VAL_FAILED_55_623
{
  BYTE action;
} EVT_SL_ACE_CERT_VAL_FAILED_55_623, *PEVT_SL_ACE_CERT_VAL_FAILED_55_623;
    
//
// Unable to complete SSL certificate %1 because CSR generation failed.
//
typedef struct _evtSL_ACE_CSR_GEN_FAILED_55_624
{
  BYTE action;
} EVT_SL_ACE_CSR_GEN_FAILED_55_624, *PEVT_SL_ACE_CSR_GEN_FAILED_55_624;
    
//
// CAC/SmartCard Authentication Login failed: %1
//
typedef struct _evtSL_CAC_LOGIN_FAILURE_CRL_REVOKED_55_628
{
  char username[1];
} EVT_SL_CAC_LOGIN_FAILURE_CRL_REVOKED_55_628, *PEVT_SL_CAC_LOGIN_FAILURE_CRL_REVOKED_55_628;
    
//
// SPDM device at location %1 could not be authenticated (reason %2)
//
typedef struct _evtSL_SPDM_AUTH_FAILURE_55_629
{
  char location[1];
  //char reason[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_SL_SPDM_AUTH_FAILURE_55_629, *PEVT_SL_SPDM_AUTH_FAILURE_55_629;
    
//
// SPDM Device at location %1 is authentic
//
typedef struct _evtSL_SPDM_AUTH_SUCCESS_55_630
{
  char location[1];
} EVT_SL_SPDM_AUTH_SUCCESS_55_630, *PEVT_SL_SPDM_AUTH_SUCCESS_55_630;
    
//
// Global Component Integrity changed to %1
//
typedef struct _evtSL_GLOBAL_COMPONENT_INTEGRITY_55_631
{
  BYTE state;
} EVT_SL_GLOBAL_COMPONENT_INTEGRITY_55_631, *PEVT_SL_GLOBAL_COMPONENT_INTEGRITY_55_631;
    
//
// SPDM Boot Policy changed to %1
//
typedef struct _evtSL_COMPONENT_INTEGRITY_POLICY_55_632
{
  BYTE spdmComponentIntegrityPolicy;
} EVT_SL_COMPONENT_INTEGRITY_POLICY_55_632, *PEVT_SL_COMPONENT_INTEGRITY_POLICY_55_632;
    
//
// TLS Version %1 is %2 by : %3
//
typedef struct _evtSL_TLS_VERSION_STATUS_55_633
{
  BYTE version;
  BYTE status;
  char user[1];
} EVT_SL_TLS_VERSION_STATUS_55_633, *PEVT_SL_TLS_VERSION_STATUS_55_633;
    
//
// SSL certificate could not be imported %1.
//
typedef struct _evtSL_SSL_CERT_COMMON_FAILURES_55_635
{
  BYTE failure_reason;
} EVT_SL_SSL_CERT_COMMON_FAILURES_55_635, *PEVT_SL_SSL_CERT_COMMON_FAILURES_55_635;
    
//
// SSL certificate could not be imported %1.
//
typedef struct _evtSL_SSL_CERT_SIDE_LOADED_FAILURES_55_636
{
  BYTE failure_reason;
} EVT_SL_SSL_CERT_SIDE_LOADED_FAILURES_55_636, *PEVT_SL_SSL_CERT_SIDE_LOADED_FAILURES_55_636;
    
//
// SSL certificate could not be imported %1.
//
typedef struct _evtSL_SSL_CERT_CA_SIGNED_FAILURES_55_637
{
  BYTE failure_reason;
} EVT_SL_SSL_CERT_CA_SIGNED_FAILURES_55_637, *PEVT_SL_SSL_CERT_CA_SIGNED_FAILURES_55_637;
    
//
// SSL certificate could not be imported %1.
//
typedef struct _evtSL_SSL_CERT_SIDE_LOADED_SEC_STATE_FAILURES_55_639
{
  BYTE failure_reason;
} EVT_SL_SSL_CERT_SIDE_LOADED_SEC_STATE_FAILURES_55_639, *PEVT_SL_SSL_CERT_SIDE_LOADED_SEC_STATE_FAILURES_55_639;
    
//
// %1 certificate could not be imported %2.
//
typedef struct _evtSL_DEVID_CERT_FAILURE_55_1601
{
  BYTE failure_reason;
  BYTE failed_certificate;
} EVT_SL_DEVID_CERT_FAILURE_55_1601, *PEVT_SL_DEVID_CERT_FAILURE_55_1601;
    
//
// %1 Certificate %2
//
typedef struct _evtSL_DEVID_SUCCESS_55_1602
{
  BYTE success_reason;
  BYTE success_certificate;
} EVT_SL_DEVID_SUCCESS_55_1602, *PEVT_SL_DEVID_SUCCESS_55_1602;
    
//
// #ILO%1 is transferred to OpenBMC firmware.
//
typedef struct _evtSL_OPENBMC_TRANSFER_OUT_55_1603
{
  char version[1];
} EVT_SL_OPENBMC_TRANSFER_OUT_55_1603, *PEVT_SL_OPENBMC_TRANSFER_OUT_55_1603;
    
//
// #ILO%1 is transferred back from OpenBMC firmware.
//
typedef struct _evtSL_OPENBMC_TRANSFER_IN_55_1604
{
  char version[1];
} EVT_SL_OPENBMC_TRANSFER_IN_55_1604, *PEVT_SL_OPENBMC_TRANSFER_IN_55_1604;
    
//
// Transfer to OpenBMC firmware is prohibited %1.
//
typedef struct _evtSL_OPENBMC_INHIBIT_55_1605
{
  BYTE inhibit_reason;
} EVT_SL_OPENBMC_INHIBIT_55_1605, *PEVT_SL_OPENBMC_INHIBIT_55_1605;
    
//
// PCR Measurements Changed, Component Type %1 PCR Index %2
//
typedef struct _evtSL_PCR_MEASUREMENTS_CHANGED_55_1607
{
  BYTE componentType;
  BYTE pCRIndex;
} EVT_SL_PCR_MEASUREMENTS_CHANGED_55_1607, *PEVT_SL_PCR_MEASUREMENTS_CHANGED_55_1607;
    
//
// PCR Measurements Updated, Component Type %1 PCR Index %2, no previous measurements to compare
//
typedef struct _evtSL_PCR_MEASUREMENTS_UPDATED_55_1608
{
  BYTE componentType;
  BYTE pCRIndex;
} EVT_SL_PCR_MEASUREMENTS_UPDATED_55_1608, *PEVT_SL_PCR_MEASUREMENTS_UPDATED_55_1608;
    
//
// Login security banner message modified by: %1.
//
typedef struct _evtSL_LOGIN_BANNER_MESSAGE_55_5648
{
  char userName[1];
} EVT_SL_LOGIN_BANNER_MESSAGE_55_5648, *PEVT_SL_LOGIN_BANNER_MESSAGE_55_5648;
    
//
// User with Account Id %1 is %2 by %3.
//
typedef struct _evtSL_ACCOUNT_STATUS_CHANGED_55_5649
{
  DWORD accountId;
  BYTE accountStatus;
  char userName[1];
} EVT_SL_ACCOUNT_STATUS_CHANGED_55_5649, *PEVT_SL_ACCOUNT_STATUS_CHANGED_55_5649;
    
//
// The %1 Security Status on Security Dashboard is set to %2. State is %3. The Ignore flag is %4.
//
typedef struct _evtSL_SECDB_SEC_PARAM_STATUS_55_5652
{
  DWORD configuration;
  DWORD status;
  DWORD state;
  DWORD ignore;
} EVT_SL_SECDB_SEC_PARAM_STATUS_55_5652, *PEVT_SL_SECDB_SEC_PARAM_STATUS_55_5652;
    
//
// The overall security status on security dashboard is at %1.
//
typedef struct _evtSL_SECDB_OVERALL_STATUS_55_5653
{
  DWORD overallSecStatus;
} EVT_SL_SECDB_OVERALL_STATUS_55_5653, *PEVT_SL_SECDB_OVERALL_STATUS_55_5653;
    
//
// The overall security status on security dashboard is at %1.
//
typedef struct _evtSL_SECDB_OVERALL_STATUS_ILO5_55_5654
{
  DWORD overallSecStatus;
} EVT_SL_SECDB_OVERALL_STATUS_ILO5_55_5654, *PEVT_SL_SECDB_OVERALL_STATUS_ILO5_55_5654;
    
//
// Weak Ciphers are %1 by %2.
//
typedef struct _evtSL_WEAK_CIPHERS_STATUS_55_5655
{
  BYTE weakcipherstatus;
  char username[1];
} EVT_SL_WEAK_CIPHERS_STATUS_55_5655, *PEVT_SL_WEAK_CIPHERS_STATUS_55_5655;
    
//
// Component %1 could not be authenticated (reason %2)
//
typedef struct _evtSL_HPM_AUTH_FAILURE_55_5656
{
  char location[1];
  //char reason[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_SL_HPM_AUTH_FAILURE_55_5656, *PEVT_SL_HPM_AUTH_FAILURE_55_5656;
    
//
// Authentication check failed for %1
//
typedef struct _evtSL_TULIP_AUTH_CHECK_FAILURE_55_5657
{
  BYTE cPU_type;
} EVT_SL_TULIP_AUTH_CHECK_FAILURE_55_5657, *PEVT_SL_TULIP_AUTH_CHECK_FAILURE_55_5657;
    
//
// The security state of \"%1\" parameter on security dashboard is \"%2\". State is \"%3\" and ignore option is \"%4\".
//
typedef struct _evtSL_SECDB_IGNORED_BY_55_55_5661
{
  DWORD configuration;
  DWORD status;
  DWORD state;
  DWORD ignore;
} EVT_SL_SECDB_IGNORED_BY_55_55_5661, *PEVT_SL_SECDB_IGNORED_BY_55_55_5661;
    
//
// TPM Quote Signature Validation has failed
//
typedef struct _evtSL_TPM_QUOTE_SIGNATURE_INVALID_55_5664
{
  BYTE componentType;
} EVT_SL_TPM_QUOTE_SIGNATURE_INVALID_55_5664, *PEVT_SL_TPM_QUOTE_SIGNATURE_INVALID_55_5664;
    
//
// %1 detected %2 unauthorized login attempts.
//
typedef struct _evtSL_UNAUTHORIZED_LOGIN_ATTEMPTS_56_2
{
  DWORD badLoginAttemptsThresh;
  BYTE subsystem;
} EVT_SL_UNAUTHORIZED_LOGIN_ATTEMPTS_56_2, *PEVT_SL_UNAUTHORIZED_LOGIN_ATTEMPTS_56_2;
    
//
// %1 detected invalid %2 firmware.
//
typedef struct _evtSL_FI_57_3
{
  BYTE subsystem;
  DWORD firmwareType;
} EVT_SL_FI_57_3, *PEVT_SL_FI_57_3;
    
//
// #ILO was unable to automatically repair the %1 firmware.
//
typedef struct _evtSL_FI_REP_FAIL_57_4
{
  BYTE firmwareName;
} EVT_SL_FI_REP_FAIL_57_4, *PEVT_SL_FI_REP_FAIL_57_4;
    
//
// Intrusion Alert Detection - The server chassis hood was removed %1.
//
typedef struct _evtSL_CHASSIS_HOOD_REMOVAL_58_9
{
  char time_stamp[1];
} EVT_SL_CHASSIS_HOOD_REMOVAL_58_9, *PEVT_SL_CHASSIS_HOOD_REMOVAL_58_9;
    
//
// HPE Trusted OS Security found an OS Kernel Corruption in %1.
//
typedef struct _evtSL_EVT_OS_SECURITY_SCAN_59_1
{
  char module_name[1];
} EVT_SL_EVT_OS_SECURITY_SCAN_59_1, *PEVT_SL_EVT_OS_SECURITY_SCAN_59_1;
    
//
// HPE Trusted OS Security found a new operating system kernel module %1.
//
typedef struct _evtSL_EVT_OS_SECURITY_ADD_59_2
{
  char module_name[1];
} EVT_SL_EVT_OS_SECURITY_ADD_59_2, *PEVT_SL_EVT_OS_SECURITY_ADD_59_2;
    
//
// HPE Trusted OS Security detected operating system kernel module %1 was removed.
//
typedef struct _evtSL_EVT_OS_SECURITY_REMOVE_59_3
{
  char module_name[1];
} EVT_SL_EVT_OS_SECURITY_REMOVE_59_3, *PEVT_SL_EVT_OS_SECURITY_REMOVE_59_3;
    
//
// HPE Trusted OS Security found an OS Kernel Corruption Correction in %1
//
typedef struct _evtSL_EVT_OS_SECURITY_CORRUPTION_CORRECTION_59_16
{
  char moduleName[1];
} EVT_SL_EVT_OS_SECURITY_CORRUPTION_CORRECTION_59_16, *PEVT_SL_EVT_OS_SECURITY_CORRUPTION_CORRECTION_59_16;
    
//
// %1
//
typedef struct _evtIML_SMARTNIC_DPU_60_1
{
  char message[1];
} EVT_IML_SMARTNIC_DPU_60_1, *PEVT_IML_SMARTNIC_DPU_60_1;
    
//
// DPU Log cleared by: %1
//
typedef struct _evtIML_DPU_CLEARED_60_2
{
  char userName[1];
} EVT_IML_DPU_CLEARED_60_2, *PEVT_IML_DPU_CLEARED_60_2;
    
//
// Server Critical Fault (Service Information: %1)
//
typedef struct _evtIML_RECOV_INPUT_POWER_LOSS_61_1
{
  BYTE powerFailureIndex;
  BYTE powerFailureType;
  BYTE powerFailureArea;
  BYTE powerFailureDeviceBitMap;
  BYTE powerFailureRepairSteps;
  BYTE actionStr;
  char powerFailureGroupString[1];
  //char imlString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_RECOV_INPUT_POWER_LOSS_61_1, *PEVT_IML_RECOV_INPUT_POWER_LOSS_61_1;
    
//
// Server Critical Fault (Service Information: %1) 
//
typedef struct _evtIML_RECOV_POWER_ON_FAULT_61_2
{
  BYTE powerFailureIndex;
  BYTE powerFailureType;
  BYTE powerFailureArea;
  BYTE powerFailureDeviceBitMap;
  BYTE powerFailureRepairSteps;
  BYTE actionStr;
  char powerFailureGroupString[1];
  //char imlString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_RECOV_POWER_ON_FAULT_61_2, *PEVT_IML_RECOV_POWER_ON_FAULT_61_2;
    
//
// Server Critical Fault (Service Information: %1) 
//
typedef struct _evtIML_RECOV_RUNTIME_FAULT_61_3
{
  BYTE powerFailureIndex;
  BYTE powerFailureType;
  BYTE powerFailureArea;
  BYTE powerFailureDeviceBitMap;
  BYTE powerFailureRepairSteps;
  BYTE actionStr;
  char powerFailureGroupString[1];
  //char imlString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_RECOV_RUNTIME_FAULT_61_3, *PEVT_IML_RECOV_RUNTIME_FAULT_61_3;
    
//
// Server Critical Fault (Service Information: %1) %2
//
typedef struct _evtIML_RECOV_MEZZANINE_CARD_FAULT_61_4
{
  BYTE mezzanineCardFailureIndex;
  BYTE mezzanineCardFailureType;
  BYTE mezzanineCardFailureArea;
  BYTE mezzanineFailureDeviceBitMap;
  BYTE mezzanineFailureRepairSteps;
  BYTE actionStr;
  char mezzanineFailureGroupString[1];
  //char imlString[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char gUIDCanonical[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_RECOV_MEZZANINE_CARD_FAULT_61_4, *PEVT_IML_RECOV_MEZZANINE_CARD_FAULT_61_4;
    
//
// %1 (%2) Redfish event from %3
//
typedef struct _evtIML_RDE_GENERIC_IML_62_1
{
  char messageId[1];
  //char messageArguments[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
  //char originOfCondition[1]; Only 1st string is represented in structure.
  //Code must find null terminator of 1st string to determine starting offset of 2nd string
} EVT_IML_RDE_GENERIC_IML_62_1, *PEVT_IML_RDE_GENERIC_IML_62_1;
    
    
//
// _evtIELInfo_1
//
typedef struct _evtIELInfo_1
{
  DWORD number;
} EVT_IEL_INFO_1, *PEVT_IEL_INFO_1;
    
//
// _evtIELInfo_2
//
typedef struct _evtIELInfo_2
{
  DWORD number1;
  DWORD number2;
  char cText[1];
} EVT_IEL_INFO_2, *PEVT_IEL_INFO_2;
    
//
// _evtIELInfo_3
//
typedef struct _evtIELInfo_3
{
  BYTE day;
  BYTE month;
  DWORD year;
  BYTE hours;
  BYTE mins;
  BYTE secs;
} EVT_IEL_INFO_3, *PEVT_IEL_INFO_3;
    
//
// _evtIELInfo_4
//
typedef struct _evtIELInfo_4
{
  DWORD number;
  char cText[1];
} EVT_IEL_INFO_4, *PEVT_IEL_INFO_4;
    
//
// _evtIELInfo_5
//
typedef struct _evtIELInfo_5
{
  char cText[1];
} EVT_IEL_INFO_5, *PEVT_IEL_INFO_5;
    
//
// _evtIELInfo_6
//
typedef struct _evtIELInfo_6
{
  DWORD number1;
  DWORD number2;
} EVT_IEL_INFO_6, *PEVT_IEL_INFO_6;
    
//
// _evtIELInfo_7
//
typedef struct _evtIELInfo_7
{
  DWORD number1;
  DWORD number2;
  DWORD number3;
} EVT_IEL_INFO_7, *PEVT_IEL_INFO_7;
    
//
// _evtIELInfo_8
//
typedef struct _evtIELInfo_8
{
  DWORD number1;
  DWORD number2;
  DWORD number3;
  char cText[1];
} EVT_IEL_INFO_8, *PEVT_IEL_INFO_8;
    
    
typedef union _evtFreeForm
{
  EVT_IML_TEST_IML_EVENT_1_1 imlTestImlEvent_1_1;
  EVT_IML_MACHINE_OVERHEAT_2_19 imlMachineOverheat_2_19;
  EVT_IML_MACHINE_OVERHEAT_EXT_CHASSIS_2_20 imlMachineOverheatExtChassis_2_20;
  EVT_IML_MACHINE_OVERHEAT_STORAGE_2_21 imlMachineOverheatStorage_2_21;
  EVT_IML_MACHINE_OVERHEAT_ENCLOSURE_2_22 imlMachineOverheatEnclosure_2_22;
  EVT_IML_MACHINE_FAN_FAIL_2_23 imlMachineFanFail_2_23;
  EVT_IML_MACHINE_FAN_FAIL_EXT_CHASSIS_2_24 imlMachineFanFailExtChassis_2_24;
  EVT_IML_MACHINE_FAN_FAIL_STORAGE_2_25 imlMachineFanFailStorage_2_25;
  EVT_IML_MACHINE_FAN_FAIL_ENCLOSURE_2_26 imlMachineFanFailEnclosure_2_26;
  EVT_IML_MACHINE_FAN_REMOVED_2_27 imlMachineFanRemoved_2_27;
  EVT_IML_MACHINE_FAN_REMOVED_EXT_CHASSIS_2_28 imlMachineFanRemovedExtChassis_2_28;
  EVT_IML_MACHINE_FAN_REMOVED_STORAGE_2_29 imlMachineFanRemovedStorage_2_29;
  EVT_IML_MACHINE_FAN_REMOVED_ENCLOSURE_2_30 imlMachineFanRemovedEnclosure_2_30;
  EVT_IML_MACHINE_FAN_INSERTED_2_31 imlMachineFanInserted_2_31;
  EVT_IML_MACHINE_FAN_INSERTED_EXT_CHASSIS_2_32 imlMachineFanInsertedExtChassis_2_32;
  EVT_IML_MACHINE_FAN_INSERTED_STORAGE_2_33 imlMachineFanInsertedStorage_2_33;
  EVT_IML_MACHINE_FAN_INSERTED_ENCLOSURE_2_34 imlMachineFanInsertedEnclosure_2_34;
  EVT_IML_MACHINE_FAN_NOT_REDUNDANT_2_35 imlMachineFanNotRedundant_2_35;
  EVT_IML_MACHINE_FAN_NOT_REDUNDANT_EXT_CHASSIS_2_36 imlMachineFanNotRedundantExtChassis_2_36;
  EVT_IML_MACHINE_FAN_NOT_REDUNDANT_STORAGE_2_37 imlMachineFanNotRedundantStorage_2_37;
  EVT_IML_MACHINE_FAN_NOT_REDUNDANT_ENCLOSURE_2_38 imlMachineFanNotRedundantEnclosure_2_38;
  EVT_IML_MACHINE_CRITICAL_OVERHEAT_2_39 imlMachineCriticalOverheat_2_39;
  EVT_IML_MACHINE_CRITICAL_OVERHEAT_THRESHOLD_2_40 imlMachineCriticalOverheatThreshold_2_40;
  EVT_IML_MACHINE_CRITICAL_OVERHEAT_EXT_CHASSIS_2_41 imlMachineCriticalOverheatExtChassis_2_41;
  EVT_IML_MACHINE_CRITICAL_OVERHEAT_EXT_STORAGE_2_42 imlMachineCriticalOverheatExtStorage_2_42;
  EVT_IML_MACHINE_CRITICAL_OVERHEAT_ENCLOSURE_2_43 imlMachineCriticalOverheatEnclosure_2_43;
  EVT_IML_MACHINE_DISK_OVERHEAT_2_44 imlMachineDiskOverheat_2_44;
  EVT_IML_MACHINE_FAN_FAIL_SAS_2_49 imlMachineFanFailSas_2_49;
  EVT_IML_OVERHEAT_SAS_2_50 imlOverheatSas_2_50;
  EVT_IML_MACHINE_FAN_DEGRADE_2_51 imlMachineFanDegrade_2_51;
  EVT_IML_PRE_CAUTION_THRES_EXCEED_2_57 imlPreCautionThresExceed_2_57;
  EVT_IML_MIN_FAN_SPEED_SETTING_2_58 imlMinFanSpeedSetting_2_58;
  EVT_IML_MACHINE_LIQUID_COOLED_PUMP_FAIL_2_59 imlMachineLiquidCooledPumpFail_2_59;
  EVT_IML_MACHINE_LIQUID_COOLING_PUMP_DEGRADED_2_60 imlMachineLiquidCoolingPumpDegraded_2_60;
  EVT_IML_MACHINE_LIQUID_COOLING_NOT_REDUNDANT_2_61 imlMachineLiquidCoolingNotRedundant_2_61;
  EVT_IML_USER_DEF_CAUT_THRES_EXCEED_2_63 imlUserDefCautThresExceed_2_63;
  EVT_IML_USER_DEF_CRIT_THRES_EXCEED_2_64 imlUserDefCritThresExceed_2_64;
  EVT_IML_MACHINE_LIQUID_COOLING_PUMP_MISSING_2_66 imlMachineLiquidCoolingPumpMissing_2_66;
  EVT_IML_TEMP_SENSOR_STALE_2_67 imlTempSensorStale_2_67;
  EVT_IML_TEMP_SENSOR_STALE_2_66_2_104 imlTempSensorStale266_2_104;
  EVT_IML_NO_ACTIVE_RECORDS_FOUND_FOR_LC_MODULE_2_105 imlNoActiveRecordsFoundForLcModule_2_105;
  EVT_IML_LIQUID_COOLING_TIME_LAPSED_WARNING_1_2_107 imlLiquidCoolingTimeLapsedWarning1_2_107;
  EVT_IML_LIQUID_COOLING_TIME_LAPSED_WARNING_2_2_108 imlLiquidCoolingTimeLapsedWarning2_2_108;
  EVT_IML_LIQUID_COOLING_TIME_LAPSED_2_109 imlLiquidCoolingTimeLapsed_2_109;
  EVT_IML_AIR_FILTER_TIME_LAPSED_REMINDER_1_2_110 imlAirFilterTimeLapsedReminder1_2_110;
  EVT_IML_AIR_FILTER_TIME_LAPSED_FINAL_REMINDER_2_111 imlAirFilterTimeLapsedFinalReminder_2_111;
  EVT_IML_TEMP_SENSOR_STALE_2_66_1_2_112 imlTempSensorStale2661_2_112;
  EVT_IML_CHASSIS_HOOD_REMOVAL_2_113 imlChassisHoodRemoval_2_113;
  EVT_IML_LIQUID_COOLING_LEAKAGE_DETECTED_2_137 imlLiquidCoolingLeakageDetected_2_137;
  EVT_IML_DIMM_CORR_ERROR_3_1 imlDimmCorrError_3_1;
  EVT_IML_DIMM_UNCORR_ERROR_3_2 imlDimmUncorrError_3_2;
  EVT_IML_DIMM_HOT_3_3 imlDimmHot_3_3;
  EVT_IML_DIMM_VRD_HOT_3_4 imlDimmVrdHot_3_4;
  EVT_IML_DIMM_VRD_FAULT_WARN_3_5 imlDimmVrdFaultWarn_3_5;
  EVT_IML_DIMM_UNCORR_ERROR_MISC_3_7 imlDimmUncorrErrorMisc_3_7;
  EVT_IML_DDR_INIT_FAILURES_3_8 imlDdrInitFailures_3_8;
  EVT_IML_DIMM_CONFIG_FAILURE_3_9 imlDimmConfigFailure_3_9;
  EVT_IML_MEM_UNCORRECTABLE_ERROR_3_11 imlMemUncorrectableError_3_11;
  EVT_IML_CPU_UNCORR_MCE_5_3 imlCpuUncorrMce_5_3;
  EVT_IML_AMD_CPU_UNCORR_MCE_5_4 imlAmdCpuUncorrMce_5_4;
  EVT_IML_SYS_PROC_PROP_5_6 imlSysProcProp_5_6;
  EVT_IML_PROC_FAULT_OR_UNRECOVERR_5_8 imlProcFaultOrUnrecoverr_5_8;
  EVT_IML_PROC_CORR_ERROR_5_9 imlProcCorrError_5_9;
  EVT_IML_PROC_CRIT_STOP_5_10 imlProcCritStop_5_10;
  EVT_IML_RAS_INT_ERROR_5_11 imlRasIntError_5_11;
  EVT_IML_SOC_VRD_FAULT_WARN_5_13 imlSocVrdFaultWarn_5_13;
  EVT_IML_SOC_VRD_HOT_5_14 imlSocVrdHot_5_14;
  EVT_IML_CORE_VRD_FAULT_WARN_5_15 imlCoreVrdFaultWarn_5_15;
  EVT_IML_CORE_VRD_HOT_5_16 imlCoreVrdHot_5_16;
  EVT_IML_CPU_UNC_ERROR_5_17 imlCpuUncError_5_17;
  EVT_IML_AMD_FATAL_ERROR_ADDC_5_19 imlAmdFatalErrorAddc_5_19;
  EVT_IML_EVT_CPU_MISMTACH_5_24 imlEvtCpuMismtach_5_24;
  EVT_IML_PROC_UNCORRECTABLE_ERROR_5_25 imlProcUncorrectableError_5_25;
  EVT_IML_UPI_ERROR_6_3 imlUpiError_6_3;
  EVT_IML_PCIE_SLOT_ERROR_8_2 imlPcieSlotError_8_2;
  EVT_IML_PCIE_NVME_ERROR_8_3 imlPcieNvmeError_8_3;
  EVT_IML_PCIE_SLOT_ERROR_NO_AER_8_4 imlPcieSlotErrorNoAer_8_4;
  EVT_IML_PCIE_NVME_ERROR_NO_AER_8_5 imlPcieNvmeErrorNoAer_8_5;
  EVT_IML_PCIE_UNCORR_ERROR_8_7 imlPcieUncorrError_8_7;
  EVT_IML_PCIE_UNCORR_ERROR_AER_8_8 imlPcieUncorrErrorAer_8_8;
  EVT_IML_OCP_SLOT_ERROR_8_10 imlOcpSlotError_8_10;
  EVT_IML_OCP_SLOT_ERROR_NO_AER_8_11 imlOcpSlotErrorNoAer_8_11;
  EVT_IML_PCIE_UNCORRECTABLE_ERROR_8_12 imlPcieUncorrectableError_8_12;
  EVT_IML_PWR_FAIL_FLEX_MEZZ_10_549 imlPwrFailFlexMezz_10_549;
  EVT_IML_PWR_FAIL_EBD_STOR_10_550 imlPwrFailEbdStor_10_550;
  EVT_IML_PWR_FAIL_M2_10_551 imlPwrFailM2_10_551;
  EVT_IML_SRIOV_NON_SRIOV_SLOT_10_580 imlSriovNonSriovSlot_10_580;
  EVT_IML_SW1_SW3_ON_10_593 imlSw1Sw3On_10_593;
  EVT_IML_NON_INS_PROC_PCIE_SLT_10_596 imlNonInsProcPcieSlt_10_596;
  EVT_IML_NVM_CORRUPTION_10_614 imlNvmCorruption_10_614;
  EVT_IML_NVM_VAR_CORRUPTION_10_616 imlNvmVarCorruption_10_616;
  EVT_IML_ILO_FW_COM_FAIL_OLD_10_624 imlIloFwComFailOld_10_624;
  EVT_IML_COUNTERFEIT_SMART_MEM_10_626 imlCounterfeitSmartMem_10_626;
  EVT_IML_DIMM_UNC_MEM_ERR_10_644 imlDimmUncMemErr_10_644;
  EVT_IML_SW_RAID_CHG_MODE_10_658 imlSwRaidChgMode_10_658;
  EVT_IML_SW1_ON_10_663 imlSw1On_10_663;
  EVT_IML_SM_STOR_BATT_CFG_ERR_EXCEED_CAP_10_785 imlSmStorBattCfgErrExceedCap_10_785;
  EVT_IML_SM_STOR_BATT_FAIL_COM_FAIL_10_786 imlSmStorBattFailComFail_10_786;
  EVT_IML_DUAL_SD_CFG_ERR_ONE_NOT_INST_10_801 imlDualSdCfgErrOneNotInst_10_801;
  EVT_IML_DUAL_SD_CFG_ERR_ALL_NOT_INST_10_802 imlDualSdCfgErrAllNotInst_10_802;
  EVT_IML_DUAL_SD_CFG_ERR_ONE_FAIL_10_803 imlDualSdCfgErrOneFail_10_803;
  EVT_IML_DUAL_SD_CFG_ERR_ALL_FAIL_10_804 imlDualSdCfgErrAllFail_10_804;
  EVT_IML_DUAL_SD_CFG_ERR_CONFLICT_META_DATA_10_805 imlDualSdCfgErrConflictMetaData_10_805;
  EVT_IML_DUAL_SD_CFG_ERR_SLTX_FAIL_SLT1_ABSENT_10_806 imlDualSdCfgErrSltxFailSlt1Absent_10_806;
  EVT_IML_PMC_FW_ERR_COM_FW_10_809 imlPmcFwErrComFw_10_809;
  EVT_IML_RESTFUL_API_ERR_COM_ILO_FAIL_RESET_ILO_10_819 imlRestfulApiErrComIloFailResetIlo_10_819;
  EVT_IML_RESTFUL_API_ERR_GET_REQ_FAIL_10_820 imlRestfulApiErrGetReqFail_10_820;
  EVT_IML_RESTFUL_API_ERR_PUT_REG_FAIL_10_821 imlRestfulApiErrPutRegFail_10_821;
  EVT_IML_RESTFUL_API_ERR_COM_ILO_FAIL_10_824 imlRestfulApiErrComIloFail_10_824;
  EVT_IML_NVDIMM_BACKUP_ERR_10_832 imlNvdimmBackupErr_10_832;
  EVT_IML_NVDIMM_RESTORE_ERR_10_833 imlNvdimmRestoreErr_10_833;
  EVT_IML_NVDIMM_UNC_ERR_10_834 imlNvdimmUncErr_10_834;
  EVT_IML_NVDIMM_BACKUP_PWR_ERR_10_835 imlNvdimmBackupPwrErr_10_835;
  EVT_IML_NVDIMM_CTRL_ERR_10_836 imlNvdimmCtrlErr_10_836;
  EVT_IML_NVDIMM_ERASE_ERR_10_837 imlNvdimmEraseErr_10_837;
  EVT_IML_NVDIMM_ARMING_ERR_10_838 imlNvdimmArmingErr_10_838;
  EVT_IML_SM_STOR_BATT_NOT_CHARGED_WAIT_10_849 imlSmStorBattNotChargedWait_10_849;
  EVT_IML_SM_STOR_BATT_NOT_CHARGED_NO_WAIT_10_850 imlSmStorBattNotChargedNoWait_10_850;
  EVT_IML_NVDIMM_SANI_OK_10_853 imlNvdimmSaniOk_10_853;
  EVT_IML_NVDIMM_SANI_FAIL_10_854 imlNvdimmSaniFail_10_854;
  EVT_IML_NVDIMM_NON_SMART_MEM_10_855 imlNvdimmNonSmartMem_10_855;
  EVT_IML_INVALID_PROC_RAPL_WATT_10_865 imlInvalidProcRaplWatt_10_865;
  EVT_IML_INVALID_DIMM_RAPL_WATT_10_866 imlInvalidDimmRaplWatt_10_866;
  EVT_IML_NVDIMM_SET_GUID_MISMATCH_10_867 imlNvdimmSetGuidMismatch_10_867;
  EVT_IML_NVDIMM_FW_ERROR_10_868 imlNvdimmFwError_10_868;
  EVT_IML_NEW_NVDIMM_INTERLEAVE_ON_10_881 imlNewNvdimmInterleaveOn_10_881;
  EVT_IML_NEW_NVDIMM_INTERLEAVE_OFF_10_882 imlNewNvdimmInterleaveOff_10_882;
  EVT_IML_NVDIMM_REMOVED_INTERLEAVE_ON_10_883 imlNvdimmRemovedInterleaveOn_10_883;
  EVT_IML_MRC_ERR_INTERLEAVE_ON_10_884 imlMrcErrInterleaveOn_10_884;
  EVT_IML_MRC_ERR_INTERLEAVE_OFF_10_885 imlMrcErrInterleaveOff_10_885;
  EVT_IML_NVDIMM_INTERLEAVE_ON_10_886 imlNvdimmInterleaveOn_10_886;
  EVT_IML_NVDIMM_INTERLEAVE_OFF_10_887 imlNvdimmInterleaveOff_10_887;
  EVT_IML_PROC_TYPE_INTERLEAVE_ON_10_888 imlProcTypeInterleaveOn_10_888;
  EVT_IML_PROC_TYPE_INTERLEAVE_OFF_10_889 imlProcTypeInterleaveOff_10_889;
  EVT_IML_NVDIMM_CFG_ERR_SNC_ON_10_898 imlNvdimmCfgErrSncOn_10_898;
  EVT_IML_NVDIMM_CFG_ERR_SNC_OFF_10_899 imlNvdimmCfgErrSncOff_10_899;
  EVT_IML_CHNL_INTERLEAVE_ON_10_900 imlChnlInterleaveOn_10_900;
  EVT_IML_CHNL_INTERLEAVE_OFF_10_901 imlChnlInterleaveOff_10_901;
  EVT_IML_METADATA_CORRUPTED_INTERLEAVE_ON_10_902 imlMetadataCorruptedInterleaveOn_10_902;
  EVT_IML_METADATA_CORRUPTED_INTERLEAVE_OFF_10_903 imlMetadataCorruptedInterleaveOff_10_903;
  EVT_IML_NVDIMM_EVT_NOTIFY_ERR_INFO_10_916 imlNvdimmEvtNotifyErrInfo_10_916;
  EVT_IML_NVDIMM_PERSIS_LOST_ERR_INFO_10_917 imlNvdimmPersisLostErrInfo_10_917;
  EVT_IML_NVDIMM_PERSIS_RESTORE_INFO_10_918 imlNvdimmPersisRestoreInfo_10_918;
  EVT_IML_NVDIMM_LIFECYCLE_WARN_10_919 imlNvdimmLifecycleWarn_10_919;
  EVT_IML_NVDIMM_SLOT_BACKUP_POWER_ERROR_10_920 imlNvdimmSlotBackupPowerError_10_920;
  EVT_IML_NVDIMM_EXTENDED_DIAGS_INFO_10_921 imlNvdimmExtendedDiagsInfo_10_921;
  EVT_IML_IE_FW_ERR_10_1040 imlIeFwErr_10_1040;
  EVT_IML_SPS_FW_ERR_10_1044 imlSpsFwErr_10_1044;
  EVT_IML_TLS_CFG_VERIFY_FAILED_10_1056 imlTlsCfgVerifyFailed_10_1056;
  EVT_IML_DIMM_CORRECTED_ERROR_THRESHOLD_10_1120 imlDimmCorrectedErrorThreshold_10_1120;
  EVT_IML_DIMM_CORRECTED_ERROR_RATE_10_1121 imlDimmCorrectedErrorRate_10_1121;
  EVT_IML_DIMM_UNC_MIRROR_ENGAGED_10_1123 imlDimmUncMirrorEngaged_10_1123;
  EVT_IML_DIMM_ONLINE_SPARE_COPY_STARTED_10_1124 imlDimmOnlineSpareCopyStarted_10_1124;
  EVT_IML_CHANNEL_CORRECTED_ERROR_THRESHOLD_10_1126 imlChannelCorrectedErrorThreshold_10_1126;
  EVT_IML_PROC_UNC_ERROR_10_1127 imlProcUncError_10_1127;
  EVT_IML_NVDIMM_FW_UPDATE_SUCCESS_10_1152 imlNvdimmFwUpdateSuccess_10_1152;
  EVT_IML_NVDIMM_FW_UPDATE_ERROR_10_1153 imlNvdimmFwUpdateError_10_1153;
  EVT_IML_NVDIMM_FW_IMAGE_INVALID_10_1154 imlNvdimmFwImageInvalid_10_1154;
  EVT_IML_IPT_CORE_BOOST_MISSING_ILO_LICENSE_10_1329 imlIptCoreBoostMissingIloLicense_10_1329;
  EVT_IML_NVME_FW_UPDATE_SUCCESS_10_1360 imlNvmeFwUpdateSuccess_10_1360;
  EVT_IML_NVME_FW_UPDATE_ERROR_10_1361 imlNvmeFwUpdateError_10_1361;
  EVT_IML_AEP_FW_UPDATE_SUCCESS_10_1362 imlAepFwUpdateSuccess_10_1362;
  EVT_IML_AEP_FW_UPDATE_ERROR_10_1363 imlAepFwUpdateError_10_1363;
  EVT_IML_DEVICE_FW_UPDATE_SUCCESS_10_1364 imlDeviceFwUpdateSuccess_10_1364;
  EVT_IML_TPM_FW_UPDATE_ERROR_10_1365 imlTpmFwUpdateError_10_1365;
  EVT_IML_PCIE_FW_UPDATE_SUCCESS_10_1368 imlPcieFwUpdateSuccess_10_1368;
  EVT_IML_PCIE_FW_UPDATE_ERROR_10_1369 imlPcieFwUpdateError_10_1369;
  EVT_IML_AEP_GOAL_CONFIG_FIRMWARE_ERRORS_10_1397 imlAepGoalConfigFirmwareErrors_10_1397;
  EVT_IML_AEP_GOAL_CONFIG_DIMM_NOT_FOUND_ERRORS_10_1398 imlAepGoalConfigDimmNotFoundErrors_10_1398;
  EVT_IML_AEP_GOAL_CONFIG_MEMORY_REQUEST_ERRORS_10_1399 imlAepGoalConfigMemoryRequestErrors_10_1399;
  EVT_IML_AEP_GOAL_CONFIG_INTERLEAVE_ERRORS_10_1400 imlAepGoalConfigInterleaveErrors_10_1400;
  EVT_IML_AEP_BOOT_STATUS_REGISTER_WARNING_10_1401 imlAepBootStatusRegisterWarning_10_1401;
  EVT_IML_PMEM_READ_SCAN_10_1409 imlPmemReadScan_10_1409;
  EVT_IML_ILO_DISCOVERY_FAILED_10_1414 imlIloDiscoveryFailed_10_1414;
  EVT_IML_TPM_MODULE_ERR_10_5686 imlTpmModuleErr_10_5686;
  EVT_IML_SA_HII_NORMAL_STRING_10_5888 imlSaHiiNormalString_10_5888;
  EVT_IML_SA_MEM_SELFTEST_ERROR_10_5891 imlSaMemSelftestError_10_5891;
  EVT_IML_SA_CACHE_BATTERY_REPLACE_10_5893 imlSaCacheBatteryReplace_10_5893;
  EVT_IML_SA_BOOTSTRAP_NV_CHECKSUM_FAIL_10_5895 imlSaBootstrapNvChecksumFail_10_5895;
  EVT_IML_SA_BOOTSTRAP_NV_RESTORED_10_5896 imlSaBootstrapNvRestored_10_5896;
  EVT_IML_SA_DRIVE_NOT_HP_DRIVE_10_5897 imlSaDriveNotHpDrive_10_5897;
  EVT_IML_SA_STRIPE_SIZE_TOO_LARGE_RAID56_10_5905 imlSaStripeSizeTooLargeRaid56_10_5905;
  EVT_IML_SA_RED_REPROG_FAIL_10_5907 imlSaRedReprogFail_10_5907;
  EVT_IML_SA_RED_CHECKSUM_ERROR_10_5908 imlSaRedChecksumError_10_5908;
  EVT_IML_SA_MEM_ERROR_10_5909 imlSaMemError_10_5909;
  EVT_IML_SA_UC_MEDIA_ERROR_10_5910 imlSaUcMediaError_10_5910;
  EVT_IML_SA_DRIVE_OVERHEAT_10_5911 imlSaDriveOverheat_10_5911;
  EVT_IML_SA_SOME_DRIVE_IGNORED_10_5912 imlSaSomeDriveIgnored_10_5912;
  EVT_IML_SA_CONTROLLER_FAIL_10_5913 imlSaControllerFail_10_5913;
  EVT_IML_SA_SMART_DETECT_FAILURE_10_5920 imlSaSmartDetectFailure_10_5920;
  EVT_IML_SA_DRIVE_POS_CHANGE_10_5924 imlSaDrivePosChange_10_5924;
  EVT_IML_SA_CACHE_SIZE_OR_BATT_CHANGE_10_5926 imlSaCacheSizeOrBattChange_10_5926;
  EVT_IML_SA_NEW_DRIVE_10_5927 imlSaNewDrive_10_5927;
  EVT_IML_SA_SHUTDOWN_WB_CACHE_ENABLED_10_5928 imlSaShutdownWbCacheEnabled_10_5928;
  EVT_IML_SA_OPTIMAL_SCAN_10_5929 imlSaOptimalScan_10_5929;
  EVT_IML_SA_ENC_FW_UPGRADE_ERROR_10_5939 imlSaEncFwUpgradeError_10_5939;
  EVT_IML_SA_ENC_PATH_CONFIG_ERROR_10_5941 imlSaEncPathConfigError_10_5941;
  EVT_IML_SA_RED_CABLE_EXCEED_10_5943 imlSaRedCableExceed_10_5943;
  EVT_IML_SA_ENCL_RED_CABLE_EXCEED_10_5944 imlSaEnclRedCableExceed_10_5944;
  EVT_IML_SA_RED_CABLE_NOT_RECOMMENDED_10_5945 imlSaRedCableNotRecommended_10_5945;
  EVT_IML_SA_DRIVE_ERASE_IN_PROGRESS_10_5956 imlSaDriveEraseInProgress_10_5956;
  EVT_IML_SA_DRIVE_ERASE_COMPLETED_10_5957 imlSaDriveEraseCompleted_10_5957;
  EVT_IML_SA_CACHE_FLASH_ERASED_10_5961 imlSaCacheFlashErased_10_5961;
  EVT_IML_SA_RAID_LV_CONFIG_INVALID_10_5972 imlSaRaidLvConfigInvalid_10_5972;
  EVT_IML_SA_CAPACITY_EXP_TEMP_DIS_10_5988 imlSaCapacityExpTempDis_10_5988;
  EVT_IML_SA_RESUMEING_LD_CAPACITY_10_5992 imlSaResumeingLdCapacity_10_5992;
  EVT_IML_SA_DRVE_DIS_FAIL_EXPAN_10_5993 imlSaDrveDisFailExpan_10_5993;
  EVT_IML_SA_DRIVE_FW_UPGRADE_RECOMMENDED_10_6000 imlSaDriveFwUpgradeRecommended_10_6000;
  EVT_IML_SA_OBSOLETE_DATA_IN_CACHE_10_6004 imlSaObsoleteDataInCache_10_6004;
  EVT_IML_SA_STOR_ENC_ERROR_10_6007 imlSaStorEncError_10_6007;
  EVT_IML_SA_RESUMING_AUTO_DATA_10_6008 imlSaResumingAutoData_10_6008;
  EVT_IML_SA_RP_DRIVE_DETECTED_10_6009 imlSaRpDriveDetected_10_6009;
  EVT_IML_SA_DRIVE_ARRAY_CONTROLLER_FAIL_10_6019 imlSaDriveArrayControllerFail_10_6019;
  EVT_IML_SA_LD_FAIL_10_6020 imlSaLdFail_10_6020;
  EVT_IML_SA_DRIVE_ARRAY_NOT_CONFIG_10_6021 imlSaDriveArrayNotConfig_10_6021;
  EVT_IML_SA_DRIVE_ARRAY_RECOV_NEEDED_10_6022 imlSaDriveArrayRecovNeeded_10_6022;
  EVT_IML_SA_DRIVE_ARRAY_DEGRADED_MODE_10_6023 imlSaDriveArrayDegradedMode_10_6023;
  EVT_IML_SA_DRIVE_ARRAY_INCORRECT_DRIVE_REPLACEMENT_10_6024 imlSaDriveArrayIncorrectDriveReplacement_10_6024;
  EVT_IML_SA_DRIVE_ARRAY_NOT_RESPONDING_10_6025 imlSaDriveArrayNotResponding_10_6025;
  EVT_IML_SA_VALID_DATA_IN_WB_CACHE_10_6034 imlSaValidDataInWbCache_10_6034;
  EVT_IML_SA_DATA_IN_WB_CACHE_LOST_10_6035 imlSaDataInWbCacheLost_10_6035;
  EVT_IML_SA_CACHE_BATT_CHARGING_10_6036 imlSaCacheBattCharging_10_6036;
  EVT_IML_SA_WB_CACHE_CONFIG_ERROR_10_6037 imlSaWbCacheConfigError_10_6037;
  EVT_IML_SA_CACHE_NOT_RESPONDING_10_6038 imlSaCacheNotResponding_10_6038;
  EVT_IML_SA_WB_CACHE_BACKUP_FAIL_10_6039 imlSaWbCacheBackupFail_10_6039;
  EVT_IML_SA_DRIVE_ARRAY_CACHE_SELFTEST_FAIL_10_6040 imlSaDriveArrayCacheSelftestFail_10_6040;
  EVT_IML_SA_DRIVE_ARRAY_DRIVE_DIS_WB_CACHE_LOSS_10_6041 imlSaDriveArrayDriveDisWbCacheLoss_10_6041;
  EVT_IML_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_DIS_CONTROLLER_10_6148 imlSaDriveArrayCacheCriErrorDisController_10_6148;
  EVT_IML_SA_DRIVE_ARRAY_SUPER_CAP_NOT_INST_10_6149 imlSaDriveArraySuperCapNotInst_10_6149;
  EVT_IML_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_DIS_ACCESS_10_6152 imlSaDriveArrayCacheCriErrorDisAccess_10_6152;
  EVT_IML_CRYPTO_COMM_FAIL_10_6153 imlCryptoCommFail_10_6153;
  EVT_IML_CRYPTO_MASTER_KEY_FAIL_10_6160 imlCryptoMasterKeyFail_10_6160;
  EVT_IML_CRYPTO_DRIVE_KEY_GET_FAIL_10_6161 imlCryptoDriveKeyGetFail_10_6161;
  EVT_IML_CRYPTO_DRIVE_KEY_INVALID_10_6162 imlCryptoDriveKeyInvalid_10_6162;
  EVT_IML_SA_DRIVE_ARRAY_CACHE_CRI_ERROR_CHARGING_FAIL_10_6163 imlSaDriveArrayCacheCriErrorChargingFail_10_6163;
  EVT_IML_CYRPTO_COMM_SLOT_FAIL_10_6164 imlCyrptoCommSlotFail_10_6164;
  EVT_IML_SA_ENCRY_FAIL_LD_OFFLINE_PW_FAIL_10_6165 imlSaEncryFailLdOfflinePwFail_10_6165;
  EVT_IML_SA_ENCRY_FAIL_LD_NOT_ENCRYPTED_10_6166 imlSaEncryFailLdNotEncrypted_10_6166;
  EVT_IML_SA_ENCRY_EN_CONTROLLER_MASTER_KEY_NOT_SET_10_6167 imlSaEncryEnControllerMasterKeyNotSet_10_6167;
  EVT_IML_SA_ENCRY_FAIL_KM_MODE_MISMATCH_10_6168 imlSaEncryFailKmModeMismatch_10_6168;
  EVT_IML_SA_ENCRY_FAIL_UNSUPP_ROM_10_6169 imlSaEncryFailUnsuppRom_10_6169;
  EVT_IML_SA_ENCRY_FAIL_ENCRY_LD_OFFLINE_10_6176 imlSaEncryFailEncryLdOffline_10_6176;
  EVT_IML_SA_ENCRY_FAIL_FW_VER_NOT_SUPPORT_ENCRY_10_6177 imlSaEncryFailFwVerNotSupportEncry_10_6177;
  EVT_IML_CRYPTO_MASTER_KEY_IMPORT_10_6178 imlCryptoMasterKeyImport_10_6178;
  EVT_IML_SA_ENCRY_FAIL_UNSUPPOR_ILO_FW_10_6179 imlSaEncryFailUnsupporIloFw_10_6179;
  EVT_IML_SA_STOR_CABLE_FAIL_DISCOV_10_6180 imlSaStorCableFailDiscov_10_6180;
  EVT_IML_SA_ENCRY_FAIL_NV_CORRUPT_10_6181 imlSaEncryFailNvCorrupt_10_6181;
  EVT_IML_SA_ENCRY_FAIL_ENCRY_ENG_FAIL_10_6182 imlSaEncryFailEncryEngFail_10_6182;
  EVT_IML_SA_DRIVE_ARRAY_DATA_IN_WB_LOST_10_6193 imlSaDriveArrayDataInWbLost_10_6193;
  EVT_IML_SA_DRIVE_NOT_EXPOSED_10_6194 imlSaDriveNotExposed_10_6194;
  EVT_IML_SA_UNSUPPOR_ARRAY_CONFIG_10_6195 imlSaUnsupporArrayConfig_10_6195;
  EVT_IML_SA_CTRL_FW_UPDATE_PENDING_10_6196 imlSaCtrlFwUpdatePending_10_6196;
  EVT_IML_SA2_DRIVE_ARRAY_CONTROLLER_FAIL_10_6400 imlSa2DriveArrayControllerFail_10_6400;
  EVT_IML_SA2_CONTROLLER_FAIL_10_6401 imlSa2ControllerFail_10_6401;
  EVT_IML_SA2_DRIVE_ARRAY_NOT_CONFIG_10_6402 imlSa2DriveArrayNotConfig_10_6402;
  EVT_IML_SA2_MEM_ERROR_10_6403 imlSa2MemError_10_6403;
  EVT_IML_SA2_RED_REPROG_FAIL_10_6404 imlSa2RedReprogFail_10_6404;
  EVT_IML_SA2_RED_CHECKSUM_ERROR_10_6405 imlSa2RedChecksumError_10_6405;
  EVT_IML_SA2_DRIVE_ARRAY_CONFIG_NOT_COMMIT_10_6406 imlSa2DriveArrayConfigNotCommit_10_6406;
  EVT_IML_SA2_CONTROLLER_DEGRADED_10_6407 imlSa2ControllerDegraded_10_6407;
  EVT_IML_SA2_CONTROLLER_BOOT_PASSWORD_10_6408 imlSa2ControllerBootPassword_10_6408;
  EVT_IML_SA2_DRIVE_NOT_HP_DRIVE_10_6416 imlSa2DriveNotHpDrive_10_6416;
  EVT_IML_SA2_DRIVE_FAIL_10_6417 imlSa2DriveFail_10_6417;
  EVT_IML_SA2_DRIVE_OVERHEAT_10_6418 imlSa2DriveOverheat_10_6418;
  EVT_IML_SA2_DRIVE_ERASE_IN_PROGRESS_10_6419 imlSa2DriveEraseInProgress_10_6419;
  EVT_IML_SA2_SMART_DETECT_FAILURE_10_6420 imlSa2SmartDetectFailure_10_6420;
  EVT_IML_SA2_DRIVE_MEDIA_ERROR_10_6421 imlSa2DriveMediaError_10_6421;
  EVT_IML_SA2_STOR_ENC_ERROR_10_6432 imlSa2StorEncError_10_6432;
  EVT_IML_SA2_ENC_FW_UPGRADE_ERROR_10_6433 imlSa2EncFwUpgradeError_10_6433;
  EVT_IML_SA2_SOME_DRIVE_IGNORED_10_6434 imlSa2SomeDriveIgnored_10_6434;
  EVT_IML_SA2_CONTROLLER_LINK_ERROR_10_6435 imlSa2ControllerLinkError_10_6435;
  EVT_IML_SA2_VALID_DATA_IN_WB_CACHE_10_6448 imlSa2ValidDataInWbCache_10_6448;
  EVT_IML_SA2_DATA_IN_WB_CACHE_LOST_10_6449 imlSa2DataInWbCacheLost_10_6449;
  EVT_IML_SA2_WB_CACHE_CONFIG_ERROR_10_6450 imlSa2WbCacheConfigError_10_6450;
  EVT_IML_SA2_CACHE_BATT_NOT_PRESENT_10_6452 imlSa2CacheBattNotPresent_10_6452;
  EVT_IML_SA2_CACHE_BATT_CHARGING_10_6453 imlSa2CacheBattCharging_10_6453;
  EVT_IML_SA2_DRIVE_ARRAY_CACHE_SELFTEST_FAIL_10_6454 imlSa2DriveArrayCacheSelftestFail_10_6454;
  EVT_IML_SA2_CACHE_BATT_CABLE_MISSING_10_6455 imlSa2CacheBattCableMissing_10_6455;
  EVT_IML_SA2_LD_FAIL_10_6464 imlSa2LdFail_10_6464;
  EVT_IML_SA2_MISSING_LOGICAL_DRIVE_10_6465 imlSa2MissingLogicalDrive_10_6465;
  EVT_IML_SA2_DRIVE_ARRAY_NOT_RESPONDING_10_6466 imlSa2DriveArrayNotResponding_10_6466;
  EVT_IML_SA2_RAID_LV_CONFIG_INVALID_10_6467 imlSa2RaidLvConfigInvalid_10_6467;
  EVT_IML_SA2_IMPORT_FOREIGN_CONFIG_10_6468 imlSa2ImportForeignConfig_10_6468;
  EVT_IML_SA2_DEGRADED_LOGICAL_DRIVE_10_6469 imlSa2DegradedLogicalDrive_10_6469;
  EVT_IML_SA2_DISABLED_LOGICAL_DRIVE_10_6470 imlSa2DisabledLogicalDrive_10_6470;
  EVT_IML_SLTX_SAN_ERR_LNK_DN_2_10_8448 imlSltxSanErrLnkDn2_10_8448;
  EVT_IML_SLTX_SAN_ERR_FABRIC_LOGIN_FAIL_2_10_8449 imlSltxSanErrFabricLoginFail2_10_8449;
  EVT_IML_SLTX_SAN_ERR_NAME_SERVER_LOGIN_FAIL_2_10_8450 imlSltxSanErrNameServerLoginFail2_10_8450;
  EVT_IML_SLTX_SAN_ERR_NO_TARGET_2_10_8451 imlSltxSanErrNoTarget2_10_8451;
  EVT_IML_SLTX_SAN_ERR_ADP_RST_2_10_8452 imlSltxSanErrAdpRst2_10_8452;
  EVT_IML_SLTX_ERR_VPD_NA_2_10_8453 imlSltxErrVpdNa2_10_8453;
  EVT_IML_SLTX_NIC_ERR_2_10_8454 imlSltxNicErr2_10_8454;
  EVT_IML_SLTX_ERR_FW_UPDATE_FAIL_2_10_8455 imlSltxErrFwUpdateFail2_10_8455;
  EVT_IML_SLTX_ERR_FW_RECOVERY_FAIL_2_10_8456 imlSltxErrFwRecoveryFail2_10_8456;
  EVT_IML_SLTX_ERR_APPLY_VC_FAIL_2_10_8457 imlSltxErrApplyVcFail2_10_8457;
  EVT_IML_SLTX_ERR_CONTROLLER_IO_TO_2_10_8464 imlSltxErrControllerIoTo2_10_8464;
  EVT_IML_SLTX_SCSI_ERR_ACQ_DHCP_INIT_ADR_10_8465 imlSltxScsiErrAcqDhcpInitAdr_10_8465;
  EVT_IML_SLTX_SCSI_ERR_ACQ_DHCP_TARG_ADR_10_8466 imlSltxScsiErrAcqDhcpTargAdr_10_8466;
  EVT_IML_SLTX_SCSI_ERR_ACQ_DHCP_ISNS_ADR_2_10_8467 imlSltxScsiErrAcqDhcpIsnsAdr2_10_8467;
  EVT_IML_ISCSI_ERR_LOGIN_2_10_8468 imlIscsiErrLogin2_10_8468;
  EVT_IML_ISCSI_ERR_BOOT_LUN_2_10_8469 imlIscsiErrBootLun2_10_8469;
  EVT_IML_ISCSI_ERR_FW_NOT_RE_RDY_2_10_8470 imlIscsiErrFwNotReRdy2_10_8470;
  EVT_IML_SLTX_MODULE_ERROR_2_10_8473 imlSltxModuleError2_10_8473;
  EVT_IML_SLTX_NVM_OLD_2_10_8480 imlSltxNvmOld2_10_8480;
  EVT_IML_SLTX_NVM_NEW_2_10_8481 imlSltxNvmNew2_10_8481;
  EVT_IML_SLTX_NVM_NEW_STOP_2_10_8482 imlSltxNvmNewStop2_10_8482;
  EVT_IML_DIMM_CORRECTED_ERROR_10_8528 imlDimmCorrectedError_10_8528;
  EVT_IML_ILO_TEST_CERT_FOUND_10_8992 imlIloTestCertFound_10_8992;
  EVT_IML_SLTX_SAN_ERR_LNK_DN_10_9216 imlSltxSanErrLnkDn_10_9216;
  EVT_IML_SLTX_SAN_ERR_FABRIC_LOGIN_FAIL_10_9217 imlSltxSanErrFabricLoginFail_10_9217;
  EVT_IML_SLTX_SAN_ERR_NAME_SERVER_LOGIN_FAIL_10_9218 imlSltxSanErrNameServerLoginFail_10_9218;
  EVT_IML_SLTX_SAN_ERR_NO_TARGET_10_9219 imlSltxSanErrNoTarget_10_9219;
  EVT_IML_SLTX_SAN_ERR_ADP_RST_10_9220 imlSltxSanErrAdpRst_10_9220;
  EVT_IML_SLTX_ERR_VPD_NA_10_9221 imlSltxErrVpdNa_10_9221;
  EVT_IML_SLTX_NIC_ERR_10_9222 imlSltxNicErr_10_9222;
  EVT_IML_SLTX_ERR_FW_UPDATE_FAIL_10_9223 imlSltxErrFwUpdateFail_10_9223;
  EVT_IML_SLTX_ERR_FW_RECOVERY_FAIL_10_9224 imlSltxErrFwRecoveryFail_10_9224;
  EVT_IML_SLTX_ERR_APPLY_VC_FAIL_10_9225 imlSltxErrApplyVcFail_10_9225;
  EVT_IML_SLTX_ERR_CONTROLLER_IO_TO_10_9232 imlSltxErrControllerIoTo_10_9232;
  EVT_IML_ISCSI_ERR_CLIENT_10_9233 imlIscsiErrClient_10_9233;
  EVT_IML_ISCSI_ERR_TARGET_10_9234 imlIscsiErrTarget_10_9234;
  EVT_IML_SLTX_SCSI_ERR_ACQ_DHCP_ISNS_ADR_10_9235 imlSltxScsiErrAcqDhcpIsnsAdr_10_9235;
  EVT_IML_ISCSI_ERR_LOGIN_10_9236 imlIscsiErrLogin_10_9236;
  EVT_IML_ISCSI_ERR_BOOT_LUN_10_9237 imlIscsiErrBootLun_10_9237;
  EVT_IML_ISCSI_ERR_FW_NOT_RE_RDY_10_9238 imlIscsiErrFwNotReRdy_10_9238;
  EVT_IML_SLTX_MODULE_ERROR_10_9241 imlSltxModuleError_10_9241;
  EVT_IML_SLTX_NVM_OLD_10_9248 imlSltxNvmOld_10_9248;
  EVT_IML_SLTX_NVM_NEW_10_9249 imlSltxNvmNew_10_9249;
  EVT_IML_SLTX_NVM_NEW_STOP_10_9250 imlSltxNvmNewStop_10_9250;
  EVT_IML_SLTX_FW_RECOVERY_MODE_10_9251 imlSltxFwRecoveryMode_10_9251;
  EVT_IML_SLTX_CRITICAL_DATA_CORRUPTED_10_9252 imlSltxCriticalDataCorrupted_10_9252;
  EVT_IML_SLTX_TOPOLOGY_MEDIA_CONFLICT_10_9253 imlSltxTopologyMediaConflict_10_9253;
  EVT_IML_SLTX_FW_ROLLBACK_MODE_10_9254 imlSltxFwRollbackMode_10_9254;
  EVT_IML_SERVER_CONFIG_LOCK_PCI_NVME_MISMATCH_10_12548 imlServerConfigLockPciNvmeMismatch_10_12548;
  EVT_IML_TL_ON_UNSUPPORTED_SLOT_10_12549 imlTlOnUnsupportedSlot_10_12549;
  EVT_IML_SERVER_CONFIG_LOCK_DIMM_MISMATCH_10_12550 imlServerConfigLockDimmMismatch_10_12550;
  EVT_IML_SERVER_CONFIG_LOCK_CPU_MISMATCH_10_12552 imlServerConfigLockCpuMismatch_10_12552;
  EVT_IML_SERVER_CONFIG_LOCK_PCI_SLOT_MISMATCH_10_12553 imlServerConfigLockPciSlotMismatch_10_12553;
  EVT_IML_AEP_CAUTION_HEALTH_STATE_FAILURE_10_12563 imlAepCautionHealthStateFailure_10_12563;
  EVT_IML_AEP_CRITICAL_HEALTH_STATE_FAILURE_10_12565 imlAepCriticalHealthStateFailure_10_12565;
  EVT_IML_AEP_FATAL_HEALTH_STATE_FAILURE_10_12566 imlAepFatalHealthStateFailure_10_12566;
  EVT_IML_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_CAUTION_10_12567 imlAepPercentageRemainingAlarmTripCaution_10_12567;
  EVT_IML_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_WARNING_10_12568 imlAepPercentageRemainingAlarmTripWarning_10_12568;
  EVT_IML_AEP_PERCENTAGE_REMAINING_ALARM_TRIP_CRITICAL_10_12569 imlAepPercentageRemainingAlarmTripCritical_10_12569;
  EVT_IML_AEP_LAST_SHUTDOWN_STATE_WARNING_10_12576 imlAepLastShutdownStateWarning_10_12576;
  EVT_IML_TOR_TIMEOUT_SLOT_ERROR_10_12577 imlTorTimeoutSlotError_10_12577;
  EVT_IML_TOR_TIMEOUT_NVME_ERROR_10_12583 imlTorTimeoutNvmeError_10_12583;
  EVT_IML_AEP_SECURE_ERASE_PASS_10_12598 imlAepSecureErasePass_10_12598;
  EVT_IML_AEP_SECURE_ERASE_FAIL_10_12599 imlAepSecureEraseFail_10_12599;
  EVT_IML_ENABLE_ENCRYPTION_FOR_DCPMM_FAILED_10_12611 imlEnableEncryptionForDcpmmFailed_10_12611;
  EVT_IML_DISABLE_ENCRYPTION_FOR_DCPMM_FAILED_10_12613 imlDisableEncryptionForDcpmmFailed_10_12613;
  EVT_IML_PASSPHRASE_MODIFICATION_FOR_DCPMM_FAILED_10_12614 imlPassphraseModificationForDcpmmFailed_10_12614;
  EVT_IML_DCPMM_LOCKED_UNTIL_NEXT_BOOT_10_12616 imlDcpmmLockedUntilNextBoot_10_12616;
  EVT_IML_ENCRYPTION_FOR_DCPMM_DISABLED_10_12619 imlEncryptionForDcpmmDisabled_10_12619;
  EVT_IML_ENCRYPTION_PASSPHRASE_MODIFIED_FOR_DCPMM_10_12620 imlEncryptionPassphraseModifiedForDcpmm_10_12620;
  EVT_IML_ATTEMPTING_UNLOCK_DCPMM_SUCCESS_10_12622 imlAttemptingUnlockDcpmmSuccess_10_12622;
  EVT_IML_SATA_ERASE_FAILURE_10_12624 imlSataEraseFailure_10_12624;
  EVT_IML_SMART_ARRAY_DISK_SECURE_ERASE_FAIL_10_12625 imlSmartArrayDiskSecureEraseFail_10_12625;
  EVT_IML_NVMe_ERASE_FAILURE_10_12626 imlNvmeEraseFailure_10_12626;
  EVT_IML_ENCRYPTION_FOR_DCPMM_ENABLED_10_12629 imlEncryptionForDcpmmEnabled_10_12629;
  EVT_IML_AEP_STATUS_SOCKET_INTERLEAVING_NOT_SUPPORTED_10_12630 imlAepStatusSocketInterleavingNotSupported_10_12630;
  EVT_IML_AEP_STATUS_MISSING_DIMM_IN_INTERLEAVED_SET_10_12631 imlAepStatusMissingDimmInInterleavedSet_10_12631;
  EVT_IML_PCICONFIG_RESET_ERASE_FAIL_10_12632 imlPciconfigResetEraseFail_10_12632;
  EVT_IML_AEP_STATUS_INTERLEAVED_DIMMS_POPULATED_IN_WRONG_ORDER_10_12633 imlAepStatusInterleavedDimmsPopulatedInWrongOrder_10_12633;
  EVT_IML_AEP_STATUS_CHANNEL_INTERLEAVING_NOT_SUPPORTED_10_12635 imlAepStatusChannelInterleavingNotSupported_10_12635;
  EVT_IML_AEP_STATUS_NEW_DIMM_POPULATED_IN_SYSTEM_10_12636 imlAepStatusNewDimmPopulatedInSystem_10_12636;
  EVT_IML_SERVER_CONFIG_LOCK_UNEXPECTED_ERROR_10_12642 imlServerConfigLockUnexpectedError_10_12642;
  EVT_IML_ESKM_CONNECTION_FAILURE_10_12646 imlEskmConnectionFailure_10_12646;
  EVT_IML_CPU_X64_EXCEPTION_10_12647 imlCpuX64Exception_10_12647;
  EVT_IML_ENABLE_ENCRYPTION_FOR_OPAL_FAILED_10_12648 imlEnableEncryptionForOpalFailed_10_12648;
  EVT_IML_DISABLE_ENCRYPTION_FOR_OPAL_FAILED_10_12649 imlDisableEncryptionForOpalFailed_10_12649;
  EVT_IML_PASSPHRASE_MODIFICATION_FOR_OPAL_FAILED_10_12650 imlPassphraseModificationForOpalFailed_10_12650;
  EVT_IML_OPAL_LOCKED_UNTIL_NEXT_BOOT_10_12651 imlOpalLockedUntilNextBoot_10_12651;
  EVT_IML_ENCRYPTION_PASSPHRASE_MODIFIED_FOR_OPAL_10_12652 imlEncryptionPassphraseModifiedForOpal_10_12652;
  EVT_IML_ATTEMPTING_UNLOCK_OPAL_SUCCESS_10_12654 imlAttemptingUnlockOpalSuccess_10_12654;
  EVT_IML_ENCRYPTION_FOR_OPAL_DISABLED_10_12655 imlEncryptionForOpalDisabled_10_12655;
  EVT_IML_ENCRYPTION_FOR_OPAL_ENABLED_10_12658 imlEncryptionForOpalEnabled_10_12658;
  EVT_SL_SED_PASSPHRASE_MODIFIED_10_12659 slSedPassphraseModified_10_12659;
  EVT_SL_DCPMM_DEVICE_ENCRYPTION_ENABLED_10_12662 slDcpmmDeviceEncryptionEnabled_10_12662;
  EVT_SL_DCPMM_DEVICE_ENCRYPTION_DISABLED_10_12663 slDcpmmDeviceEncryptionDisabled_10_12663;
  EVT_SL_DCPMM_DEVICE_PASSPHRASE_MODIFIED_10_12664 slDcpmmDevicePassphraseModified_10_12664;
  EVT_SL_DCPMM_DEVICE_UNLOCKED_10_12665 slDcpmmDeviceUnlocked_10_12665;
  EVT_SL_DCPMM_UNLOCK_EXCESSIVE_FAILURES_10_12666 slDcpmmUnlockExcessiveFailures_10_12666;
  EVT_SL_SL_ILO_TEST_CERT_DETECTED_10_12685 slSlIloTestCertDetected_10_12685;
  EVT_IML_DCPMM_PERSIS_LOST_ERR_INFO_10_12697 imlDcpmmPersisLostErrInfo_10_12697;
  EVT_SL_SECURITY_TLS_VERSION_CHANGED_10_12710 slSecurityTlsVersionChanged_10_12710;
  EVT_IML_PCIE_EDPC_DETECTION_NVME_10_12717 imlPcieEdpcDetectionNvme_10_12717;
  EVT_SL_SECURE_BOOT_AUTH_FAIL_CERT2_10_12718 slSecureBootAuthFailCert2_10_12718;
  EVT_SL_SECURE_BOOT_AUTH_FAIL2_10_12719 slSecureBootAuthFail2_10_12719;
  EVT_IML_ENERGY_SOURCE_NOT_CHARGED_WAIT_10_12725 imlEnergySourceNotChargedWait_10_12725;
  EVT_IML_ENERGY_SOURCE_NOT_CHARGED_NO_WAIT_10_12726 imlEnergySourceNotChargedNoWait_10_12726;
  EVT_IML_NVDIMM_BACKUP_PWR_ERROR_10_12727 imlNvdimmBackupPwrError_10_12727;
  EVT_IML_SANITIZE_CONTROLLER_SECURE_ERASE_FAIL_10_12732 imlSanitizeControllerSecureEraseFail_10_12732;
  EVT_IML_FACTORY_PCIE_ERROR_EXCEEDED_10_12733 imlFactoryPcieErrorExceeded_10_12733;
  EVT_IML_PMEM_CURRENT_BSR_WARNING_10_12739 imlPmemCurrentBsrWarning_10_12739;
  EVT_IML_PWR_FAIL_OCP_10_12742 imlPwrFailOcp_10_12742;
  EVT_IML_EVT_SMARTNIC_TIMEOUT_10_12743 imlEvtSmartnicTimeout_10_12743;
  EVT_IML_SMARTIO_INIT_ERROR_10_12744 imlSmartioInitError_10_12744;
  EVT_IML_PCIE_EDPC_DETECTION_EVENT_10_12747 imlPcieEdpcDetectionEvent_10_12747;
  EVT_IML_HBM_UNC_MEM_ERR_10_12753 imlHbmUncMemErr_10_12753;
  EVT_IML_HBM_CORRECTED_ERROR_THRESHOLD_10_12754 imlHbmCorrectedErrorThreshold_10_12754;
  EVT_IML_DIMM_CFG_POP_ORDER_FIFTH_10_12755 imlDimmCfgPopOrderFifth_10_12755;
  EVT_IML_SMARTIO_REMOVED_FROM_PCI_BUS_10_12756 imlSmartioRemovedFromPciBus_10_12756;
  EVT_IML_HBM_UCE_MAPOUT_10_12757 imlHbmUceMapout_10_12757;
  EVT_IML_NVMEOF_ERR_CLIENT_10_12759 imlNvmeofErrClient_10_12759;
  EVT_IML_NVMEOF_ERR_TARGET_10_12760 imlNvmeofErrTarget_10_12760;
  EVT_IML_NVMEOF_ERR_BOOT_NID_10_12761 imlNvmeofErrBootNid_10_12761;
  EVT_IML_SPS_FIRMWARE_UPDATE_ERROR_10_12762 imlSpsFirmwareUpdateError_10_12762;
  EVT_IML_NVMEOF_ERR_LOGIN_10_12764 imlNvmeofErrLogin_10_12764;
  EVT_IML_NVME_HOTPLUG_SYNC_ERROR_10_12766 imlNvmeHotplugSyncError_10_12766;
  EVT_IML_OCP_NVMEOF_ERR_CLIENT_10_12767 imlOcpNvmeofErrClient_10_12767;
  EVT_IML_OCP_NVMEOF_ERR_TARGET_10_12768 imlOcpNvmeofErrTarget_10_12768;
  EVT_IML_OCP_NVMEOF_ERR_BOOT_NID_10_12769 imlOcpNvmeofErrBootNid_10_12769;
  EVT_IML_OCP_NVMEOF_ERR_LOGIN_10_12770 imlOcpNvmeofErrLogin_10_12770;
  EVT_IML_OCP_ISCSI_ERR_CLIENT_10_12771 imlOcpIscsiErrClient_10_12771;
  EVT_IML_OCP_ISCSI_ERR_TARGET_10_12772 imlOcpIscsiErrTarget_10_12772;
  EVT_IML_OCP_ISCSI_ERR_LOGIN_10_12773 imlOcpIscsiErrLogin_10_12773;
  EVT_IML_OCP_ISCSI_ERR_BOOT_LUN_10_12774 imlOcpIscsiErrBootLun_10_12774;
  EVT_IML_NVMe_SECURE_ERASE_FAILURE_10_12775 imlNvmeSecureEraseFailure_10_12775;
  EVT_IML_NVMe_SECURE_ERASE_START_COMPLETE_10_12776 imlNvmeSecureEraseStartComplete_10_12776;
  EVT_IML_MEM_SPEED_CHANGE_TO_AUTO_10_12777 imlMemSpeedChangeToAuto_10_12777;
  EVT_IML_PCIE_EDR_FAIL_EVENT_10_12778 imlPcieEdrFailEvent_10_12778;
  EVT_IML_PCIE_EDR_FAIL_NVME_10_12779 imlPcieEdrFailNvme_10_12779;
  EVT_IML_PS_MISMATCH_11_21 imlPsMismatch_11_21;
  EVT_IML_PS_STORBAT_REMOVED_11_30 imlPsStorbatRemoved_11_30;
  EVT_IML_PS_POWER_ON_DENIED_11_36 imlPsPowerOnDenied_11_36;
  EVT_IML_PS_FAILURE_11_40 imlPsFailure_11_40;
  EVT_IML_PS_FAILURE_EXT_CHASSIS_11_41 imlPsFailureExtChassis_11_41;
  EVT_IML_PS_FAILURE_STORAGE_11_42 imlPsFailureStorage_11_42;
  EVT_IML_PS_FAILURE_ENCLOSURE_11_43 imlPsFailureEnclosure_11_43;
  EVT_IML_PS_REMOVED_11_44 imlPsRemoved_11_44;
  EVT_IML_PS_REMOVED_EXT_CHASSIS_11_45 imlPsRemovedExtChassis_11_45;
  EVT_IML_PS_REMOVED_STORAGE_11_46 imlPsRemovedStorage_11_46;
  EVT_IML_PS_REMOVED_ENCLOSURE_ADDR_11_47 imlPsRemovedEnclosureAddr_11_47;
  EVT_IML_PS_REMOVED_ENCLOSURE_SERIAL_11_48 imlPsRemovedEnclosureSerial_11_48;
  EVT_IML_PS_INSERTED_11_49 imlPsInserted_11_49;
  EVT_IML_PS_INSERTED_EXT_CHASSIS_11_50 imlPsInsertedExtChassis_11_50;
  EVT_IML_PS_INSERTED_STORAGE_11_51 imlPsInsertedStorage_11_51;
  EVT_IML_PS_INSERTED_ENCLOSURE_ADDR_11_52 imlPsInsertedEnclosureAddr_11_52;
  EVT_IML_PS_INSERTED_ENCLOSURE_SERIAL_11_53 imlPsInsertedEnclosureSerial_11_53;
  EVT_IML_PS_NOT_REDUNDANT_11_54 imlPsNotRedundant_11_54;
  EVT_IML_PS_NOT_REDUNDANT_EXT_CHASSIS_11_55 imlPsNotRedundantExtChassis_11_55;
  EVT_IML_PS_NOT_REDUNDANT_STORAGE_11_56 imlPsNotRedundantStorage_11_56;
  EVT_IML_PS_NOT_REDUNDANT_ENCLOSURE_SERIAL_11_58 imlPsNotRedundantEnclosureSerial_11_58;
  EVT_IML_PS_NOT_REDUNDANT_ENCLOSURE_ADDR_11_59 imlPsNotRedundantEnclosureAddr_11_59;
  EVT_IML_PS_SERVER_POWER_FAULT_11_60 imlPsServerPowerFault_11_60;
  EVT_IML_PS_SERVER_POWER_FAULT_OVERLOAD_11_61 imlPsServerPowerFaultOverload_11_61;
  EVT_IML_PS_STORBAT_FAILED_11_62 imlPsStorbatFailed_11_62;
  EVT_IML_PS_STORBAT_FAILED_INFO_3_11_63 imlPsStorbatFailedInfo3_11_63;
  EVT_IML_PS_STORBAT_FAILED_INFO_4_11_64 imlPsStorbatFailedInfo4_11_64;
  EVT_IML_PS_STORBAT_FAILED_INFO_5_11_65 imlPsStorbatFailedInfo5_11_65;
  EVT_IML_PS_STORBAT_FAILED_INFO_7_11_66 imlPsStorbatFailedInfo7_11_66;
  EVT_IML_PS_STORBAT_FAILED_INFO_11_11_67 imlPsStorbatFailedInfo11_11_67;
  EVT_IML_PS_FAILURE_SAS_11_68 imlPsFailureSas_11_68;
  EVT_IML_PS_AC_LOST_11_82 imlPsAcLost_11_82;
  EVT_IML_PS_SERVER_PWR_EXCEEDED_REDUNDANT_WARN_LIMIT_11_83 imlPsServerPwrExceededRedundantWarnLimit_11_83;
  EVT_IML_PS_RECOVERABLE_FAILURE_11_84 imlPsRecoverableFailure_11_84;
  EVT_IML_PS_BBU_FAILURE_11_85 imlPsBbuFailure_11_85;
  EVT_IML_PS_STORBAT_PREFAIL_INFO_12_11_86 imlPsStorbatPrefailInfo12_11_86;
  EVT_IML_PS_BBU_DISCHARGING_11_87 imlPsBbuDischarging_11_87;
  EVT_IML_PS_SERVER_PWR_EXCEEDED_LIMIT_11_89 imlPsServerPwrExceededLimit_11_89;
  EVT_IML_PS_UNSUPPORTED_11_144 imlPsUnsupported_11_144;
  EVT_IML_MCRPS_OVER_CURRENT_WARNING_11_146 imlMcrpsOverCurrentWarning_11_146;
  EVT_IML_MCRPS_OVER_CURRENT_FAULT_11_147 imlMcrpsOverCurrentFault_11_147;
  EVT_IML_MCRPS_OVER_TEMPERATURE_WARNING_11_148 imlMcrpsOverTemperatureWarning_11_148;
  EVT_IML_MCRPS_OVER_TEMPERATURE_FAULT_11_149 imlMcrpsOverTemperatureFault_11_149;
  EVT_IML_PDB_UNSUPPORTED_11_150 imlPdbUnsupported_11_150;
  EVT_IML_OS_AUTO_SHUTDOWN_14_2 imlOsAutoShutdown_14_2;
  EVT_IML_NIC_LINK_DOWN_1_17_8 imlNicLinkDown1_17_8;
  EVT_IML_NIC_LINK_DOWN_2_17_9 imlNicLinkDown2_17_9;
  EVT_IML_NIC_LINK_CONNECTIVITY_LOST_17_10 imlNicLinkConnectivityLost_17_10;
  EVT_IML_FCA_HOST_CNTRL_STATUS_CHANGE_17_11 imlFcaHostCntrlStatusChange_17_11;
  EVT_IML_NIC_LINK_REDUNDANCY_LOST_17_12 imlNicLinkRedundancyLost_17_12;
  EVT_IML_NIC_ALL_LINK_CONNECTIVITY_LOST_17_13 imlNicAllLinkConnectivityLost_17_13;
  EVT_IML_NIC_SOME_LINK_CONNECTIVITY_UP_17_14 imlNicSomeLinkConnectivityUp_17_14;
  EVT_IML_DPU_SMARTNIC_17_15 imlDpuSmartnic_17_15;
  EVT_IML_NIC_LINK_CONNECTIVITY_UP_DOWN_17_16 imlNicLinkConnectivityUpDown_17_16;
  EVT_IML_NIC_CONFIG_CHANGE_17_17 imlNicConfigChange_17_17;
  EVT_IML_iSCSI_LINK_UP_18_1 imlIscsiLinkUp_18_1;
  EVT_IML_iSCSI_LINK_DOWN_18_2 imlIscsiLinkDown_18_2;
  EVT_IML_ARRAY_CTRL_FAILED_1_19_18 imlArrayCtrlFailed1_19_18;
  EVT_IML_ARRAY_CTRL_FAILED_2_19_19 imlArrayCtrlFailed2_19_19;
  EVT_IML_ARRAY_DEVICE_FAILED_SAS_1_19_20 imlArrayDeviceFailedSas1_19_20;
  EVT_IML_ARRAY_SAS_SMART_WEAR_ERROR_1_19_21 imlArraySasSmartWearError1_19_21;
  EVT_IML_ARRAY_DEVICE_PREDICT_FAIL_SAS_1_19_22 imlArrayDevicePredictFailSas1_19_22;
  EVT_IML_IDA_ACCEL_STAT_CHG_19_23 imlIdaAccelStatChg_19_23;
  EVT_IML_CARRIER_AUTH_FAILURE_19_24 imlCarrierAuthFailure_19_24;
  EVT_IML_PHY_DRIVE_STATUS_19_30 imlPhyDriveStatus_19_30;
  EVT_IML_SAS_PHY_DRIVE_WEAR_STATUS_CHANGE_19_31 imlSasPhyDriveWearStatusChange_19_31;
  EVT_IML_IDE_ATA_DISK_STATUS_CHANGE_19_32 imlIdeAtaDiskStatusChange_19_32;
  EVT_IML_IDA_LOG_DRV_STATUS_CHANGE_19_33 imlIdaLogDrvStatusChange_19_33;
  EVT_IML_IDA_ACCEL_BADDATA_19_35 imlIdaAccelBaddata_19_35;
  EVT_IML_IDA_ACCEL_BATT_FAILED_19_36 imlIdaAccelBattFailed_19_36;
  EVT_IML_STSYS_FAN_STAT_CHG_19_40 imlStsysFanStatChg_19_40;
  EVT_IML_STSYS_TEMP_STAT_CHG_19_41 imlStsysTempStatChg_19_41;
  EVT_IML_STSYS_PWR_STAT_CHG_19_42 imlStsysPwrStatChg_19_42;
  EVT_IML_STSYS_CONN_STAT_CHG_19_43 imlStsysConnStatChg_19_43;
  EVT_IML_IDA_SPR_STAT_CHG_19_44 imlIdaSprStatChg_19_44;
  EVT_IML_ARRAY_DEVICE_DRIVE_INSERTED_REMOVED_19_47 imlArrayDeviceDriveInsertedRemoved_19_47;
  EVT_IML_IDE_ATA_DISK_STATUS_CHANGE2_19_48 imlIdeAtaDiskStatusChange2_19_48;
  EVT_IML_IDE_ATA_DISK_DRIVE_WEAR_STATUS_CHANGE2_19_51 imlIdeAtaDiskDriveWearStatusChange2_19_51;
  EVT_IML_IDE_SATA_DISK_WEAR_STATUS_CHANGE_19_82 imlIdeSataDiskWearStatusChange_19_82;
  EVT_IML_UNCORR_CRITICAL_FAULT_20_7 imlUncorrCriticalFault_20_7;
  EVT_IML_UNRECOV_INPUT_PWR_ERROR_20_8 imlUnrecovInputPwrError_20_8;
  EVT_IML_INPUT_POWER_LOSS_20_10 imlInputPowerLoss_20_10;
  EVT_IML_POWER_ON_FAULT_20_11 imlPowerOnFault_20_11;
  EVT_IML_RUNTIME_FAULT_20_12 imlRuntimeFault_20_12;
  EVT_IML_UNCORR_ERROR_20_14 imlUncorrError_20_14;
  EVT_IML_UNCORR_ERROR_2P_ALI_WITH_LINK_20_15 imlUncorrError2pAliWithLink_20_15;
  EVT_IML_UNCORR_ERROR_WITH_ROOT_COMPLEX_20_16 imlUncorrErrorWithRootComplex_20_16;
  EVT_IML_UNCORR_ERROR_2P_CCIX_WITH_LINK_20_17 imlUncorrError2pCcixWithLink_20_17;
  EVT_IML_UNCORR_ERROR_RASDP_WITH_ROOT_COMPLEX_20_18 imlUncorrErrorRasdpWithRootComplex_20_18;
  EVT_IML_UNCORR_ERROR_MISC_20_19 imlUncorrErrorMisc_20_19;
  EVT_IML_MEZZANINE_CARD_FAULT_20_22 imlMezzanineCardFault_20_22;
  EVT_IML_CPU_ERROR_CODE_20_305 imlCpuErrorCode_20_305;
  EVT_IML_FIRMWARE_FLASHED_32_2 imlFirmwareFlashed_32_2;
  EVT_IML_FI_32_3 imlFi_32_3;
  EVT_IML_FI_REP_FAIL_32_4 imlFiRepFail_32_4;
  EVT_IML_FW_RECOVERY_REQUEST_32_8 imlFwRecoveryRequest_32_8;
  EVT_IML_BIOS_FIRMWARE_UPDATE_32_13 imlBiosFirmwareUpdate_32_13;
  EVT_IML_BIOS_VERSION_MISMATCH_32_14 imlBiosVersionMismatch_32_14;
  EVT_IML_MAINT_IML_CLEARED_33_1 imlMaintImlCleared_33_1;
  EVT_IML_MAINT_NOTE_33_2 imlMaintNote_33_2;
  EVT_IML_SECURE_SYSTEM_ERASE_STATUS_33_3 imlSecureSystemEraseStatus_33_3;
  EVT_SL_SECURITY_LOG_CLEARED_33_4 slSecurityLogCleared_33_4;
  EVT_SL_AHS_CLEARED_33_6 slAhsCleared_33_6;
  EVT_IML_ENCL_INADEQUATE_POWER_ENC_SERIAL_34_27 imlEnclInadequatePowerEncSerial_34_27;
  EVT_IML_ENCL_INADEQUATE_POWER_ENC_ADDR_34_28 imlEnclInadequatePowerEncAddr_34_28;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_RCK_NAME_CHG_1_34_29 imlEnclRackInfrastructureRckNameChg1_34_29;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_RCK_NAME_CHG_2_34_30 imlEnclRackInfrastructureRckNameChg2_34_30;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_NAME_CHG1_34_31 imlEnclRackInfrastructureNameChg1_34_31;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_NAME_CHG2_34_32 imlEnclRackInfrastructureNameChg2_34_32;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_SERVICE_CHG_1_34_33 imlEnclRackInfrastructureServiceChg1_34_33;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_SERVICE_CHG_2_34_34 imlEnclRackInfrastructureServiceChg2_34_34;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_NAME_CONFLICT_1_34_35 imlEnclRackInfrastructureNameConflict1_34_35;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_NAME_CONFLICT_2_34_36 imlEnclRackInfrastructureNameConflict2_34_36;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_UID_CHG_1_34_37 imlEnclRackInfrastructureUidChg1_34_37;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_UID_CHG_2_34_38 imlEnclRackInfrastructureUidChg2_34_38;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_LAN_CHG_1_34_39 imlEnclRackInfrastructureLanChg1_34_39;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_LAN_CHG_2_34_40 imlEnclRackInfrastructureLanChg2_34_40;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_UID_LED_CHG_1_34_41 imlEnclRackInfrastructureUidLedChg1_34_41;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_UID_LED_CHG_2_34_42 imlEnclRackInfrastructureUidLedChg2_34_42;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_CHG_1_34_43 imlEnclRackInfrastructureChg1_34_43;
  EVT_IML_ENCL_RACK_INFRASTRUCTURE_CHG_2_34_44 imlEnclRackInfrastructureChg2_34_44;
  EVT_IML_ENCL_INFRASTRUCTURE_FIRMWARE_MISMATCH_1_34_45 imlEnclInfrastructureFirmwareMismatch1_34_45;
  EVT_IML_ENCL_INFRASTRUCTURE_FIRMWARE_MISMATCH_2_34_46 imlEnclInfrastructureFirmwareMismatch2_34_46;
  EVT_IML_ENCL_POWER_REQUEST_DENIED_1_34_47 imlEnclPowerRequestDenied1_34_47;
  EVT_IML_ENCL_POWER_REQUEST_DENIED_2_34_48 imlEnclPowerRequestDenied2_34_48;
  EVT_IML_MUTUAL_AUTH_ILO_SECURE_ELM_35_17696 imlMutualAuthIloSecureElm_35_17696;
  EVT_IML_MAC_MISSING_IN_EEPROM_35_17756 imlMacMissingInEeprom_35_17756;
  EVT_IML_HPM_AUTH_BIND_FAIL_35_17758 imlHpmAuthBindFail_35_17758;
  EVT_IML_FALLBACK_TEMP_SENSOR_STATUS_35_17771 imlFallbackTempSensorStatus_35_17771;
  EVT_IML_PCAP_REDUCED_PERF_39_1 imlPcapReducedPerf_39_1;
  EVT_IML_PCAP_UNREACHABLE_WITH_CAP_VALUE_39_3 imlPcapUnreachableWithCapValue_39_3;
  EVT_IML_PCAP_FAST_CAP_SET_FAILURE_39_4 imlPcapFastCapSetFailure_39_4;
  EVT_IML_PS_NPSS_UNSUPPORTED_39_5 imlPsNpssUnsupported_39_5;
  EVT_IML_APOLLO_POWER_STATE_CHANGED_39_7 imlApolloPowerStateChanged_39_7;
  EVT_IML_FM_BOOT_FROM_FLASH_ERROR_40_1 imlFmBootFromFlashError_40_1;
  EVT_IML_FM_BOOT_FROM_FLASH_READ_ERROR_40_2 imlFmBootFromFlashReadError_40_2;
  EVT_IML_FM_BOOT_FROM_FLASH_WRITE_ERROR_40_3 imlFmBootFromFlashWriteError_40_3;
  EVT_IML_FM_BOOT_FROM_FLASH_REDUNDANCY_LOST_40_4 imlFmBootFromFlashRedundancyLost_40_4;
  EVT_IML_FM_BOOT_FROM_FLASH_SYC_FAILED_40_5 imlFmBootFromFlashSycFailed_40_5;
  EVT_IML_FM_BOOT_FROM_FLASH_REDUNDANCY_RESTORED_40_7 imlFmBootFromFlashRedundancyRestored_40_7;
  EVT_IML_IL_DEV_NOT_SEATED_OR_MISSING_41_1 imlIlDevNotSeatedOrMissing_41_1;
  EVT_IML_IL_DEV_INSTALLED_STATE_41_2 imlIlDevInstalledState_41_2;
  EVT_IML_IL_DEV_SUPPORTED_STATE_41_3 imlIlDevSupportedState_41_3;
  EVT_IML_IL_DEV_BACKPLANE_TYPE_41_4 imlIlDevBackplaneType_41_4;
  EVT_IML_IL_DEV_SLOT_NUMBER_41_5 imlIlDevSlotNumber_41_5;
  EVT_IML_DIMM_CFG_ERR_NOT_SUPP_AMP_MODE_50_521 imlDimmCfgErrNotSuppAmpMode_50_521;
  EVT_IML_DIMM_CFG_INTERLEAVE_MODE_50_528 imlDimmCfgInterleaveMode_50_528;
  EVT_IML_DIMM_CFG_NO_ECC_50_529 imlDimmCfgNoEcc_50_529;
  EVT_IML_CPU_UPI_INIT_ERROR_50_530 imlCpuUpiInitError_50_530;
  EVT_IML_DIMM_CFG_MAX_SYSTEM_RANKS_50_531 imlDimmCfgMaxSystemRanks_50_531;
  EVT_IML_DIMM_CFG_INVALID_FREQ_50_532 imlDimmCfgInvalidFreq_50_532;
  EVT_IML_DIMM_CPU_INIT_ERROR_50_533 imlDimmCpuInitError_50_533;
  EVT_IML_DIMM_INIT_FATAL_ERROR_50_534 imlDimmInitFatalError_50_534;
  EVT_IML_DIMM_INIT_VOLTAGE_50_535 imlDimmInitVoltage_50_535;
  EVT_IML_DIMM_AMOUNT_EXCEEDS_CPU_SUPPORT_50_537 imlDimmAmountExceedsCpuSupport_50_537;
  EVT_IML_KTI_INIT_ERROR_50_544 imlKtiInitError_50_544;
  EVT_IML_UNKNOWN_MRC_ERROR_50_545 imlUnknownMrcError_50_545;
  EVT_IML_CHANNEL_TRAIN_ERROR_WITHOUT_CHANNEL_NUMBER_50_547 imlChannelTrainErrorWithoutChannelNumber_50_547;
  EVT_IML_DIMM_CFG_POP_ORDER_50_552 imlDimmCfgPopOrder_50_552;
  EVT_IML_DIMM_CFG_UNSUPPORTED_DIMM_50_553 imlDimmCfgUnsupportedDimm_50_553;
  EVT_IML_DIMM_CFG_MAX_CHANNEL_RANKS_50_560 imlDimmCfgMaxChannelRanks_50_560;
  EVT_IML_DIMM_CFG_NO_MEM_50_561 imlDimmCfgNoMem_50_561;
  EVT_IML_DIMM_INIT_ERROR_50_562 imlDimmInitError_50_562;
  EVT_IML_CHANNEL_TRAIN_ERROR_50_563 imlChannelTrainError_50_563;
  EVT_IML_DIMM_TRAIN_ERROR_50_564 imlDimmTrainError_50_564;
  EVT_IML_DIMM_CFG_UDIMM_50_565 imlDimmCfgUdimm_50_565;
  EVT_IML_DIMM_CFG_VOLTAGE_50_566 imlDimmCfgVoltage_50_566;
  EVT_IML_DIMM_CFG_OCTAL_QUAD_RANK_50_567 imlDimmCfgOctalQuadRank_50_567;
  EVT_IML_DIMM_CFG_LRDIMM_MIX_RANK_50_568 imlDimmCfgLrdimmMixRank_50_568;
  EVT_IML_DIMM_CFG_MIXED_DIMM_TYPE_50_569 imlDimmCfgMixedDimmType_50_569;
  EVT_IML_ILO_FW_COM_FAIL_50_624 imlIloFwComFail_50_624;
  EVT_IML_UNSUPP_PROC_CFG_STEP_50_629 imlUnsuppProcCfgStep_50_629;
  EVT_IML_NVDIMM_POP_RDIMM_50_840 imlNvdimmPopRdimm_50_840;
  EVT_IML_NVDIMM_POP_ORDER_ERR_50_848 imlNvdimmPopOrderErr_50_848;
  EVT_IML_NVDIMM_SUPERCAP_50_856 imlNvdimmSupercap_50_856;
  EVT_IML_NVDIMM_CFG_INCOMPATIBLE_50_869 imlNvdimmCfgIncompatible_50_869;
  EVT_IML_EELOG_ERR_NO_SRC_50_905 imlEelogErrNoSrc_50_905;
  EVT_IML_UNSUPPORTED_AEP_DETECTED_50_1107 imlUnsupportedAepDetected_50_1107;
  EVT_IML_DIMM_UNC_ERROR_THRESHOLD_50_1122 imlDimmUncErrorThreshold_50_1122;
  EVT_IML_AEP_FW_UPDATE_NEEDED_50_1344 imlAepFwUpdateNeeded_50_1344;
  EVT_IML_AEP_NOT_SUPPORTED_50_1376 imlAepNotSupported_50_1376;
  EVT_IML_AEP_SOCKET_MISSING_DIMM_50_1377 imlAepSocketMissingDimm_50_1377;
  EVT_IML_AEP_S0C0D0_MISSING_DIMM_50_1378 imlAepS0c0d0MissingDimm_50_1378;
  EVT_IML_DIMM_NOT_SUPPORTED_WITH_AEP_50_1379 imlDimmNotSupportedWithAep_50_1379;
  EVT_IML_AEPS_ON_SAME_CHANNEL_50_1380 imlAepsOnSameChannel_50_1380;
  EVT_IML_AEP_CHANNEL_ORDER_ERROR_50_1381 imlAepChannelOrderError_50_1381;
  EVT_IML_DUAL_DIE_LRDIMM_NO_AEP_50_1382 imlDualDieLrdimmNoAep_50_1382;
  EVT_IML_AEP_NOT_ON_IMC0_50_1383 imlAepNotOnImc0_50_1383;
  EVT_IML_AEP_NOT_ON_CPU1_50_1384 imlAepNotOnCpu1_50_1384;
  EVT_IML_AEP_2LM_3DS_LRDIMMS_50_1392 imlAep2lm3dsLrdimms_50_1392;
  EVT_IML_AEP_2LM_UNBALANCED_50_1393 imlAep2lmUnbalanced_50_1393;
  EVT_IML_AEP_2LM_DIMM_IMC_MISMATCH_50_1395 imlAep2lmDimmImcMismatch_50_1395;
  EVT_IML_AEP_CAP_MISMATCH_50_1396 imlAepCapMismatch_50_1396;
  EVT_IML_DOUBLE_WIDE_MEZZ_INSTALL_ERROR_50_1537 imlDoubleWideMezzInstallError_50_1537;
  EVT_IML_RISER_CABLE_INSTALL_ERROR_50_1538 imlRiserCableInstallError_50_1538;
  EVT_IML_FACTORY_BUILD_ERROR_50_1539 imlFactoryBuildError_50_1539;
  EVT_IML_HPE_CPU_BIST_50_12307 imlHpeCpuBist_50_12307;
  EVT_IML_PCIE_SLOT_FAILURE_50_12320 imlPcieSlotFailure_50_12320;
  EVT_IML_PCIE_FULL_SLOT_FAILURE_50_12321 imlPcieFullSlotFailure_50_12321;
  EVT_IML_PCIE_BIFUR_SLOT_FAILURE_50_12322 imlPcieBifurSlotFailure_50_12322;
  EVT_IML_FLEXLOM_LINK_FAILURE_50_12323 imlFlexlomLinkFailure_50_12323;
  EVT_IML_FLEXLOM_LINK_DEGRADED_50_12324 imlFlexlomLinkDegraded_50_12324;
  EVT_IML_AEP_MIXED_SKU_50_12325 imlAepMixedSku_50_12325;
  EVT_IML_AEP_COMM_FAILURE_50_12326 imlAepCommFailure_50_12326;
  EVT_IML_SMART_PPR_REPAIR_50_12329 imlSmartPprRepair_50_12329;
  EVT_IML_AEP_POP_WARN_50_12336 imlAepPopWarn_50_12336;
  EVT_IML_AUTO_HEAL_RESOLUTION_50_12340 imlAutoHealResolution_50_12340;
  EVT_IML_LTSX_BIOS_ACM_ERROR_50_12346 imlLtsxBiosAcmError_50_12346;
  EVT_IML_LTSX_SINIT_ACM_ERROR_50_12347 imlLtsxSinitAcmError_50_12347;
  EVT_IML_STEP_BEGIN_50_12355 imlStepBegin_50_12355;
  EVT_IML_STEP_END_50_12356 imlStepEnd_50_12356;
  EVT_IML_STEP_REPAIR_50_12357 imlStepRepair_50_12357;
  EVT_IML_DIMM_CFG_POP_ORDER_TERTIARY_50_12358 imlDimmCfgPopOrderTertiary_50_12358;
  EVT_IML_DIMM_CFG_POP_ORDER_FOURTH_50_12359 imlDimmCfgPopOrderFourth_50_12359;
  EVT_IML_AEP_INIT_ERROR_50_12360 imlAepInitError_50_12360;
  EVT_SL_ILO_HIGH_SEC_NO_ADMIN_PWD_50_12361 slIloHighSecNoAdminPwd_50_12361;
  EVT_IML_BPS_2LM_TOO_MUCH_NM_50_12362 imlBps2lmTooMuchNm_50_12362;
  EVT_IML_BPS_2LM_NM_FM_RATIO_50_12363 imlBps2lmNmFmRatio_50_12363;
  EVT_IML_STEP_RESTART_50_12365 imlStepRestart_50_12365;
  EVT_IML_STEP_REPAIR_FAIL_50_12366 imlStepRepairFail_50_12366;
  EVT_IML_PCIE_RETRAIN_ERROR_50_12753 imlPcieRetrainError_50_12753;
  EVT_IML_MPH_CABLE_RISER_INSTALL_ERROR_50_21568 imlMphCableRiserInstallError_50_21568;
  EVT_IML_HBM_TRAIN_FAILURE_50_21571 imlHbmTrainFailure_50_21571;
  EVT_IML_HBM_2LM_UNSUPPORTED_50_21572 imlHbm2lmUnsupported_50_21572;
  EVT_IML_NEWER_PROCESSOR_FW_VERSION_50_21573 imlNewerProcessorFwVersion_50_21573;
  EVT_IML_CFR_PROVISION_FAIL_50_21574 imlCfrProvisionFail_50_21574;
  EVT_IML_HBM_2LM_FM_NM_RATIO_INCORRECTED_50_21578 imlHbm2lmFmNmRatioIncorrected_50_21578;
  EVT_IML_SMART_PPR_AMD_TEST_DURATION_50_21579 imlSmartPprAmdTestDuration_50_21579;
  EVT_IML_HBM_AMT_INIT_50_21580 imlHbmAmtInit_50_21580;
  EVT_IML_HBM_AMT_COMPLETE_50_21581 imlHbmAmtComplete_50_21581;
  EVT_IML_HBM_STEP_REPAIR_50_21582 imlHbmStepRepair_50_21582;
  EVT_IML_DIMM_UNC_ERROR_THRESHOLD_MAPOUT_CHANNEL_50_21583 imlDimmUncErrorThresholdMapoutChannel_50_21583;
  EVT_IML_DIMM_PWR_FAIL_ERROR_50_21585 imlDimmPwrFailError_50_21585;
  EVT_IML_PROCESSOR_FW_MISMATCH_50_21586 imlProcessorFwMismatch_50_21586;
  EVT_IML_CXL_NUM_LIMIT_EXCEEDED_50_21587 imlCxlNumLimitExceeded_50_21587;
  EVT_IML_CXL_CACHE_LIMIT_50_21588 imlCxlCacheLimit_50_21588;
  EVT_IML_CXL_1P1_LIMIT_EXCEED_50_21589 imlCxl1p1LimitExceed_50_21589;
  EVT_IML_CXL_1P1_CFG_ERROR_50_21590 imlCxl1p1CfgError_50_21590;
  EVT_IML_STEP_BEGIN_G12_50_21591 imlStepBeginG12_50_21591;
  EVT_IML_STEP_END_G12_50_21592 imlStepEndG12_50_21592;
  EVT_IML_STEP_REPAIR_G12_50_21593 imlStepRepairG12_50_21593;
  EVT_IML_STEP_REPAIR_FAIL_G12_50_21594 imlStepRepairFailG12_50_21594;
  EVT_IML_STEP_RESTART_G12_50_21595 imlStepRestartG12_50_21595;
  EVT_IML_PCIe_DRIVE_TEMP_FAILED_51_1 imlPcieDriveTempFailed_51_1;
  EVT_IML_PCIe_DRIVE_COND_CHANGE_51_2 imlPcieDriveCondChange_51_2;
  EVT_IML_PCIe_DRIVE_WEAR_STATUS_CHANGE_51_3 imlPcieDriveWearStatusChange_51_3;
  EVT_IML_PCIe_DRIVE_ADDED_POWERON_51_4 imlPcieDriveAddedPoweron_51_4;
  EVT_IML_PCIe_DRIVE_REMOVED_POWEROFF_51_5 imlPcieDriveRemovedPoweroff_51_5;
  EVT_IML_PCIe_DRIVE_INVALID_TYPE_51_6 imlPcieDriveInvalidType_51_6;
  EVT_IML_BACKPLANE_FRU_INVALID_DATA_51_7 imlBackplaneFruInvalidData_51_7;
  EVT_IML_PS_OVERCURRENT_52_1 imlPsOvercurrent_52_1;
  EVT_IML_CHASSIS_PEFORMANCE_52_2 imlChassisPeformance_52_2;
  EVT_IML_ZONE_PERFORMANCE_52_3 imlZonePerformance_52_3;
  EVT_IML_IST_PERFORMANCE_THRESHOLD_53_1 imlIstPerformanceThreshold_53_1;
  EVT_SL_FIPS_KAT_FAILED_54_1 slFipsKatFailed_54_1;
  EVT_SL_HEALTH_TEST_FAILURE_54_3 slHealthTestFailure_54_3;
  EVT_SL_SECDB_IGNORED_BY_55_2 slSecdbIgnoredBy_55_2;
  EVT_SL_SECURITY_STATE_CHANGED_55_4 slSecurityStateChanged_55_4;
  EVT_SL_CERT_VAL_FAILED_55_6 slCertValFailed_55_6;
  EVT_SL_CERT_VAL_INCOMPATIBLE_55_7 slCertValIncompatible_55_7;
  EVT_SL_SSO_TRUST_CHANGE_55_9 slSsoTrustChange_55_9;
  EVT_SL_SSO_ROLE_CHANGE_55_10 slSsoRoleChange_55_10;
  EVT_SL_SSO_LOGIN_REJECT_ERROR_55_11 slSsoLoginRejectError_55_11;
  EVT_SL_SSL_CERT_INSTALLED_55_12 slSslCertInstalled_55_12;
  EVT_SL_HOST_AUTHENTICATION_55_13 slHostAuthentication_55_13;
  EVT_SL_LOGIN_BANNER_55_14 slLoginBanner_55_14;
  EVT_SL_SSH_KEY_55_16 slSshKey_55_16;
  EVT_SL_IPMI_ACCESS_MODIFIED_55_18 slIpmiAccessModified_55_18;
  EVT_SL_NETWORK_CFG_MODIFIED_BY_55_19 slNetworkCfgModifiedBy_55_19;
  EVT_SL_CERTIFICATE_WARNING_BAD_NAME_55_20 slCertificateWarningBadName_55_20;
  EVT_SL_SERVER_SIGNATURE_CHANGED_55_21 slServerSignatureChanged_55_21;
  EVT_SL_ACCESS_SETTINGS_MODIFIED_BY_55_22 slAccessSettingsModifiedBy_55_22;
  EVT_SL_SERVICE_PORT_SETTINGS_MODIFIED_BY_55_23 slServicePortSettingsModifiedBy_55_23;
  EVT_SL_CAC_SETTINGS_MODIFIED_BY_55_24 slCacSettingsModifiedBy_55_24;
  EVT_SL_DG_POL_MOD_55_28 slDgPolMod_55_28;
  EVT_SL_INVALID_FILE_ADDED_55_29 slInvalidFileAdded_55_29;
  EVT_SL_REST_SUBSCRIBER_CA_CERTIFICATE_IMPORTED_BY_55_30 slRestSubscriberCaCertificateImportedBy_55_30;
  EVT_SL_CAC_CERT_ADD_REMOVE_55_31 slCacCertAddRemove_55_31;
  EVT_SL_KEYMGR_ESKM_MODIFY_55_32 slKeymgrEskmModify_55_32;
  EVT_SL_SSO_SRV_55_34 slSsoSrv_55_34;
  EVT_SL_SSO_SRV_REC_DEL_55_35 slSsoSrvRecDel_55_35;
  EVT_SL_FW_RECOVERY_REQUEST_55_36 slFwRecoveryRequest_55_36;
  EVT_SL_FI_SETTINGS_CHANGED_55_37 slFiSettingsChanged_55_37;
  EVT_SL_IMPORT_CERT_LDAP_55_41 slImportCertLdap_55_41;
  EVT_SL_DSA_SIGNED_SSH_KEYS_STATUS_55_67 slDsaSignedSshKeysStatus_55_67;
  EVT_SL_ACCOUNT_SERVICE_SETTINGS_MODIFIED_BY_55_609 slAccountServiceSettingsModifiedBy_55_609;
  EVT_SL_IMPORT_REMOVE_CA_CERT_55_611 slImportRemoveCaCert_55_611;
  EVT_SL_IMPORT_REMOVE_CRL_55_612 slImportRemoveCrl_55_612;
  EVT_SL_EAP_TLS_SETTINGS_MODIFIED_55_614 slEapTlsSettingsModified_55_614;
  EVT_SL_ACE_CERT_STAT_SUCCESS_55_618 slAceCertStatSuccess_55_618;
  EVT_SL_ACE_CERT_STAT_FAILED_55_619 slAceCertStatFailed_55_619;
  EVT_SL_ACE_SCEP_STAT_CHANGED_55_621 slAceScepStatChanged_55_621;
  EVT_SL_ACE_CERT_ISSUE_FAILED_55_622 slAceCertIssueFailed_55_622;
  EVT_SL_ACE_CERT_VAL_FAILED_55_623 slAceCertValFailed_55_623;
  EVT_SL_ACE_CSR_GEN_FAILED_55_624 slAceCsrGenFailed_55_624;
  EVT_SL_CAC_LOGIN_FAILURE_CRL_REVOKED_55_628 slCacLoginFailureCrlRevoked_55_628;
  EVT_SL_SPDM_AUTH_FAILURE_55_629 slSpdmAuthFailure_55_629;
  EVT_SL_SPDM_AUTH_SUCCESS_55_630 slSpdmAuthSuccess_55_630;
  EVT_SL_GLOBAL_COMPONENT_INTEGRITY_55_631 slGlobalComponentIntegrity_55_631;
  EVT_SL_COMPONENT_INTEGRITY_POLICY_55_632 slComponentIntegrityPolicy_55_632;
  EVT_SL_TLS_VERSION_STATUS_55_633 slTlsVersionStatus_55_633;
  EVT_SL_SSL_CERT_COMMON_FAILURES_55_635 slSslCertCommonFailures_55_635;
  EVT_SL_SSL_CERT_SIDE_LOADED_FAILURES_55_636 slSslCertSideLoadedFailures_55_636;
  EVT_SL_SSL_CERT_CA_SIGNED_FAILURES_55_637 slSslCertCaSignedFailures_55_637;
  EVT_SL_SSL_CERT_SIDE_LOADED_SEC_STATE_FAILURES_55_639 slSslCertSideLoadedSecStateFailures_55_639;
  EVT_SL_DEVID_CERT_FAILURE_55_1601 slDevidCertFailure_55_1601;
  EVT_SL_DEVID_SUCCESS_55_1602 slDevidSuccess_55_1602;
  EVT_SL_OPENBMC_TRANSFER_OUT_55_1603 slOpenbmcTransferOut_55_1603;
  EVT_SL_OPENBMC_TRANSFER_IN_55_1604 slOpenbmcTransferIn_55_1604;
  EVT_SL_OPENBMC_INHIBIT_55_1605 slOpenbmcInhibit_55_1605;
  EVT_SL_PCR_MEASUREMENTS_CHANGED_55_1607 slPcrMeasurementsChanged_55_1607;
  EVT_SL_PCR_MEASUREMENTS_UPDATED_55_1608 slPcrMeasurementsUpdated_55_1608;
  EVT_SL_LOGIN_BANNER_MESSAGE_55_5648 slLoginBannerMessage_55_5648;
  EVT_SL_ACCOUNT_STATUS_CHANGED_55_5649 slAccountStatusChanged_55_5649;
  EVT_SL_SECDB_SEC_PARAM_STATUS_55_5652 slSecdbSecParamStatus_55_5652;
  EVT_SL_SECDB_OVERALL_STATUS_55_5653 slSecdbOverallStatus_55_5653;
  EVT_SL_SECDB_OVERALL_STATUS_ILO5_55_5654 slSecdbOverallStatusIlo5_55_5654;
  EVT_SL_WEAK_CIPHERS_STATUS_55_5655 slWeakCiphersStatus_55_5655;
  EVT_SL_HPM_AUTH_FAILURE_55_5656 slHpmAuthFailure_55_5656;
  EVT_SL_TULIP_AUTH_CHECK_FAILURE_55_5657 slTulipAuthCheckFailure_55_5657;
  EVT_SL_SECDB_IGNORED_BY_55_55_5661 slSecdbIgnoredBy55_55_5661;
  EVT_SL_TPM_QUOTE_SIGNATURE_INVALID_55_5664 slTpmQuoteSignatureInvalid_55_5664;
  EVT_SL_UNAUTHORIZED_LOGIN_ATTEMPTS_56_2 slUnauthorizedLoginAttempts_56_2;
  EVT_SL_FI_57_3 slFi_57_3;
  EVT_SL_FI_REP_FAIL_57_4 slFiRepFail_57_4;
  EVT_SL_CHASSIS_HOOD_REMOVAL_58_9 slChassisHoodRemoval_58_9;
  EVT_SL_EVT_OS_SECURITY_SCAN_59_1 slEvtOsSecurityScan_59_1;
  EVT_SL_EVT_OS_SECURITY_ADD_59_2 slEvtOsSecurityAdd_59_2;
  EVT_SL_EVT_OS_SECURITY_REMOVE_59_3 slEvtOsSecurityRemove_59_3;
  EVT_SL_EVT_OS_SECURITY_CORRUPTION_CORRECTION_59_16 slEvtOsSecurityCorruptionCorrection_59_16;
  EVT_IML_SMARTNIC_DPU_60_1 imlSmartnicDpu_60_1;
  EVT_IML_DPU_CLEARED_60_2 imlDpuCleared_60_2;
  EVT_IML_RECOV_INPUT_POWER_LOSS_61_1 imlRecovInputPowerLoss_61_1;
  EVT_IML_RECOV_POWER_ON_FAULT_61_2 imlRecovPowerOnFault_61_2;
  EVT_IML_RECOV_RUNTIME_FAULT_61_3 imlRecovRuntimeFault_61_3;
  EVT_IML_RECOV_MEZZANINE_CARD_FAULT_61_4 imlRecovMezzanineCardFault_61_4;
  EVT_IML_RDE_GENERIC_IML_62_1 imlRdeGenericIml_62_1;
  EVT_IEL_INFO_1 evtIELInfo_1;
  EVT_IEL_INFO_2 evtIELInfo_2;
  EVT_IEL_INFO_3 evtIELInfo_3;
  EVT_IEL_INFO_4 evtIELInfo_4;
  EVT_IEL_INFO_5 evtIELInfo_5;
  EVT_IEL_INFO_6 evtIELInfo_6;
  EVT_IEL_INFO_7 evtIELInfo_7;
  EVT_IEL_INFO_8 evtIELInfo_8;
} EVT_FREE_FORM, *PEVT_FREE_FORM;
    
typedef struct _evtLogEntry
{
  EVT_HEADER hdr;             // Length of event including header
  EVT_FREE_FORM data;         // Free form entry specific
} EVT_LOG_ENTRY, *PEVT_LOG_ENTRY;
    
//------------------------------------------------------------------------------------
//                            END ENCODING STRUCTURES                                 
//------------------------------------------------------------------------------------
    
    
    
//------------------------------------------------------------------------------------
//                            START DECODING STRUCTURES                               
//------------------------------------------------------------------------------------
    
//
// SP Log Entry
//
typedef struct _evtSpLogEntry
{
  WORD evtClass;              // Event class
  WORD evtCode;               // Event code
  BYTE severity;              // Severity
  WORD evtVarLength;          // Length of event including header
  EVT_FREE_FORM data;         // Free form entry specific
} EVT_SP_LOG_ENTRY, *PEVT_SP_LOG_ENTRY;
    
//
// Service Event Data
//
typedef struct _evtServiceEventData
{
  WORD evtClass;              // Event class
  WORD evtCode;               // Event code
  DWORD serEvtID;             // Service Event ID
} EVT_SERVICE_EVENT_DATA, *PEVT_SERVICE_EVENT_DATA;
    
//
// RIS Alert Data
//
typedef struct _evtAlertDetails
{
  BYTE mappedSeverity;        // Event severity to which this alert is mapped
  BYTE paramCount;            // No. of parameters
  BYTE* mappedVarNumbers;     // Array of mapped variables
  char* risAlertID;           // RIS alert ID
} EVT_ALERT_DETAILS, *PEVT_ALERT_DETAILS;
    
typedef struct _evtRISAlertData
{
  WORD evtClass;                   // Event class
  WORD evtCode;                    // Event code
  BYTE alertCount;                 // RIS alert ID
  PEVT_ALERT_DETAILS alertDetails; // Array of alert details
} EVT_RIS_ALERT_DATA, *PEVT_RIS_ALERT_DATA;
    
//
// SNMP Trap Data
//
typedef struct _evtVarBinds
{
  BYTE oidDigitCount;         // OID digits count
  WORD *oid;                  // OID - using WORD because OID value can be greater than 255
  BYTE oidIdxMappedVarCount;  // No. of OID index mapping count
  BYTE *oidIdxMappedVarNum;
  BYTE oidType;               // OID Type - 0x04(String Type), 0x05(Integer Type)
  BYTE mappedVarNum;          // Mapped variable number
} EVT_VARBINDS, *PEVT_VARBINDS;
    
typedef struct _evtTrapDetails
{
  DWORD trapId;               // Trap ID
  BYTE mappedSeverity;        // Event severity to which this trap is mapped to
  DWORD hostTrapFlag;         // indicating the trap condition
  BYTE varBindCount;          // No. of varbinds
  PEVT_VARBINDS varBinds;     // Array of varbinds
} EVT_TRAP_DETAILS, *PEVT_TRAP_DETAILS;
    
typedef struct _evtTrapData
{
  WORD evtClass;                 // Event class
  WORD evtCode;                  // Event code
  BYTE trapCount;                // No. of traps
  PEVT_TRAP_DETAILS trapDetails; // Array of trap details
} EVT_TRAP_DATA, *PEVT_TRAP_DATA;
    
//
// Variable Data
//
typedef struct _varValDesc
{
  BYTE value;                 // enum value
  char* desc;                 // enum description
} VAR_VAL_DESC, *PVAR_VAL_DESC;
    
typedef struct _evtVarDetails
{
  BYTE varWidth;              // Variable width for non-strings. This field has special meaning
                              // for strings. For strings it will store string number. For example
                              // for first string in the binary buffer this value will be set to 1,
                              // for second string this value will be set to 2 and so on. Actual width
                              // of the string will be calculated based on the null termination.
  BYTE varOffset;             // Variable offset in the binary buffer. For strings this always
                              // give the offset of first string in the binary buffer. Actual offset of  
                              // the string will be calculated based on the string no. specified in varWidth.
  BYTE varRepresentation;     // Representation in description text 0x01(Integer), 0x02(Hex),
                              // 0x03(STRING). Note: When variable is an enum then representation should be 0x01(Integer)
  BYTE varRepDigits;          // # of digits to be used for integer or hex value replacement
                              // in the description or action text. This should always be set to 0 for strings.
  BYTE ahsRedactionFlag;      // AHSRedactionFlag (EVT_DISABLED or EVT_ENABLED)
  char* varName;              // Variable name - to be used for AHS redacted bangs
                              // NOTE: Extract this value only if AHS redaction flag is enabled
  BYTE valDescCount;          // No. of value descriptions enums
  PVAR_VAL_DESC valDesc;      // Array of value descriptions enums
} EVT_VAR_DETAILS, *PEVT_VAR_DETAILS;
    
typedef struct _evtVarData
{
  WORD evtClass;              // Event class
  WORD evtCode;               // Event code
  BYTE varDataCount;          // No. of variable data
  PEVT_VAR_DETAILS varDetails; // Array of variable details
} EVT_VAR_DATA, *PEVT_VAR_DATA;
    
//
// Description/Action Data
//
typedef struct _evtArgsToVarDet
{
  BYTE varNum;                // Variable number
  BYTE replaceWith;           // Replace with flag - 0x01(Replace with Variable Value), 
                              // 0x02(Replace with Variable Description).
} EVT_ARGS_TO_VAR_DET, *PEVT_ARGS_TO_VAR_DET;
    
typedef struct _evtTextData
{
  WORD evtClass;              // Event class
  WORD evtCode;               // Event code
  char *msg;                  // Description (Message) string
  BYTE argCount;              // No. of args
  PEVT_ARGS_TO_VAR_DET argsToVarDet; // ArgsToVarDet
} EVT_TEXT_DATA, *PEVT_TEXT_DATA;
    
//
// General Data
//
typedef struct _evtGeneralData
{
  WORD evtClass;              // Event class
  WORD evtCode;               // Event code
  BYTE defSeverity;           // Default severity - 0x02(Informational), 0x06(Repaired), 
                              // 0x09(Caution), 0x0F(Critical)
  BYTE evtType;               // Event type - 0x01(IML), 0x02(IEL), 0x03(SL)
  BYTE repEntity;             // Reporting entity - 0x01(iLO), 0x02(UEFI), 0x04(SA),
                              // 0x08(NIC), 0x10(AMS) - an event can have multiple reporting entities
  QWORD evtCategory;          // Event category - 0x0001 (Security), 0x0002 (Hardware Failure),
                              // 0x0004 (Firmware Failure), 0x0008 (Maintenance), 0x0010 (Administration), 
                              // 0x0020 (Power), 0x0040 (Cooling), 0x0080 (Invalid User Input), 0x0100 (Other), 
                              // 0x0200 (Configuration), bit 9-63(reserved for future)
  BYTE logToAHS;              // Log to AHS flag - 0x00(don't log to AHS), 0x01(log decoded event),
                              // 0x02(log raw event), 0x03(log decoded and raw event)
  BYTE snmpTrap;              // SNMP trap enabled/disabled - 0x00(Disabled), 0x01(Enabled)
  BYTE serEvent;              // Service event enabled/disabled - 0x00(Disabled), 0x01(Enabled)
  BYTE risAlert;              // RIS alert enabled/disabled - 0x00(Disabled), 0x01(Enabled)
  BYTE biosRendering;         // true if IML needs to be rendered on screen - 0x00(Disabled), 0x01(Enabled)
  WORD expectedLen;           // expected raw event (header + variable data) length
} EVT_GENERAL_DATA, *PEVT_GENERAL_DATA;
    
//------------------------------------------------------------------------------------
//                            END DECODING STRUCTURES                                 
//------------------------------------------------------------------------------------
    
    
#pragma pack()
    
#endif // _DATAEXTRACT_INCLUDE_H_
